
-- ============================================================
-- FORGE MINIGAME SKIPPER + AUTO HAMMER + CUSTOM HOTKEY
-- ============================================================

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Variables
local library = nil
local PepsiForgeWindow = nil
local customHotkeyButton = nil
local hammerMinigameUI = nil
local Knit = nil
local ForgeServiceRF = nil

-- State
local isHammerMinigameActive = false
local autoHammerRunning = false
local originalMinigames = {}
local lastHammerTime = 0
local HAMMER_COOLDOWN = 0.5
local hammerTask = nil
local stopRequested = false
local debugMode = false
local mainUIHidden = false

-- Flags
local flags = {
    AutoHammerEnabled = true,
    SkipMeltEnabled = true,
    SkipPourEnabled = true,
    ShowHotkeyButton = true,
    HotkeyEnabled = true
}

-- Hotkey settings
local HOTKEY_IMAGE_URL = "https://imgur.com/Tf03ara" -- Default Imgur image
local HOTKEY_KEY = Enum.KeyCode.RightShift
local buttonPosition = UDim2.new(0, 100, 0, 100) -- Default position

----------------------------------------------------------------
-- CUSTOM HOTKEY BUTTON (Floating with Imgur Image)
----------------------------------------------------------------
local function loadImageFromURL(url)
    local success, result = pcall(function()
        -- Create image label
        local imageLabel = Instance.new("ImageLabel")
        imageLabel.Image = url
        
        -- Try to preload
        pcall(function()
            game:GetService("ContentProvider"):PreloadAsync({url})
        end)
        
        return imageLabel
    end)
    
    if success then
        return result
    else
        warn("[IMAGE] Failed to load image:", result)
        return nil
    end
end

local function createHotkeyButton()
    local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
    
    -- Create screen GUI
    local hotkeyGui = Instance.new("ScreenGui")
    hotkeyGui.Name = "ForgeHotkeyGUI"
    hotkeyGui.ResetOnSpawn = false
    hotkeyGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    hotkeyGui.Parent = playerGui
    
    -- Create the floating button
    customHotkeyButton = Instance.new("ImageButton")
    customHotkeyButton.Name = "HotkeyButton"
    customHotkeyButton.Size = UDim2.new(0, 50, 0, 50) -- Small square
    customHotkeyButton.Position = buttonPosition
    customHotkeyButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    customHotkeyButton.BackgroundTransparency = 0.3
    customHotkeyButton.BorderSizePixel = 0
    customHotkeyButton.AutoButtonColor = false
    
    -- Add rounded corners
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0.2, 0)
    uiCorner.Parent = customHotkeyButton
    
    -- Add stroke/border
    local uiStroke = Instance.new("UIStroke")
    uiStroke.Color = Color3.fromRGB(0, 170, 255)
    uiStroke.Thickness = 2
    uiStroke.Transparency = 0.3
    uiStroke.Parent = customHotkeyButton
    
    -- Load image from Imgur URL
    local imageLabel = Instance.new("ImageLabel")
    imageLabel.Name = "ButtonImage"
    imageLabel.Size = UDim2.new(0.8, 0, 0.8, 0)
    imageLabel.Position = UDim2.new(0.1, 0, 0.1, 0)
    imageLabel.BackgroundTransparency = 1
    imageLabel.Image = HOTKEY_IMAGE_URL
    imageLabel.Parent = customHotkeyButton
    
    -- Preload the image
    task.spawn(function()
        pcall(function()
            game:GetService("ContentProvider"):PreloadAsync({HOTKEY_IMAGE_URL})
        end)
    end)
    
    -- Add tooltip
    local tooltip = Instance.new("TextLabel")
    tooltip.Name = "Tooltip"
    tooltip.Text = "Press: RSHIFT\nDrag to move"
    tooltip.Size = UDim2.new(0, 100, 0, 40)
    tooltip.Position = UDim2.new(1, 10, 0.5, -20)
    tooltip.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    tooltip.TextColor3 = Color3.fromRGB(200, 200, 200)
    tooltip.Font = Enum.Font.Gotham
    tooltip.TextSize = 10
    tooltip.TextWrapped = true
    tooltip.Visible = false
    tooltip.BorderSizePixel = 0
    tooltip.ZIndex = 10
    
    local tooltipCorner = Instance.new("UICorner")
    tooltipCorner.CornerRadius = UDim.new(0.2, 0)
    tooltipCorner.Parent = tooltip
    
    tooltip.Parent = customHotkeyButton
    
    -- Hover effects
    customHotkeyButton.MouseEnter:Connect(function()
        if UserInputService.MouseEnabled then
            tooltip.Visible = true
            TweenService:Create(customHotkeyButton, TweenInfo.new(0.2), {
                BackgroundTransparency = 0.1,
                Size = UDim2.new(0, 55, 0, 55)
            }):Play()
        end
    end)
    
    customHotkeyButton.MouseLeave:Connect(function()
        if UserInputService.MouseEnabled then
            tooltip.Visible = false
            TweenService:Create(customHotkeyButton, TweenInfo.new(0.2), {
                BackgroundTransparency = 0.3,
                Size = UDim2.new(0, 50, 0, 50)
            }):Play()
        end
    end)
    
    -- Click animation
    local function animateClick()
        TweenService:Create(customHotkeyButton, TweenInfo.new(0.1), {
            Size = UDim2.new(0, 45, 0, 45)
        }):Play()
        task.wait(0.1)
        TweenService:Create(customHotkeyButton, TweenInfo.new(0.1), {
            Size = UDim2.new(0, 50, 0, 50)
        }):Play()
    end
    
    -- Function to simulate Right Shift press
    local function pressRightShift()
        if not flags.HotkeyEnabled then
            return
        end
        
        print("[HOTKEY] Simulating Right Shift press")
        
        -- Simulate key press using VirtualInputManager
        pcall(function()
            -- Press down
            VirtualInputManager:SendKeyEvent(true, HOTKEY_KEY, false, nil)
            task.wait(0.05) -- Short press duration
            -- Release
            VirtualInputManager:SendKeyEvent(false, HOTKEY_KEY, false, nil)
        end)
        
        -- Visual feedback
        TweenService:Create(customHotkeyButton, TweenInfo.new(0.1), {
            BackgroundColor3 = Color3.fromRGB(0, 255, 100)
        }):Play()
        task.wait(0.1)
        TweenService:Create(customHotkeyButton, TweenInfo.new(0.1), {
            BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        }):Play()
    end
    
    -- Connect click event
    customHotkeyButton.MouseButton1Click:Connect(function()
        animateClick()
        pressRightShift()
    end)
    
    -- Touch support
    if UserInputService.TouchEnabled then
        customHotkeyButton.TouchTap:Connect(function()
            animateClick()
            pressRightShift()
        end)
    end
    
    -- Drag functionality
    local dragging = false
    local dragStart = nil
    local startPosition = nil
    
    local function updatePosition(input)
        if not dragging then
            return
        end
        
        local delta = input.Position - dragStart
        local newPosition = UDim2.new(
            startPosition.X.Scale,
            startPosition.X.Offset + delta.X,
            startPosition.Y.Scale,
            startPosition.Y.Offset + delta.Y
        )
        
        customHotkeyButton.Position = newPosition
        buttonPosition = newPosition -- Save position
    end
    
    customHotkeyButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPosition = customHotkeyButton.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
        if input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPosition = customHotkeyButton.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    customHotkeyButton.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            if dragging then
                updatePosition(input)
            end
        end
        if input.UserInputType == Enum.UserInputType.Touch then
            if dragging then
                updatePosition(input)
            end
        end
    end)
    
    customHotkeyButton.Parent = hotkeyGui
    
    -- Auto-hide/show based on flag
    customHotkeyButton.Visible = flags.ShowHotkeyButton
    
    return customHotkeyButton
end

-- Function to update hotkey button image
local function updateHotkeyImage(url)
    if customHotkeyButton then
        local imageLabel = customHotkeyButton:FindFirstChild("ButtonImage")
        if imageLabel then
            imageLabel.Image = url
            HOTKEY_IMAGE_URL = url
            
            -- Preload new image
            task.spawn(function()
                pcall(function()
                    game:GetService("ContentProvider"):PreloadAsync({url})
                end)
            end)
            
            print("[HOTKEY] Image updated to:", url)
            return true
        end
    end
    return false
end

-- Function to manually trigger hotkey
local function triggerHotkey()
    if customHotkeyButton then
        customHotkeyButton.MouseButton1Click:Fire()
    end
end

----------------------------------------------------------------
-- LOAD UI LIBRARY (Optional - for main UI)
----------------------------------------------------------------
local function loadUILibrary()
    local success, lib = pcall(function()
        return loadstring(game:GetObjects("rbxassetid://7657867786")[1].Source)()
    end)
    
    if success then
        library = lib
        return true
    else
        warn("[FORGE UI] Failed to load UI Library")
        return false
    end
end

----------------------------------------------------------------
-- INITIALIZE REMOTES
----------------------------------------------------------------
local function initializeRemotes()
    local success, result = pcall(function()
        local Packages = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages")
        Knit = require(Packages.Knit)
        return Knit
    end)
    
    if not success then
        warn("[FORGE SKIP] Failed to load Knit:", result)
        return false
    end
    
    local Packages = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages")
    local Services = Packages.Knit.Services
    
    local success1, result1 = pcall(function()
        ForgeServiceRF = Services.ForgeService.RF.ChangeSequence
        return ForgeServiceRF
    end)
    
    if not success1 then
        warn("[FORGE SKIP] Failed to get ForgeServiceRF:", result1)
        return false
    end
    
    return ForgeServiceRF ~= nil
end

----------------------------------------------------------------
-- MINIGAME DETECTION
----------------------------------------------------------------
local function getHammerMinigameUI()
    local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
    local forgeUI = playerGui:FindFirstChild("Forge")
    if forgeUI then
        return forgeUI:FindFirstChild("HammerMinigame")
    end
    return nil
end

local function isMinigameVisible()
    hammerMinigameUI = getHammerMinigameUI()
    if hammerMinigameUI then
        return hammerMinigameUI.Visible
    end
    return false
end

----------------------------------------------------------------
-- AUTO HAMMER ENGINE
----------------------------------------------------------------
local function hammerLoop()
    print("[HAMMER] Loop started")
    local hammerCount = 0
    local lastCheckTime = tick()
    
    while isHammerMinigameActive and autoHammerRunning and not stopRequested do
        local currentTime = tick()
        if currentTime - lastCheckTime > 0.5 then
            if not isMinigameVisible() then
                print("[HAMMER] Minigame not visible, stopping")
                stopRequested = true
                break
            end
            lastCheckTime = currentTime
        end
        
        local baseDelay = HAMMER_COOLDOWN
        local randomVariation = math.random(-20, 30) / 100
        local totalDelay = math.max(0.3, baseDelay + randomVariation)
        
        local startWait = tick()
        while tick() - startWait < totalDelay do
            if not isHammerMinigameActive then
                return
            end
            if not autoHammerRunning then
                return
            end
            if stopRequested then
                return
            end
            task.wait(0.05)
        end
        
        if not isHammerMinigameActive then
            return
        end
        if not autoHammerRunning then
            return
        end
        if stopRequested then
            return
        end
        
        local success, result = pcall(function()
            return ForgeServiceRF:InvokeServer(
                "Hammer",
                { 
                    ClientTime = workspace:GetServerTimeNow(),
                    RandomSeed = math.random(1, 1000)
                }
            )
        end)
        
        if success then
            hammerCount = hammerCount + 1
            lastHammerTime = tick()
            print("[HAMMER] Hit #" .. hammerCount .. " sent")
        else
            print("[HAMMER] Hit failed:", result)
        end
    end
    
    print("[HAMMER] Loop ended. Total hits: " .. hammerCount)
end

local function startAutoHammer()
    if autoHammerRunning then
        return
    end
    
    print("[HAMMER] Starting auto hammer")
    autoHammerRunning = true
    stopRequested = false
    
    if hammerTask then
        task.cancel(hammerTask)
        hammerTask = nil
    end
    
    hammerTask = task.spawn(function()
        hammerLoop()
        autoHammerRunning = false
        hammerTask = nil
        print("[HAMMER] Task cleaned up")
    end)
end

local function stopAutoHammer()
    print("[HAMMER] Stopping")
    stopRequested = true
    autoHammerRunning = false
    isHammerMinigameActive = false
    
    if hammerTask then
        task.cancel(hammerTask)
        hammerTask = nil
    end
end

----------------------------------------------------------------
-- MINIGAME HOOKING (Simplified)
----------------------------------------------------------------
local function hookMinigameModules()
    local success, ForgeController = pcall(function()
        return Knit.GetController("ForgeController")
    end)
    
    if not success or not ForgeController or not ForgeController.Minigames then
        warn("[FORGE] Cannot hook minigames")
        return false
    end

    print("[FORGE] Found ForgeController")

    if ForgeController.Minigames.MeltMinigame then
        originalMinigames.MeltStart = ForgeController.Minigames.MeltMinigame.Start

        ForgeController.Minigames.MeltMinigame.Start = function(self, data)
            if flags.SkipMeltEnabled then
                print("[FORGE] Skipping Melt")
                local t = workspace:GetServerTimeNow()
                task.wait(0.3)
                return t - 0.001
            elseif originalMinigames.MeltStart then
                return originalMinigames.MeltStart(self, data)
            end
        end
    end

    if ForgeController.Minigames.PourMinigame then
        originalMinigames.PourStart = ForgeController.Minigames.PourMinigame.Start

        ForgeController.Minigames.PourMinigame.Start = function(self, data)
            if flags.SkipPourEnabled then
                print("[FORGE] Skipping Pour")
                local t = workspace:GetServerTimeNow()
                task.wait(0.3)
                return t - 0.001
            elseif originalMinigames.PourStart then
                return originalMinigames.PourStart(self, data)
            end
        end
    end

    if ForgeController.Minigames.HammerMinigame then
        local originalHammerStart = ForgeController.Minigames.HammerMinigame.Start
        local originalHammerStop = ForgeController.Minigames.HammerMinigame.Stop
        
        ForgeController.Minigames.HammerMinigame.Start = function(self, ...)
            print("[FORGE] Hammer minigame started")
            
            isHammerMinigameActive = true
            autoHammerRunning = false
            stopRequested = false
            
            if flags.AutoHammerEnabled then
                task.spawn(function()
                    task.wait(0.5)
                    if isMinigameVisible() then
                        print("[FORGE] Starting auto hammer")
                        startAutoHammer()
                    end
                end)
            end
            
            if originalHammerStart then
                return originalHammerStart(self, ...)
            end
            return nil
        end

        ForgeController.Minigames.HammerMinigame.Stop = function(self, ...)
            print("[FORGE] Hammer minigame stopped")
            stopAutoHammer()
            
            if originalHammerStop then
                return originalHammerStop(self, ...)
            end
            return nil
        end
    end

    print("[FORGE] All minigames hooked")
    return true
end

----------------------------------------------------------------
-- CREATE SIMPLE UI (Optional)
----------------------------------------------------------------
local function createSimpleUI()
    local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ForgeSimpleUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = playerGui

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 150)
    frame.Position = UDim2.new(1, -210, 0, 10)
    frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    frame.BorderColor3 = Color3.fromRGB(60, 60, 60)
    frame.BorderSizePixel = 2
    frame.Parent = screenGui

    local title = Instance.new("TextLabel")
    title.Text = "ðŸ”¨ Forge System"
    title.Size = UDim2.new(1, 0, 0, 30)
    title.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    title.TextColor3 = Color3.fromRGB(255, 200, 100)
    title.Font = Enum.Font.Code
    title.TextSize = 14
    title.Parent = frame

    local hookBtn = Instance.new("TextButton")
    hookBtn.Text = "Activate Hooks"
    hookBtn.Size = UDim2.new(0.8, 0, 0, 30)
    hookBtn.Position = UDim2.new(0.1, 0, 0.3, 0)
    hookBtn.BackgroundColor3 = Color3.fromRGB(60, 140, 60)
    hookBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    hookBtn.Font = Enum.Font.Code
    hookBtn.TextSize = 12
    hookBtn.Parent = frame

    local status = Instance.new("TextLabel")
    status.Text = "Status: Ready"
    status.Size = UDim2.new(1, 0, 0, 20)
    status.Position = UDim2.new(0, 0, 0.7, 0)
    status.BackgroundTransparency = 1
    status.TextColor3 = Color3.fromRGB(200, 200, 200)
    status.Font = Enum.Font.Code
    status.TextSize = 11
    status.Parent = frame

    hookBtn.MouseButton1Click:Connect(function()
        local s = hookMinigameModules()
        if s then
            hookBtn.Text = "Hooks Active"
            hookBtn.BackgroundColor3 = Color3.fromRGB(140, 60, 60)
            status.Text = "Status: Hooks Active"
        end
    end)

    return screenGui
end

----------------------------------------------------------------
-- MAIN SETUP
----------------------------------------------------------------
local function setupForgeSystem()
    print("=== FORGE SYSTEM LOADING ===")
    
    -- Initialize remotes
    local remotesOk = initializeRemotes()
    if not remotesOk then
        warn("Failed to initialize remotes")
        return
    end
    
    -- Create the floating hotkey button FIRST
    createHotkeyButton()
    print("[HOTKEY] Floating button created with Imgur image")
    
    -- Create simple UI (optional)
    createSimpleUI()
    print("[UI] Simple UI created")
    
    -- Add F key toggle for hotkey button
    if UserInputService.KeyboardEnabled then
        UserInputService.InputBegan:Connect(function(input)
            if input.KeyCode == Enum.KeyCode.F then
                if UserInputService:GetFocusedTextBox() == nil then
                    flags.ShowHotkeyButton = not flags.ShowHotkeyButton
                    if customHotkeyButton then
                        customHotkeyButton.Visible = flags.ShowHotkeyButton
                        print("[HOTKEY] Button visibility:", flags.ShowHotkeyButton)
                    end
                end
            end
        end)
    end
    
    -- Cleanup
    Players.LocalPlayer.AncestryChanged:Connect(function()
        if not Players.LocalPlayer.Parent then
            print("Player leaving, cleaning up")
            stopAutoHammer()
        end
    end)
    
    print("=== FORGE SYSTEM READY ===")
    print("Features:")
    print("- Floating hotkey button (drag to move)")
    print("- Press button = RSHIFT key")
    print("- Auto Forge with melt/pour skip")
    print("- Press F to hide/show hotkey button")
    print("- Imgur image support")
end

-- Start the system
task.spawn(function()
    task.wait(5) -- Wait for game to load
    local success, err = pcall(setupForgeSystem)
    if not success then
        warn("Setup error:", err)
    end
end)

-- Return API
return {
    -- Hotkey functions
    PressHotkey = triggerHotkey,
    UpdateHotkeyImage = updateHotkeyImage,
    SetHotkeyEnabled = function(enabled)
        flags.HotkeyEnabled = enabled
        print("[HOTKEY] Enabled:", enabled)
    end,
    ShowHotkeyButton = function(show)
        flags.ShowHotkeyButton = show
        if customHotkeyButton then
            customHotkeyButton.Visible = show
        end
    end,
    
    -- Forge functions
    ActivateHooks = hookMinigameModules,
    StartAutoHammer = startAutoHammer,
    StopAutoHammer = stopAutoHammer,
    
    -- Status
    GetStatus = function()
        return {
            HotkeyEnabled = flags.HotkeyEnabled,
            AutoHammerRunning = autoHammerRunning,
            MinigameActive = isHammerMinigameActive,
            HotkeyButtonVisible = customHotkeyButton and customHotkeyButton.Visible or false
        }
    end
}
