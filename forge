-- ============================================================
-- JAWIRSCRIPT AUTO FORGE SYSTEM
-- ============================================================
-- Gabungan sistem: Forge Skipper + Auto Mine System + Mob ESP & Auto Attack
-- TIDAK DETEKSI PLAYER - HANYA MOB
-- DUKUNGAN MOBILE: Tombol floating untuk toggle GUI
-- ============================================================

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer

-- Remote references
local ForgeServiceRF
local ToolServiceRF
local Knit

-- FORGE STATE
local isHammerMinigameActive = false
local autoHammerRunning = false
local originalMinigames = {}
local lastHammerTime = 0
local HAMMER_COOLDOWN = 0.5
local hammerTask = nil
local stopRequested = false
local debugMode = false
local hammerMinigameUI = nil
local minigameCompleteFlag = false

-- AUTO MINE STATE
local AutoMineEnabled = false
local IsMining = false
local IsAttacking = false
local CurrentMineTarget = nil
local CurrentAttackTarget = nil
local MineConnection = nil
local AttackConnection = nil
local MINING_COOLDOWN = 0.5
local ATTACK_COOLDOWN = 1.0
local MINING_SPEED = 150
local ATTACK_SPEED = 150
local MINING_SEARCH_RADIUS = 1000
local ATTACK_SEARCH_RADIUS = 300
local SelectedRockType = "Any"
local SelectedMobType = "Any"
local NOCLIP_ENABLED = true
local FLY_HEIGHT = 15
local MINE_DELAY = 0.5
local ATTACK_DELAY = 0.3

-- ESP STATE
local highlightedObjects = {}
local highlightedMobs = {}
local ESPEnabled = true
local MobESPEnabled = true
local ESPDistance = 500
local MobESPDistance = 300
local ESPUpdateInterval = 0.5
local lastESPUpdate = 0
local ESPConnection = nil

-- Blacklist untuk player names
local PlayerBlacklist = {}

-- Priority mob untuk auto attack saat mining
local PriorityMobs = {
    ["Blight Pyromancer"] = true,
    ["Reaper"] = true,
    ["Elite Deathaxe Skeleton"] = true,
    ["Elite Rogue Skeleton"] = true,
    ["Deathaxe Skeleton"] = true,
    ["Axe Skeleton"] = true,
    ["Skeleton Rogue"] = true,
    ["Brute Zombie"] = true,
    ["Elite Zombie"] = true,
    ["Delver Zombie"] = true,
    ["Miner Zombie"] = true,
    ["Zombie3"] = true,
    ["Zombie"] = true,
    ["Bomber"] = true,
    ["Blazing Slime"] = true,
    ["Slime"] = true
}

-- Rock configurations
local RockConfigs = {
    Pebble = {
        Name = "Pebble",
        Color = Color3.fromRGB(180, 160, 140),
        SizeOffset = Vector3.new(0, 2, 0),
        BillboardSize = UDim2.new(0, 80, 0, 40),
        TextSize = 16,
        Priority = 12
    },
    Rock = {
        Name = "Rock",
        Color = Color3.fromRGB(150, 120, 90),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 100, 0, 50),
        TextSize = 18,
        Priority = 11
    },
    Boulder = {
        Name = "Boulder",
        Color = Color3.fromRGB(120, 85, 60),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 120, 0, 60),
        TextSize = 20,
        Priority = 10
    },
    ["Lucky Block"] = {
        Name = "Lucky Block",
        Color = Color3.fromRGB(255, 215, 0),
        SizeOffset = Vector3.new(0, 6, 0),
        BillboardSize = UDim2.new(0, 160, 0, 80),
        TextSize = 24,
        Priority = 1
    }
}

-- Mob configurations (HANYA MOB - TIDAK PLAYER)
local MobConfigs = {
    ["Blight Pyromancer"] = {
        Name = "Blight Pyromancer",
        Color = Color3.fromRGB(255, 69, 0),
        SizeOffset = Vector3.new(0, 6, 0),
        BillboardSize = UDim2.new(0, 180, 0, 90),
        TextSize = 22,
        Priority = 1,
        HealthBar = true,
        IsMob = true
    },
    ["Reaper"] = {
        Name = "Reaper",
        Color = Color3.fromRGB(0, 0, 0),
        SizeOffset = Vector3.new(0, 7, 0),
        BillboardSize = UDim2.new(0, 200, 0, 100),
        TextSize = 24,
        Priority = 2,
        HealthBar = true,
        IsMob = true
    },
    ["Elite Deathaxe Skeleton"] = {
        Name = "Elite Deathaxe Skeleton",
        Color = Color3.fromRGB(220, 20, 60),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 170, 0, 85),
        TextSize = 21,
        Priority = 3,
        HealthBar = true,
        IsMob = true
    },
    ["Zombie"] = {
        Name = "Zombie",
        Color = Color3.fromRGB(34, 139, 34),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 140, 0, 70),
        TextSize = 18,
        Priority = 13,
        HealthBar = true,
        IsMob = true
    },
    ["Bomber"] = {
        Name = "Bomber",
        Color = Color3.fromRGB(255, 0, 0),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 160, 0, 80),
        TextSize = 20,
        Priority = 14,
        HealthBar = true,
        IsMob = true
    },
    ["Slime"] = {
        Name = "Slime",
        Color = Color3.fromRGB(0, 255, 0),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 130, 0, 65),
        TextSize = 17,
        Priority = 16,
        HealthBar = true,
        IsMob = true
    }
}

-- GUI STATE
local guiVisible = true
local toggleKeybind = "RightControl"
local WindUI, MainWindow
local MobileToggleButton

-- FLAGS STATE
local flags = {
    AutoHammerEnabled = true,
    SkipMeltEnabled = true,
    SkipPourEnabled = true,
    AutoInitialize = true,
    AutoAttackEnabled = true,
    AttackWhileMining = true
}

-- SETTINGS STATE
local settings = {
    FlySpeed = 150,
    RotationSpeed = 100,
    SmoothTween = true,
    AutoCollect = true,
    ShowDistance = true,
    ShowHealth = true,
    AutoHeal = false,
    HealThreshold = 30
}

----------------------------------------------------------------
-- LOAD WINDUI LIBRARY
----------------------------------------------------------------
local function loadUILibrary()
    local success, lib = pcall(function()
        local url = "https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"
        local response = game:HttpGet(url, true)
        return loadstring(response)()
    end)
    
    if success then
        WindUI = lib
        print("[WINDUI] Library loaded successfully")
        return true
    else
        warn("[WINDUI] Failed to load WindUI Library")
        return false
    end
end

----------------------------------------------------------------
-- INITIALIZE REMOTES
----------------------------------------------------------------
local function initializeRemotes()
    local Packages = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages")
    local success, result = pcall(function()
        Knit = require(Packages.Knit)
    end)
    
    if not success then
        print("[SYSTEM] Knit not found, trying alternative")
        for _, remote in pairs(ReplicatedStorage:GetDescendants()) do
            if remote.Name == "ChangeSequence" and remote:IsA("RemoteFunction") then
                ForgeServiceRF = remote
            elseif remote.Name == "ToolActivated" and remote:IsA("RemoteFunction") then
                ToolServiceRF = remote
            end
        end
        return ForgeServiceRF ~= nil and ToolServiceRF ~= nil
    end
    
    local Services = Packages.Knit.Services
    if Services then
        local ForgeService = Services:FindFirstChild("ForgeService")
        local ToolService = Services:FindFirstChild("ToolService")
        
        if ForgeService then
            ForgeServiceRF = ForgeService.RF.ChangeSequence
        end
        if ToolService then
            ToolServiceRF = ToolService.RF.ToolActivated
        end
    end
    
    return ForgeServiceRF ~= nil and ToolServiceRF ~= nil
end

----------------------------------------------------------------
-- ==================== FORGE SKIPPER ========================
----------------------------------------------------------------

local function getHammerMinigameUI()
    local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
    local forgeUI = playerGui:WaitForChild("Forge", 5)
    if forgeUI then
        return forgeUI:WaitForChild("HammerMinigame", 3)
    end
    return nil
end

local function isMinigameVisible()
    hammerMinigameUI = getHammerMinigameUI()
    if hammerMinigameUI then
        return hammerMinigameUI.Visible
    end
    return false
end

local function isMinigameTimerComplete()
    if not hammerMinigameUI then
        hammerMinigameUI = getHammerMinigameUI()
    end
    
    if hammerMinigameUI then
        local timerBar = hammerMinigameUI:FindFirstChild("Timer")
        if timerBar then
            local bar = timerBar:FindFirstChild("Bar")
            if bar then
                return bar.Size.X.Scale >= 0.95
            end
        end
    end
    return false
end

local function debugLog(message)
    if debugMode then
        print("[DEBUG] " .. message)
    end
end

local function hammerLoop()
    debugLog("Hammer loop started")
    local hammerCount = 0
    local lastCheckTime = tick()
    
    while isHammerMinigameActive and autoHammerRunning and not stopRequested do
        local currentTime = tick()
        if currentTime - lastCheckTime > 0.5 then
            if not isMinigameVisible() or isMinigameTimerComplete() then
                debugLog("Minigame no longer active, stopping hammer")
                stopRequested = true
                break
            end
            lastCheckTime = currentTime
        end
        
        local baseDelay = HAMMER_COOLDOWN
        local randomVariation = math.random(-20, 30) / 100
        local totalDelay = math.max(0.3, baseDelay + randomVariation)
        
        debugLog("Waiting " .. string.format("%.2f", totalDelay) .. "s before next hit")
        
        local startWait = tick()
        while tick() - startWait < totalDelay do
            if not isHammerMinigameActive or not autoHammerRunning or stopRequested then
                debugLog("Breaking during wait")
                return
            end
            task.wait(0.05)
        end
        
        if not isHammerMinigameActive or not autoHammerRunning or stopRequested then
            debugLog("Breaking before send")
            return
        end
        
        local success, result = pcall(function()
            return ForgeServiceRF:InvokeServer(
                "Hammer",
                { 
                    ClientTime = workspace:GetServerTimeNow(),
                    RandomSeed = math.random(1, 1000)
                }
            )
        end)
        
        if success then
            hammerCount = hammerCount + 1
            lastHammerTime = tick()
            debugLog("Hammer hit #" .. hammerCount .. " sent successfully")
            
            if isMinigameTimerComplete() then
                debugLog("Timer completed after hit #" .. hammerCount)
                stopRequested = true
                break
            end
        else
            debugLog("Hammer hit failed: " .. tostring(result))
        end
    end
    
    debugLog("Hammer loop ended. Total hits: " .. hammerCount)
end

local function startAutoHammer()
    if autoHammerRunning then
        debugLog("Auto hammer already running")
        return
    end
    
    debugLog("Starting auto hammer system")
    autoHammerRunning = true
    stopRequested = false
    minigameCompleteFlag = false
    
    if hammerTask then
        task.cancel(hammerTask)
        hammerTask = nil
    end
    
    hammerTask = task.spawn(function()
        hammerLoop()
        
        autoHammerRunning = false
        hammerTask = nil
        debugLog("Auto hammer task cleaned up")
    end)
end

local function stopAutoHammer()
    debugLog("Stopping auto hammer requested")
    stopRequested = true
    autoHammerRunning = false
    isHammerMinigameActive = false
    minigameCompleteFlag = true
    
    if hammerTask then
        task.cancel(hammerTask)
        hammerTask = nil
    end
    
    debugLog("Auto hammer fully stopped")
end

local function hookMinigameModules()
    if not Knit then
        print("[FORGE SKIP] Knit not available")
        return false
    end
    
    local ForgeController = Knit.GetController("ForgeController")
    if not ForgeController or not ForgeController.Minigames then
        warn("[FORGE SKIP] Cannot find ForgeController minigames")
        return false
    end

    print("[FORGE SKIP] Found ForgeController with minigames")

    -- MELT
    if ForgeController.Minigames.MeltMinigame then
        originalMinigames.MeltStart = ForgeController.Minigames.MeltMinigame.Start

        ForgeController.Minigames.MeltMinigame.Start = function(self, data)
            print("[FORGE SKIP] Skipping Melt...")
            local t = workspace:GetServerTimeNow()
            task.wait(0.3)
            print("[FORGE SKIP] Melt skipped!")
            return t - 0.001
        end
    end

    -- POUR
    if ForgeController.Minigames.PourMinigame then
        originalMinigames.PourStart = ForgeController.Minigames.PourMinigame.Start

        ForgeController.Minigames.PourMinigame.Start = function(self, data)
            print("[FORGE SKIP] Skipping Pour...")
            local t = workspace:GetServerTimeNow()
            task.wait(0.3)
            print("[FORGE SKIP] Pour skipped!")
            return t - 0.001
        end
    end

    -- HAMMER
    if ForgeController.Minigames.HammerMinigame then
        local originalHammerStart = ForgeController.Minigames.HammerMinigame.Start
        local originalHammerStop = ForgeController.Minigames.HammerMinigame.Stop
        
        hammerMinigameUI = getHammerMinigameUI()
        
        ForgeController.Minigames.HammerMinigame.Start = function(self, ...)
            print("[FORGE HOOK] ===== HAMMER MINIGAME STARTED =====")
            
            isHammerMinigameActive = true
            autoHammerRunning = false
            stopRequested = false
            minigameCompleteFlag = false
            
            hammerMinigameUI = getHammerMinigameUI()
            
            if flags.AutoHammerEnabled then
                task.spawn(function()
                    task.wait(0.5)
                    if isMinigameVisible() then
                        print("[FORGE HOOK] UI detected, starting auto hammer...")
                        startAutoHammer()
                    end
                end)
            end
            
            if originalHammerStart then
                return originalHammerStart(self, ...)
            end
            return nil
        end

        ForgeController.Minigames.HammerMinigame.Stop = function(self, ...)
            print("[FORGE HOOK] ===== HAMMER MINIGAME STOPPED =====")
            
            stopAutoHammer()
            
            if originalHammerStop then
                return originalHammerStop(self, ...)
            end
            return nil
        end
        
        print("[FORGE HOOK] Hammer minigame hooks installed")
    end

    print("[FORGE SKIP] All minigames hooked successfully")
    return true
end

----------------------------------------------------------------
-- ====================== ESP SYSTEM =========================
----------------------------------------------------------------

local function isPlayerModel(model)
    if not model or not model:IsA("Model") then
        return false
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character == model then
            return true
        end
    end
    
    if model == LocalPlayer.Character then
        return true
    end
    
    local hasLeaderstats = model:FindFirstChild("leaderstats")
    local hasPlayerScripts = model:FindFirstChild("PlayerScripts")
    local hasPlayerGui = model:FindFirstChild("PlayerGui")
    local hasBackpack = model:FindFirstChild("Backpack")
    
    if hasLeaderstats or hasPlayerScripts or hasPlayerGui or hasBackpack then
        return true
    end
    
    if PlayerBlacklist[model.Name] then
        return true
    end
    
    return false
end

local function createRockESP(obj, rockType)
    local config = RockConfigs[rockType]
    if not config then 
        config = {
            Name = rockType,
            Color = Color3.fromRGB(200, 200, 200),
            SizeOffset = Vector3.new(0, 3, 0),
            BillboardSize = UDim2.new(0, 100, 0, 50),
            TextSize = 18,
            Priority = 15
        }
    end
    
    if highlightedObjects[obj] then return end
    
    local BillboardGui = Instance.new('BillboardGui')
    local TextLabel = Instance.new('TextLabel')
    local DistanceLabel = Instance.new('TextLabel')
    
    BillboardGui.Name = "RockESP"
    BillboardGui.Parent = obj
    BillboardGui.AlwaysOnTop = true
    BillboardGui.Size = config.BillboardSize
    BillboardGui.StudsOffset = config.SizeOffset
    BillboardGui.MaxDistance = ESPDistance
    BillboardGui.Enabled = ESPEnabled
    
    TextLabel.Name = "TypeLabel"
    TextLabel.Parent = BillboardGui
    TextLabel.BackgroundTransparency = 1
    TextLabel.Size = UDim2.new(1, 0, 0.6, 0)
    TextLabel.Position = UDim2.new(0, 0, 0, 0)
    TextLabel.Text = config.Name
    TextLabel.TextColor3 = config.Color
    TextLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    TextLabel.TextStrokeTransparency = 0.5
    TextLabel.TextSize = config.TextSize
    TextLabel.Font = Enum.Font.SourceSansBold
    TextLabel.TextScaled = false
    
    DistanceLabel.Name = "DistanceLabel"
    DistanceLabel.Parent = BillboardGui
    DistanceLabel.BackgroundTransparency = 1
    DistanceLabel.Size = UDim2.new(1, 0, 0.4, 0)
    DistanceLabel.Position = UDim2.new(0, 0, 0.6, 0)
    DistanceLabel.Text = "0 studs"
    DistanceLabel.TextColor3 = Color3.new(1, 1, 1)
    DistanceLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    DistanceLabel.TextStrokeTransparency = 0.5
    DistanceLabel.TextSize = config.TextSize - 2
    DistanceLabel.Font = Enum.Font.SourceSans
    
    local highlight = Instance.new("BoxHandleAdornment")
    highlight.Name = "RockHighlight"
    highlight.Adornee = obj
    highlight.AlwaysOnTop = true
    highlight.ZIndex = 10
    highlight.Size = obj.Size + Vector3.new(1, 1, 1)
    highlight.Color3 = config.Color
    highlight.Transparency = 0.2
    highlight.Visible = ESPEnabled
    highlight.Parent = obj
    
    local pointLight = Instance.new("PointLight")
    pointLight.Name = "RockGlow"
    pointLight.Color = config.Color
    pointLight.Brightness = 2
    pointLight.Range = 20
    pointLight.Enabled = ESPEnabled
    pointLight.Shadows = false
    pointLight.Parent = obj
    
    highlightedObjects[obj] = {
        Billboard = BillboardGui,
        Highlight = highlight,
        Light = pointLight,
        Config = config,
        Type = rockType,
        ObjectType = "Rock",
        LastUpdate = tick()
    }
end

local function createMobESP(obj, mobType, model)
    if isPlayerModel(model) then
        return
    end
    
    local config = MobConfigs[mobType]
    if not config then 
        config = {
            Name = mobType,
            Color = Color3.fromRGB(255, 0, 0),
            SizeOffset = Vector3.new(0, 5, 0),
            BillboardSize = UDim2.new(0, 150, 0, 75),
            TextSize = 20,
            Priority = 20,
            HealthBar = false,
            IsMob = true
        }
    end
    
    if highlightedMobs[obj] then return end
    
    local BillboardGui = Instance.new('BillboardGui')
    local TextLabel = Instance.new('TextLabel')
    local DistanceLabel = Instance.new('TextLabel')
    local HealthBar = nil
    local HealthText = nil
    
    BillboardGui.Name = "MobESP"
    BillboardGui.Parent = obj
    BillboardGui.AlwaysOnTop = true
    BillboardGui.Size = config.BillboardSize
    BillboardGui.StudsOffset = config.SizeOffset
    BillboardGui.MaxDistance = MobESPDistance
    BillboardGui.Enabled = MobESPEnabled
    
    TextLabel.Name = "TypeLabel"
    TextLabel.Parent = BillboardGui
    TextLabel.BackgroundTransparency = 1
    TextLabel.Size = UDim2.new(1, 0, 0.4, 0)
    TextLabel.Position = UDim2.new(0, 0, 0, 0)
    TextLabel.Text = config.Name
    TextLabel.TextColor3 = config.Color
    TextLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    TextLabel.TextStrokeTransparency = 0.3
    TextLabel.TextSize = config.TextSize
    TextLabel.Font = Enum.Font.SourceSansBold
    TextLabel.TextScaled = false
    
    DistanceLabel.Name = "DistanceLabel"
    DistanceLabel.Parent = BillboardGui
    DistanceLabel.BackgroundTransparency = 1
    DistanceLabel.Size = UDim2.new(1, 0, 0.3, 0)
    DistanceLabel.Position = UDim2.new(0, 0, 0.4, 0)
    DistanceLabel.Text = "0 studs"
    DistanceLabel.TextColor3 = Color3.new(1, 1, 1)
    DistanceLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    DistanceLabel.TextStrokeTransparency = 0.5
    DistanceLabel.TextSize = config.TextSize - 2
    DistanceLabel.Font = Enum.Font.SourceSans
    
    if config.HealthBar then
        local healthBarFrame = Instance.new("Frame")
        healthBarFrame.Name = "HealthBarFrame"
        healthBarFrame.Size = UDim2.new(0.8, 0, 0.2, 0)
        healthBarFrame.Position = UDim2.new(0.1, 0, 0.7, 0)
        healthBarFrame.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
        healthBarFrame.BorderSizePixel = 1
        healthBarFrame.BorderColor3 = Color3.new(0, 0, 0)
        healthBarFrame.Parent = BillboardGui
        
        local healthBar = Instance.new("Frame")
        healthBar.Name = "HealthBar"
        healthBar.Size = UDim2.new(1, 0, 1, 0)
        healthBar.Position = UDim2.new(0, 0, 0, 0)
        healthBar.BackgroundColor3 = Color3.new(0, 1, 0)
        healthBar.BorderSizePixel = 0
        healthBar.Parent = healthBarFrame
        
        HealthText = Instance.new("TextLabel")
        HealthText.Name = "HealthText"
        HealthText.Size = UDim2.new(1, 0, 0.1, 0)
        HealthText.Position = UDim2.new(0, 0, 0.9, 0)
        HealthText.BackgroundTransparency = 1
        HealthText.Text = "100%"
        HealthText.TextColor3 = Color3.new(1, 1, 1)
        HealthText.TextStrokeTransparency = 0.5
        HealthText.TextSize = config.TextSize - 4
        HealthText.Font = Enum.Font.SourceSansBold
        HealthText.Parent = BillboardGui
        
        HealthBar = healthBar
    end
    
    local highlight = Instance.new("BoxHandleAdornment")
    highlight.Name = "MobHighlight"
    highlight.Adornee = obj
    highlight.AlwaysOnTop = true
    highlight.ZIndex = 10
    highlight.Size = obj.Size + Vector3.new(1, 1, 1)
    highlight.Color3 = config.Color
    highlight.Transparency = 0.3
    highlight.Visible = MobESPEnabled
    highlight.Parent = obj
    
    local pointLight = Instance.new("PointLight")
    pointLight.Name = "MobGlow"
    pointLight.Color = config.Color
    pointLight.Brightness = 3
    pointLight.Range = 25
    pointLight.Enabled = MobESPEnabled
    pointLight.Shadows = false
    pointLight.Parent = obj
    
    highlightedMobs[obj] = {
        Billboard = BillboardGui,
        Highlight = highlight,
        Light = pointLight,
        HealthBar = HealthBar,
        HealthText = HealthText,
        Config = config,
        Type = mobType,
        Model = model,
        ObjectType = "Mob",
        LastUpdate = tick()
    }
end

local function updateRockESP(obj, espData)
    if not obj or not obj.Parent then
        return false
    end
    
    local character = LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    if not humanoidRootPart then return true end
    
    local distance = (obj.Position - humanoidRootPart.Position).Magnitude
    
    if espData.Billboard and espData.Billboard:FindFirstChild("DistanceLabel") then
        espData.Billboard.DistanceLabel.Text = string.format("%.0f studs", distance)
        
        if distance < 50 then
            espData.Billboard.TypeLabel.TextColor3 = Color3.new(0, 1, 0)
        elseif distance < 100 then
            espData.Billboard.TypeLabel.TextColor3 = Color3.new(1, 1, 0)
        else
            espData.Billboard.TypeLabel.TextColor3 = espData.Config.Color
        end
        
        if espData.Highlight then
            espData.Highlight.Color3 = espData.Billboard.TypeLabel.TextColor3
        end
        
        if espData.Light then
            espData.Light.Brightness = math.clamp(30 / distance, 1, 3)
        end
        
        local shouldShow = distance <= ESPDistance
        if SelectedRockType ~= "Any" and SelectedRockType ~= espData.Type then
            shouldShow = false
        end
        
        espData.Billboard.Enabled = ESPEnabled and shouldShow
        espData.Highlight.Visible = ESPEnabled and shouldShow
        espData.Light.Enabled = ESPEnabled and shouldShow
    end
    
    espData.LastUpdate = tick()
    return true
end

local function updateMobESP(obj, espData)
    if not obj or not obj.Parent then
        return false
    end
    
    if isPlayerModel(espData.Model) then
        return false
    end
    
    local character = LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    if not humanoidRootPart then return true end
    
    local distance = (obj.Position - humanoidRootPart.Position).Magnitude
    
    if espData.Billboard and espData.Billboard:FindFirstChild("DistanceLabel") then
        espData.Billboard.DistanceLabel.Text = string.format("%.0f studs", distance)
        
        if distance < 30 then
            espData.Billboard.TypeLabel.TextColor3 = Color3.new(1, 0, 0)
        elseif distance < 100 then
            espData.Billboard.TypeLabel.TextColor3 = Color3.new(1, 0.5, 0)
        else
            espData.Billboard.TypeLabel.TextColor3 = espData.Config.Color
        end
        
        if espData.HealthBar and espData.Model then
            local humanoid = espData.Model:FindFirstChildWhichIsA("Humanoid")
            if humanoid then
                local healthPercent = humanoid.Health / humanoid.MaxHealth
                espData.HealthBar.Size = UDim2.new(healthPercent, 0, 1, 0)
                
                if healthPercent > 0.6 then
                    espData.HealthBar.BackgroundColor3 = Color3.new(0, 1, 0)
                elseif healthPercent > 0.3 then
                    espData.HealthBar.BackgroundColor3 = Color3.new(1, 1, 0)
                else
                    espData.HealthBar.BackgroundColor3 = Color3.new(1, 0, 0)
                end
                
                if espData.HealthText then
                    espData.HealthText.Text = string.format("%.0f%%", healthPercent * 100)
                end
            end
        end
        
        if espData.Highlight then
            espData.Highlight.Color3 = espData.Billboard.TypeLabel.TextColor3
        end
        
        if espData.Light then
            espData.Light.Brightness = math.clamp(40 / distance, 2, 5)
        end
        
        local shouldShow = distance <= MobESPDistance
        if SelectedMobType ~= "Any" and SelectedMobType ~= espData.Type then
            shouldShow = false
        end
        
        espData.Billboard.Enabled = MobESPEnabled and shouldShow
        espData.Highlight.Visible = MobESPEnabled and shouldShow
        espData.Light.Enabled = MobESPEnabled and shouldShow
        
        if espData.HealthBar and espData.HealthBar.Parent then
            espData.HealthBar.Parent.Visible = MobESPEnabled and shouldShow
        end
        if espData.HealthText then
            espData.HealthText.Visible = MobESPEnabled and shouldShow
        end
    end
    
    espData.LastUpdate = tick()
    return true
end

local function scanForRocks()
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj:IsA("Model") then
            local rockType = obj.Name
            if RockConfigs[rockType] then
                local mainPart = obj:FindFirstChild("MainPart") or 
                                obj:FindFirstChild("Part") or 
                                obj:FindFirstChild("Handle") or
                                obj:FindFirstChildWhichIsA("BasePart")
                
                if mainPart then
                    if not highlightedObjects[mainPart] then
                        createRockESP(mainPart, rockType)
                    end
                end
            end
        end
    end
end

local function scanForMobs()
    local livingFolder = Workspace:FindFirstChild("Living")
    
    if livingFolder then
        for _, mobModel in pairs(livingFolder:GetChildren()) do
            if mobModel:IsA("Model") then
                if isPlayerModel(mobModel) then
                    continue
                end
                
                local mobType = mobModel.Name
                
                if MobConfigs[mobType] then
                    local humanoidRootPart = mobModel:FindFirstChild("HumanoidRootPart")
                    local torso = mobModel:FindFirstChild("Torso") or mobModel:FindFirstChild("UpperTorso")
                    local head = mobModel:FindFirstChild("Head")
                    
                    local targetPart = humanoidRootPart or torso or head
                    
                    if targetPart then
                        if not highlightedMobs[targetPart] then
                            createMobESP(targetPart, mobType, mobModel)
                        end
                    end
                else
                    local humanoid = mobModel:FindFirstChildWhichIsA("Humanoid")
                    if humanoid and not isPlayerModel(mobModel) then
                        local humanoidRootPart = mobModel:FindFirstChild("HumanoidRootPart")
                        local torso = mobModel:FindFirstChild("Torso") or mobModel:FindFirstChild("UpperTorso")
                        local head = mobModel:FindFirstChild("Head")
                        
                        local targetPart = humanoidRootPart or torso or head
                        
                        if targetPart and not highlightedMobs[targetPart] then
                            createMobESP(targetPart, mobType, mobModel)
                        end
                    end
                end
            end
        end
    else
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj:IsA("Model") then
                if isPlayerModel(obj) then
                    continue
                end
                
                local mobType = obj.Name
                
                if MobConfigs[mobType] then
                    local humanoidRootPart = obj:FindFirstChild("HumanoidRootPart")
                    local torso = obj:FindFirstChild("Torso") or obj:FindFirstChild("UpperTorso")
                    local head = obj:FindFirstChild("Head")
                    
                    local targetPart = humanoidRootPart or torso or head
                    
                    if targetPart then
                        if not highlightedMobs[targetPart] then
                            createMobESP(targetPart, mobType, obj)
                        end
                    end
                end
            end
        end
    end
end

local function cleanupESP()
    for obj, espData in pairs(highlightedObjects) do
        if espData.Billboard then espData.Billboard:Destroy() end
        if espData.Highlight then espData.Highlight:Destroy() end
        if espData.Light then espData.Light:Destroy() end
    end
    highlightedObjects = {}
    
    for obj, espData in pairs(highlightedMobs) do
        if espData.Billboard then espData.Billboard:Destroy() end
        if espData.Highlight then espData.Highlight:Destroy() end
        if espData.Light then espData.Light:Destroy() end
        if espData.HealthBar then espData.HealthBar.Parent:Destroy() end
        if espData.HealthText then espData.HealthText:Destroy() end
    end
    highlightedMobs = {}
end

local function toggleRockESP()
    ESPEnabled = not ESPEnabled
    
    for obj, espData in pairs(highlightedObjects) do
        if espData.Billboard then
            espData.Billboard.Enabled = ESPEnabled
        end
        if espData.Highlight then
            espData.Highlight.Visible = ESPEnabled
        end
        if espData.Light then
            espData.Light.Enabled = ESPEnabled
        end
    end
    
    return ESPEnabled
end

local function toggleMobESP()
    MobESPEnabled = not MobESPEnabled
    
    for obj, espData in pairs(highlightedMobs) do
        if espData.Billboard then
            espData.Billboard.Enabled = MobESPEnabled
        end
        if espData.Highlight then
            espData.Highlight.Visible = MobESPEnabled
        end
        if espData.Light then
            espData.Light.Enabled = MobESPEnabled
        end
        if espData.HealthBar and espData.HealthBar.Parent then
            espData.HealthBar.Parent.Visible = MobESPEnabled
        end
        if espData.HealthText then
            espData.HealthText.Visible = MobESPEnabled
        end
    end
    
    return MobESPEnabled
end

----------------------------------------------------------------
-- ==================== AUTO ATTACK SYSTEM ====================
----------------------------------------------------------------

local function callAttackRemotes()
    local success1, result1 = pcall(function()
        local args = {"Weapon"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    task.wait(0.1)
    
    local success2, result2 = pcall(function()
        local args = {"Weapon"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    return success1 and success2
end

local function getMobsData()
    local mobs = {}
    local character = LocalPlayer.Character
    
    if not character then return mobs end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return mobs end
    
    for obj, espData in pairs(highlightedMobs) do
        if obj and obj.Parent and espData.Type then
            if isPlayerModel(espData.Model) then
                continue
            end
            
            local isAlive = true
            if espData.Model then
                local humanoid = espData.Model:FindFirstChildWhichIsA("Humanoid")
                if humanoid and humanoid.Health <= 0 then
                    isAlive = false
                end
            end
            
            if isAlive then
                if SelectedMobType == "Any" or SelectedMobType == espData.Type then
                    local distance = (obj.Position - humanoidRootPart.Position).Magnitude
                    
                    if distance <= ATTACK_SEARCH_RADIUS then
                        table.insert(mobs, {
                            Type = espData.Type,
                            Position = obj.Position,
                            Distance = distance,
                            Object = obj,
                            Model = espData.Model,
                            Config = espData.Config,
                            Priority = espData.Config.Priority or 20
                        })
                    end
                end
            end
        end
    end
    
    table.sort(mobs, function(a, b)
        if a.Priority ~= b.Priority then
            return a.Priority < b.Priority
        end
        return a.Distance < b.Distance
    end)
    
    return mobs
end

local function findNearestMob()
    local mobs = getMobsData()
    if #mobs == 0 then return nil end
    return mobs[1]
end

local function enableNoclip()
    if not NOCLIP_ENABLED then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.CanCollide then
            part.CanCollide = false
        end
    end
end

local function disableNoclip()
    local character = LocalPlayer.Character
    if not character then return end
    
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
end

local function tweenToTargetAndAttack(targetData, isMob)
    if not targetData or not targetData.Position then 
        return false 
    end
    
    local character = LocalPlayer.Character
    if not character then 
        return false 
    end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then 
        return false 
    end
    
    if isMob and targetData.Model and isPlayerModel(targetData.Model) then
        return false
    end
    
    if isMob then
        CurrentAttackTarget = targetData
    else
        CurrentMineTarget = targetData
    end
    
    enableNoclip()
    
    local targetPosition
    if isMob then
        targetPosition = targetData.Position + Vector3.new(0, 5, 0)
    else
        targetPosition = targetData.Position + Vector3.new(0, FLY_HEIGHT, 0)
    end
    
    local distance = (humanoidRootPart.Position - targetPosition).Magnitude
    local speed = isMob and ATTACK_SPEED or MINING_SPEED
    local duration = math.max(0.5, distance / speed)
    
    local tweenInfo = TweenInfo.new(
        duration,
        Enum.EasingStyle.Linear,
        Enum.EasingDirection.Out
    )
    
    local tween = TweenService:Create(humanoidRootPart, tweenInfo, {
        CFrame = CFrame.new(targetPosition)
    })
    
    tween:Play()
    
    local completed = false
    tween.Completed:Connect(function()
        completed = true
    end)
    
    local startTime = tick()
    while not completed and tick() - startTime < duration + 5 do
        task.wait(0.1)
        enableNoclip()
    end
    
    if completed then
        local actionStartTime = tick()
        local actionCount = 0
        
        local maxTime = isMob and 10 or 15
        local actionDelay = isMob and ATTACK_DELAY or MINE_DELAY
        
        while (isMob and IsAttacking) or (not isMob and AutoMineEnabled and IsMining) do
            if tick() - actionStartTime > maxTime then
                break
            end
            
            if not targetData.Object or not targetData.Object.Parent then
                break
            end
            
            if isMob and targetData.Model and isPlayerModel(targetData.Model) then
                break
            end
            
            if isMob and targetData.Model then
                local humanoid = targetData.Model:FindFirstChildWhichIsA("Humanoid")
                if humanoid and humanoid.Health <= 0 then
                    break
                end
            end
            
            local success
            if isMob then
                success = callAttackRemotes()
            else
                success = callMiningRemotes()
            end
            
            actionCount = actionCount + 1
            task.wait(actionDelay)
        end
    end
    
    if isMob then
        IsAttacking = false
        CurrentAttackTarget = nil
    else
        IsMining = false
        CurrentMineTarget = nil
    end
    
    return true
end

local function toggleAutoAttack()
    flags.AutoAttackEnabled = not flags.AutoAttackEnabled
    
    if flags.AutoAttackEnabled then
        print("[AUTO ATTACK] Auto attack system ENABLED")
        if AttackConnection then
            AttackConnection:Disconnect()
        end
        AttackConnection = RunService.Heartbeat:Connect(function()
            if not flags.AutoAttackEnabled then return end
            if IsAttacking then return end
            
            if not LocalPlayer.Character then
                return
            end
            
            if isHammerMinigameActive then
                return
            end
            
            if flags.AttackWhileMining and (AutoMineEnabled or IsMining) then
                local priorityFound = false
                local mobs = getMobsData()
                for _, mob in ipairs(mobs) do
                    if PriorityMobs[mob.Type] then
                        priorityFound = true
                        break
                    end
                end
                if priorityFound then
                    return
                end
            end
            
            local nearestMob = findNearestMob()
            
            if nearestMob then
                if isPlayerModel(nearestMob.Model) then
                    return
                end
                
                IsAttacking = true
                task.spawn(function()
                    tweenToTargetAndAttack(nearestMob, true)
                    IsAttacking = false
                    task.wait(ATTACK_COOLDOWN)
                end)
            end
        end)
    else
        print("[AUTO ATTACK] Auto attack system DISABLED")
        if AttackConnection then
            AttackConnection:Disconnect()
            AttackConnection = nil
        end
        IsAttacking = false
        CurrentAttackTarget = nil
    end
    
    return flags.AutoAttackEnabled
end

local function forceAttackNearest()
    if IsAttacking then
        return false
    end
    
    local nearestMob = findNearestMob()
    
    if nearestMob then
        if isPlayerModel(nearestMob.Model) then
            return false
        end
        
        IsAttacking = true
        task.spawn(function()
            tweenToTargetAndAttack(nearestMob, true)
            IsAttacking = false
        end)
        return true
    else
        return false
    end
end

----------------------------------------------------------------
-- ==================== AUTO MINE SYSTEM =====================
----------------------------------------------------------------

local function getRocksData()
    local rocks = {}
    local character = LocalPlayer.Character
    
    if not character then return rocks end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return rocks end
    
    for obj, espData in pairs(highlightedObjects) do
        if obj and obj.Parent and espData.Type then
            if SelectedRockType == "Any" or SelectedRockType == espData.Type then
                local distance = (obj.Position - humanoidRootPart.Position).Magnitude
                
                if distance <= MINING_SEARCH_RADIUS then
                    table.insert(rocks, {
                        Type = espData.Type,
                        Position = obj.Position,
                        Distance = distance,
                        Object = obj,
                        Config = espData.Config,
                        Priority = espData.Config.Priority or 15
                    })
                end
            end
        end
    end
    
    table.sort(rocks, function(a, b)
        if a.Priority ~= b.Priority then
            return a.Priority < b.Priority
        end
        return a.Distance < b.Distance
    end)
    
    return rocks
end

local function findNearestRock()
    local rocks = getRocksData()
    if #rocks == 0 then return nil end
    return rocks[1]
end

local function callMiningRemotes()
    local success1, result1 = pcall(function()
        local args = {"Weapon"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    task.wait(0.1)
    
    local success2, result2 = pcall(function()
        local args = {"Pickaxe"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    task.wait(0.1)
    
    local success3, result3 = pcall(function()
        local args = {"Weapon"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    task.wait(0.1)
    
    local success4, result4 = pcall(function()
        local args = {"Pickaxe"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    return success1 and success2 and success3 and success4
end

local function tweenToRockAndMine(rockData)
    return tweenToTargetAndAttack(rockData, false)
end

local function toggleAutoMine()
    AutoMineEnabled = not AutoMineEnabled
    
    if AutoMineEnabled then
        print("[AUTO MINE] Auto mining system ENABLED")
        if MineConnection then
            MineConnection:Disconnect()
        end
        MineConnection = RunService.Heartbeat:Connect(function()
            if not AutoMineEnabled then return end
            if IsMining or IsAttacking then return end
            
            if not LocalPlayer.Character then
                return
            end
            
            if isHammerMinigameActive then
                return
            end
            
            local nearestRock = findNearestRock()
            
            if nearestRock then
                IsMining = true
                task.spawn(function()
                    tweenToRockAndMine(nearestRock)
                    IsMining = false
                    task.wait(MINING_COOLDOWN)
                end)
            end
        end)
    else
        print("[AUTO MINE] Auto mining system DISABLED")
        if MineConnection then
            MineConnection:Disconnect()
            MineConnection = nil
        end
        IsMining = false
        CurrentMineTarget = nil
        disableNoclip()
    end
    
    return AutoMineEnabled
end

local function toggleNoclip()
    NOCLIP_ENABLED = not NOCLIP_ENABLED
    
    if not NOCLIP_ENABLED then
        disableNoclip()
    end
    
    print("[AUTO MINE] Noclip: " .. (NOCLIP_ENABLED and "ENABLED" or "DISABLED"))
    return NOCLIP_ENABLED
end

local function forceMineNearest()
    if IsMining then
        return false
    end
    
    local nearestRock = findNearestRock()
    
    if nearestRock then
        IsMining = true
        task.spawn(function()
            tweenToRockAndMine(nearestRock)
            IsMining = false
        end)
        return true
    else
        return false
    end
end

----------------------------------------------------------------
-- ====================== WINDUI GUI ========================
----------------------------------------------------------------

local function toggleGUI()
    if not MainWindow then 
        return 
    end
    
    if guiVisible then
        MainWindow:Close()
        guiVisible = false
        print("[GUI] GUI hidden")
    else
        MainWindow:Open()
        guiVisible = true
        print("[GUI] GUI shown")
    end
end

local function createMainWindow()
    -- Simple fallback GUI jika WindUI gagal
    local function createFallbackGUI()
        print("[GUI] Creating fallback GUI...")
        
        local ScreenGui = Instance.new("ScreenGui")
        ScreenGui.Name = "JawirScriptFallbackGUI"
        ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
        
        local MainFrame = Instance.new("Frame")
        MainFrame.Size = UDim2.new(0, 350, 0, 450)
        MainFrame.Position = UDim2.new(0.5, -175, 0.5, -225)
        MainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        MainFrame.BorderSizePixel = 0
        MainFrame.Active = true
        MainFrame.Draggable = true
        MainFrame.Visible = guiVisible
        MainFrame.Parent = ScreenGui
        
        local UICorner = Instance.new("UICorner")
        UICorner.CornerRadius = UDim.new(0, 8)
        UICorner.Parent = MainFrame
        
        local Title = Instance.new("TextLabel")
        Title.Size = UDim2.new(1, 0, 0, 40)
        Title.Position = UDim2.new(0, 0, 0, 0)
        Title.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
        Title.Text = "JawirScript - No Mobile Button"
        Title.TextColor3 = Color3.fromRGB(255, 255, 255)
        Title.Font = Enum.Font.SourceSansBold
        Title.TextSize = 18
        Title.Parent = MainFrame
        
        local CloseButton = Instance.new("TextButton")
        CloseButton.Size = UDim2.new(0, 30, 0, 30)
        CloseButton.Position = UDim2.new(1, -35, 0, 5)
        CloseButton.Text = "X"
        CloseButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
        CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        CloseButton.Font = Enum.Font.SourceSansBold
        CloseButton.TextSize = 18
        CloseButton.Parent = MainFrame
        CloseButton.MouseButton1Click:Connect(function()
            MainFrame.Visible = not MainFrame.Visible
            guiVisible = MainFrame.Visible
        end)
        
        local ScrollFrame = Instance.new("ScrollingFrame")
        ScrollFrame.Size = UDim2.new(1, -10, 1, -50)
        ScrollFrame.Position = UDim2.new(0, 5, 0, 45)
        ScrollFrame.BackgroundTransparency = 1
        ScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 600)
        ScrollFrame.ScrollBarThickness = 8
        ScrollFrame.Parent = MainFrame
        
        local UIListLayout = Instance.new("UIListLayout")
        UIListLayout.Padding = UDim.new(0, 8)
        UIListLayout.Parent = ScrollFrame
        
        local buttons = {
            {"â›ï¸ Auto Mine", toggleAutoMine},
            {"âš”ï¸ Auto Attack", toggleAutoAttack},
            {"ðŸ—¿ Rock ESP", toggleRockESP},
            {"ðŸ‘¹ Mob ESP", toggleMobESP},
            {"ðŸŽ¯ Mine Nearest", forceMineNearest},
            {"ðŸŽ¯ Attack Nearest", forceAttackNearest},
            {"ðŸ‘» Noclip", toggleNoclip},
            {"ðŸ§¹ Clean ESP", cleanupESP},
            {"ðŸ›‘ Stop All", function()
                stopAutoHammer()
                AutoMineEnabled = false
                flags.AutoAttackEnabled = false
                IsMining = false
                IsAttacking = false
                disableNoclip()
            end}
        }
        
        for i, buttonData in ipairs(buttons) do
            local button = Instance.new("TextButton")
            button.Size = UDim2.new(1, -10, 0, 50)
            button.Text = buttonData[1]
            button.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
            button.TextColor3 = Color3.fromRGB(255, 255, 255)
            button.Font = Enum.Font.SourceSansSemibold
            button.TextSize = 16
            button.Parent = ScrollFrame
            
            local buttonCorner = Instance.new("UICorner")
            buttonCorner.CornerRadius = UDim.new(0, 6)
            buttonCorner.Parent = button
            
            button.MouseButton1Click:Connect(function()
                buttonData[2]()
            end)
        end
        
        print("[GUI] Fallback GUI created successfully")
        
        return {
            Open = function() 
                MainFrame.Visible = true 
                guiVisible = true
            end,
            Close = function() 
                MainFrame.Visible = false 
                guiVisible = false
            end
        }
    end
    
    -- Coba load WindUI
    if not loadUILibrary() then
        print("[GUI] WindUI failed to load, using fallback GUI")
        MainWindow = createFallbackGUI()
        return MainWindow
    end
    
    print("[GUI] Creating WindUI Window...")
    
    local success, window = pcall(function()
        return WindUI:CreateWindow({
            Title = "JawirScript - No Mobile Button",
            Folder = "JawirScriptSystem",
            Theme = "Dark",
            Size = UDim2.new(0, 400, 0, 500),
            Radius = 12,
            Resizable = true,
            Acrylic = true,
            Background = Color3.fromRGB(30, 30, 35),
            Author = "Press RightControl to toggle GUI",
            ToggleKey = Enum.KeyCode.RightControl
        })
    end)
    
    if not success then
        print("[GUI] Failed to create WindUI window, using fallback: " .. tostring(window))
        MainWindow = createFallbackGUI()
        return MainWindow
    end
    
    MainWindow = window
    print("[GUI] WindUI Window created successfully")
    
    -- Buat tabs
    pcall(function()
        -- Tab 1: Main Controls
        local MainTab = MainWindow:Tab({
            Title = "ðŸ“± Main",
            Desc = "Main Controls"
        })
        
        MainTab:Toggle({
            Title = "â›ï¸ Auto Mine",
            Desc = "Toggle auto mining",
            Value = AutoMineEnabled,
            Callback = function(value)
                AutoMineEnabled = toggleAutoMine()
            end
        })
        
        MainTab:Toggle({
            Title = "âš”ï¸ Auto Attack",
            Desc = "Toggle auto attack",
            Value = flags.AutoAttackEnabled,
            Callback = function(value)
                flags.AutoAttackEnabled = toggleAutoAttack()
            end
        })
        
        MainTab:Toggle({
            Title = "ðŸ‘» Noclip",
            Desc = "Toggle noclip",
            Value = NOCLIP_ENABLED,
            Callback = function(value)
                NOCLIP_ENABLED = toggleNoclip()
            end
        })
        
        MainTab:Divider()
        
        MainTab:Button({
            Title = "ðŸŽ¯ Mine Now",
            Desc = "Mine nearest rock",
            Callback = function()
                forceMineNearest()
            end
        })
        
        MainTab:Button({
            Title = "ðŸŽ¯ Attack Now",
            Desc = "Attack nearest mob",
            Callback = function()
                forceAttackNearest()
            end
        })
        
        MainTab:Button({
            Title = "ðŸ›‘ Stop All",
            Desc = "Stop all systems",
            Callback = function()
                stopAutoHammer()
                AutoMineEnabled = false
                flags.AutoAttackEnabled = false
                IsMining = false
                IsAttacking = false
                disableNoclip()
            end
        })
        
        -- Tab 2: ESP Settings
        local ESPTab = MainWindow:Tab({
            Title = "ðŸ‘ï¸ ESP",
            Desc = "ESP Settings"
        })
        
        ESPTab:Toggle({
            Title = "ðŸ—¿ Rock ESP",
            Desc = "Toggle rock ESP",
            Value = ESPEnabled,
            Callback = function(value)
                ESPEnabled = toggleRockESP()
            end
        })
        
        ESPTab:Toggle({
            Title = "ðŸ‘¹ Mob ESP",
            Desc = "Toggle mob ESP",
            Value = MobESPEnabled,
            Callback = function(value)
                MobESPEnabled = toggleMobESP()
            end
        })
        
        ESPTab:Button({
            Title = "ðŸ§¹ Clean ESP",
            Desc = "Remove all ESP",
            Callback = function()
                cleanupESP()
            end
        })
        
        -- Tab 3: Forge
        local ForgeTab = MainWindow:Tab({
            Title = "âš’ï¸ Forge",
            Desc = "Forge Settings"
        })
        
        ForgeTab:Button({
            Title = "ðŸ”§ Activate Hooks",
            Desc = "Activate forge hooks",
            Callback = function()
                hookMinigameModules()
            end
        })
        
        ForgeTab:Toggle({
            Title = "ðŸ”¨ Auto Hammer",
            Desc = "Auto hammer minigame",
            Value = flags.AutoHammerEnabled,
            Callback = function(value)
                flags.AutoHammerEnabled = value
            end
        })
        
        print("[GUI] Tabs created successfully")
    end)
    
    return MainWindow
end

----------------------------------------------------------------
-- ===================== INITIALIZATION ======================
----------------------------------------------------------------

local function setupEventListeners()
    -- GUI keybind listener untuk PC
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed then
            if input.KeyCode == Enum.KeyCode[toggleKeybind] then
                toggleGUI()
            end
        end
    end)
    
    -- Character added listener for noclip
    LocalPlayer.CharacterAdded:Connect(function(character)
        task.wait(1)
        if (AutoMineEnabled or IsAttacking) and NOCLIP_ENABLED then
            enableNoclip()
        end
    end)
    
    -- Update player blacklist
    for _, player in pairs(Players:GetPlayers()) do
        PlayerBlacklist[player.Name] = true
    end
    
    Players.PlayerAdded:Connect(function(player)
        PlayerBlacklist[player.Name] = true
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        PlayerBlacklist[player.Name] = nil
    end)
end

local function startESPScanning()
    -- Start auto ESP scanning
    if ESPConnection then
        task.cancel(ESPConnection)
        ESPConnection = nil
    end
    
    ESPConnection = task.spawn(function()
        while true do
            pcall(scanForRocks)
            pcall(scanForMobs)
            task.wait(3)
        end
    end)
    print("[ESP] Auto scanning started")
end

local function initializeSystem()
    print("========================================")
    print("JAWIRSCRIPT AUTO FORGE & MINE SYSTEM")
    print("========================================")
    print("Features: Forge Skip + Auto Mine + Auto Attack")
    print("ESP: Hanya deteksi MOB (TIDAK deteksi PLAYER)")
    print("GUI: Press RightControl to toggle GUI")
    print("NO MOBILE BUTTON - Tombol kecil di kanan dihapus")
    print("========================================")
    
    -- Initialize player blacklist
    for _, player in pairs(Players:GetPlayers()) do
        PlayerBlacklist[player.Name] = true
    end
    
    -- Initialize remotes
    pcall(initializeRemotes)
    
    -- Create GUI
    pcall(createMainWindow)
    
    -- Setup event listeners
    pcall(setupEventListeners)
    
    -- Start ESP scanning
    pcall(startESPScanning)
    
    -- Auto activate hooks after delay
    task.spawn(function()
        task.wait(5)
        pcall(hookMinigameModules)
    end)
    
    -- Cleanup on player leave
    Players.LocalPlayer.AncestryChanged:Connect(function()
        if not Players.LocalPlayer.Parent then
            pcall(stopAutoHammer)
            pcall(cleanupESP)
            pcall(disableNoclip)
            
            if MineConnection then
                MineConnection:Disconnect()
                MineConnection = nil
            end
            
            if AttackConnection then
                AttackConnection:Disconnect()
                AttackConnection = nil
            end
            
            if ESPConnection then
                task.cancel(ESPConnection)
                ESPConnection = nil
            end
        end
    end)
    
    -- Cleanup on game close
    game:BindToClose(function()
        pcall(stopAutoHammer)
        pcall(cleanupESP)
        pcall(disableNoclip)
    end)
    
    print("[SYSTEM] Initialization complete")
    print("[SYSTEM] Press " .. toggleKeybind .. " to toggle GUI")
    print("========================================")
end

-- Start initialization
task.spawn(function()
    task.wait(2)
    print("[SYSTEM] Starting initialization...")
    pcall(initializeSystem)
end)
