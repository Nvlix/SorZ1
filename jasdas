-- ============================================================
-- JAWIRSCRIPT AUTO FORGE SYSTEM
-- ============================================================
-- Gabungan sistem: Forge Skipper + Rock ESP + Auto Tween
-- ============================================================

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer

-- Remote references
local ForgeServiceRF
local ProximityServiceRF
local Knit

-- FORGE STATE
local isHammerMinigameActive = false
local autoHammerRunning = false
local originalMinigames = {}
local lastHammerTime = 0
local HAMMER_COOLDOWN = 0.5
local hammerTask = nil
local stopRequested = false
local debugMode = false
local hammerMinigameUI = nil
local minigameCompleteFlag = false

-- ROCK ESP STATE
local highlightedObjects = {}
local ESPEnabled = true
local ESPDistance = 300
local ESPUpdateInterval = 0.2
local lastESPUpdate = 0

-- AUTO TWEEN STATE
local AutoTweenEnabled = false
local TweenCooldown = 60
local IsTweening = false
local LastTweenTime = 0
local CurrentTarget = nil
local TweenConnection = nil
local TWEEN_SPEED = 2
local SEARCH_RADIUS = 500
local HEIGHT_OFFSET = 3

-- GUI STATE
local guiVisible = true
local openButton
local toggleKeybind = "RightControl"

-- WindUI
local WindUI
local MainWindow
local flags = {}

-- Rock configurations
local RockConfigs = {
    Pebble = {
        Name = "Pebble",
        Color = Color3.fromRGB(180, 160, 140),
        SizeOffset = Vector3.new(0, 1.5, 0),
        BillboardSize = UDim2.new(0, 60, 0, 30),
        TextSize = 14,
        ShowTracer = false,
        Priority = 3
    },
    Rock = {
        Name = "Rock",
        Color = Color3.fromRGB(150, 120, 90),
        SizeOffset = Vector3.new(0, 2, 0),
        BillboardSize = UDim2.new(0, 80, 0, 40),
        TextSize = 16,
        ShowTracer = true,
        Priority = 2
    },
    Boulder = {
        Name = "Boulder",
        Color = Color3.fromRGB(120, 85, 60),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 100, 0, 50),
        TextSize = 18,
        ShowTracer = true,
        Priority = 1
    }
}

----------------------------------------------------------------
-- LOAD WINDUI LIBRARY
----------------------------------------------------------------
local function loadUILibrary()
    local success, lib = pcall(function()
        return loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"))()
    end)
    
    if success then
        WindUI = lib
        return true
    else
        warn("[SYSTEM] Failed to load WindUI Library")
        return false
    end
end

----------------------------------------------------------------
-- INITIALIZE REMOTES
----------------------------------------------------------------
local function initializeRemotes()
    local Packages = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages")
    Knit = require(Packages.Knit)
    
    local Services = Packages.Knit.Services
    ForgeServiceRF = Services.ForgeService.RF.ChangeSequence
    ProximityServiceRF = Services.ProximityService.RF.Forge
    
    return ForgeServiceRF ~= nil
end

----------------------------------------------------------------
-- DEBUG LOGGING
----------------------------------------------------------------
local function debugLog(module, message)
    if debugMode then
        print("[" .. module .. "] " .. message)
    end
end

----------------------------------------------------------------
-- ==================== FORGE SKIPPER ========================
----------------------------------------------------------------

local function getHammerMinigameUI()
    local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
    local forgeUI = playerGui:WaitForChild("Forge", 5)
    if forgeUI then
        return forgeUI:WaitForChild("HammerMinigame", 3)
    end
    return nil
end

local function isMinigameVisible()
    hammerMinigameUI = getHammerMinigameUI()
    if hammerMinigameUI then
        return hammerMinigameUI.Visible
    end
    return false
end

local function isMinigameTimerComplete()
    if not hammerMinigameUI then
        hammerMinigameUI = getHammerMinigameUI()
    end
    
    if hammerMinigameUI then
        local timerBar = hammerMinigameUI:FindFirstChild("Timer")
        if timerBar then
            local bar = timerBar:FindFirstChild("Bar")
            if bar then
                return bar.Size.X.Scale >= 0.95
            end
        end
    end
    return false
end

local function hammerLoop()
    debugLog("FORGE", "Hammer loop started")
    local hammerCount = 0
    local lastCheckTime = tick()
    
    while isHammerMinigameActive and autoHammerRunning and not stopRequested do
        local currentTime = tick()
        if currentTime - lastCheckTime > 0.5 then
            if not isMinigameVisible() or isMinigameTimerComplete() then
                debugLog("FORGE", "Minigame no longer active, stopping hammer")
                stopRequested = true
                break
            end
            lastCheckTime = currentTime
        end
        
        local baseDelay = HAMMER_COOLDOWN
        local randomVariation = math.random(-20, 30) / 100
        local totalDelay = math.max(0.3, baseDelay + randomVariation)
        
        debugLog("FORGE", "Waiting " .. string.format("%.2f", totalDelay) .. "s before next hit")
        
        local startWait = tick()
        while tick() - startWait < totalDelay do
            if not isHammerMinigameActive or not autoHammerRunning or stopRequested then
                debugLog("FORGE", "Breaking during wait")
                return
            end
            task.wait(0.05)
        end
        
        if not isHammerMinigameActive or not autoHammerRunning or stopRequested then
            debugLog("FORGE", "Breaking before send")
            return
        end
        
        local success, result = pcall(function()
            return ForgeServiceRF:InvokeServer(
                "Hammer",
                { 
                    ClientTime = workspace:GetServerTimeNow(),
                    RandomSeed = math.random(1, 1000)
                }
            )
        end)
        
        if success then
            hammerCount = hammerCount + 1
            lastHammerTime = tick()
            debugLog("FORGE", "Hammer hit #" .. hammerCount .. " sent successfully")
            
            if isMinigameTimerComplete() then
                debugLog("FORGE", "Timer completed after hit #" .. hammerCount)
                stopRequested = true
                break
            end
        else
            debugLog("FORGE", "Hammer hit failed: " .. tostring(result))
        end
    end
    
    debugLog("FORGE", "Hammer loop ended. Total hits: " .. hammerCount)
end

local function startAutoHammer()
    if autoHammerRunning then
        debugLog("FORGE", "Auto hammer already running")
        return
    end
    
    debugLog("FORGE", "Starting auto hammer system")
    autoHammerRunning = true
    stopRequested = false
    minigameCompleteFlag = false
    
    if hammerTask then
        task.cancel(hammerTask)
        hammerTask = nil
    end
    
    hammerTask = task.spawn(function()
        hammerLoop()
        
        autoHammerRunning = false
        hammerTask = nil
        debugLog("FORGE", "Auto hammer task cleaned up")
    end)
end

local function stopAutoHammer()
    debugLog("FORGE", "Stopping auto hammer requested")
    stopRequested = true
    autoHammerRunning = false
    isHammerMinigameActive = false
    minigameCompleteFlag = true
    
    if hammerTask then
        task.cancel(hammerTask)
        hammerTask = nil
    end
    
    debugLog("FORGE", "Auto hammer fully stopped")
end

local function hookMinigameModules()
    local ForgeController = Knit.GetController("ForgeController")
    if not ForgeController or not ForgeController.Minigames then
        warn("[FORGE] Cannot find ForgeController minigames")
        return false
    end

    print("[FORGE] Found ForgeController with minigames")

    -- MELT
    if ForgeController.Minigames.MeltMinigame then
        originalMinigames.MeltStart = ForgeController.Minigames.MeltMinigame.Start

        ForgeController.Minigames.MeltMinigame.Start = function(self, data)
            print("[FORGE] Skipping Melt...")
            local t = workspace:GetServerTimeNow()
            task.wait(0.3)
            print("[FORGE] Melt skipped!")
            return t - 0.001
        end
    end

    -- POUR
    if ForgeController.Minigames.PourMinigame then
        originalMinigames.PourStart = ForgeController.Minigames.PourMinigame.Start

        ForgeController.Minigames.PourMinigame.Start = function(self, data)
            print("[FORGE] Skipping Pour...")
            local t = workspace:GetServerTimeNow()
            task.wait(0.3)
            print("[FORGE] Pour skipped!")
            return t - 0.001
        end
    end

    -- HAMMER
    if ForgeController.Minigames.HammerMinigame then
        local originalHammerStart = ForgeController.Minigames.HammerMinigame.Start
        local originalHammerStop = ForgeController.Minigames.HammerMinigame.Stop
        
        hammerMinigameUI = getHammerMinigameUI()
        
        ForgeController.Minigames.HammerMinigame.Start = function(self, ...)
            print("[FORGE] ===== HAMMER MINIGAME STARTED =====")
            
            isHammerMinigameActive = true
            autoHammerRunning = false
            stopRequested = false
            minigameCompleteFlag = false
            
            hammerMinigameUI = getHammerMinigameUI()
            
            if flags.AutoHammerEnabled then
                task.spawn(function()
                    task.wait(0.5)
                    if isMinigameVisible() then
                        print("[FORGE] UI detected, starting auto hammer...")
                        startAutoHammer()
                    end
                end)
            end
            
            if originalHammerStart then
                return originalHammerStart(self, ...)
            end
            return nil
        end

        ForgeController.Minigames.HammerMinigame.Stop = function(self, ...)
            print("[FORGE] ===== HAMMER MINIGAME STOPPED =====")
            
            stopAutoHammer()
            
            if originalHammerStop then
                return originalHammerStop(self, ...)
            end
            return nil
        end
        
        print("[FORGE] Hammer minigame hooks installed")
    end

    print("[FORGE] All minigames hooked successfully")
    return true
end

----------------------------------------------------------------
-- ====================== ROCK ESP ==========================
----------------------------------------------------------------

local function createRockESP(obj)
    local config = RockConfigs[obj.Parent.Name]
    if not config then return end
    
    if highlightedObjects[obj] then return end
    
    local character = LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    local distance = 0
    
    if humanoidRootPart then
        distance = (obj.Position - humanoidRootPart.Position).Magnitude
    end
    
    local BillboardGui = Instance.new('BillboardGui')
    local TextLabel = Instance.new('TextLabel')
    local DistanceLabel = Instance.new('TextLabel')
    
    BillboardGui.Name = "RockESP"
    BillboardGui.Parent = obj
    BillboardGui.AlwaysOnTop = true
    BillboardGui.Size = config.BillboardSize
    BillboardGui.StudsOffset = config.SizeOffset
    BillboardGui.MaxDistance = ESPDistance
    BillboardGui.Enabled = ESPEnabled
    
    TextLabel.Name = "TypeLabel"
    TextLabel.Parent = BillboardGui
    TextLabel.BackgroundTransparency = 1
    TextLabel.Size = UDim2.new(1, 0, 0.6, 0)
    TextLabel.Position = UDim2.new(0, 0, 0, 0)
    TextLabel.Text = config.Name
    TextLabel.TextColor3 = config.Color
    TextLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    TextLabel.TextStrokeTransparency = 0.5
    TextLabel.TextSize = config.TextSize
    TextLabel.Font = Enum.Font.SourceSansBold
    TextLabel.TextScaled = false
    
    DistanceLabel.Name = "DistanceLabel"
    DistanceLabel.Parent = BillboardGui
    DistanceLabel.BackgroundTransparency = 1
    DistanceLabel.Size = UDim2.new(1, 0, 0.4, 0)
    DistanceLabel.Position = UDim2.new(0, 0, 0.6, 0)
    DistanceLabel.Text = string.format("%.1f studs", distance)
    DistanceLabel.TextColor3 = Color3.new(1, 1, 1)
    DistanceLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    DistanceLabel.TextStrokeTransparency = 0.5
    DistanceLabel.TextSize = config.TextSize - 2
    DistanceLabel.Font = Enum.Font.SourceSans
    
    local highlight = Instance.new("BoxHandleAdornment")
    highlight.Name = "RockHighlight"
    highlight.Adornee = obj
    highlight.AlwaysOnTop = true
    highlight.ZIndex = 10
    highlight.Size = obj.Size + Vector3.new(0.3, 0.3, 0.3)
    highlight.Color3 = config.Color
    highlight.Transparency = 0.3
    highlight.Visible = ESPEnabled
    highlight.Parent = obj
    
    local tracer = nil
    if config.ShowTracer then
        tracer = Instance.new("LineHandleAdornment")
        tracer.Name = "RockTracer"
        tracer.Adornee = obj
        tracer.AlwaysOnTop = true
        tracer.ZIndex = 5
        tracer.Thickness = 2
        tracer.Color3 = config.Color
        tracer.Transparency = 0.4
        tracer.Visible = ESPEnabled
        tracer.Parent = obj
    end
    
    local pointLight = Instance.new("PointLight")
    pointLight.Name = "RockGlow"
    pointLight.Color = config.Color
    pointLight.Brightness = 1.5
    pointLight.Range = 15
    pointLight.Enabled = ESPEnabled
    pointLight.Shadows = false
    pointLight.Parent = obj
    
    highlightedObjects[obj] = {
        Billboard = BillboardGui,
        Highlight = highlight,
        Tracer = tracer,
        Light = pointLight,
        Config = config,
        LastUpdate = tick()
    }
    
    debugLog("ESP", "Created ESP for " .. config.Name .. " (Distance: " .. string.format("%.1f", distance) .. ")")
end

local function updateRockESP(obj, espData)
    if not obj or not obj.Parent then
        return false
    end
    
    local character = LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    if not humanoidRootPart then return true end
    
    local distance = (obj.Position - humanoidRootPart.Position).Magnitude
    
    if espData.Billboard and espData.Billboard:FindFirstChild("DistanceLabel") then
        espData.Billboard.DistanceLabel.Text = string.format("%.1f studs", distance)
        
        local hue = (tick() % 3) / 3
        local baseColor = espData.Config.Color
        
        if distance < 20 then
            espData.Billboard.TypeLabel.TextColor3 = Color3.new(0, 1, 0)
        elseif distance < 50 then
            espData.Billboard.TypeLabel.TextColor3 = Color3.fromHSV(hue, 1, 1)
        elseif distance < 100 then
            espData.Billboard.TypeLabel.TextColor3 = baseColor
        else
            espData.Billboard.TypeLabel.TextColor3 = Color3.new(
                baseColor.R * 0.7,
                baseColor.G * 0.7,
                baseColor.B * 0.7
            )
        end
        
        if espData.Highlight then
            espData.Highlight.Color3 = espData.Billboard.TypeLabel.TextColor3
        end
        
        if espData.Tracer then
            espData.Tracer.Color3 = espData.Billboard.TypeLabel.TextColor3
            
            local camera = Workspace.CurrentCamera
            if camera then
                espData.Tracer.Length = (obj.Position - camera.CFrame.Position).Magnitude
                espData.Tracer.CFrame = CFrame.lookAt(obj.Position, camera.CFrame.Position)
            end
        end
        
        if espData.Light then
            espData.Light.Brightness = math.clamp(30 / distance, 0.5, 3)
        end
        
        local shouldShow = distance <= ESPDistance
        espData.Billboard.Enabled = ESPEnabled and shouldShow
        espData.Highlight.Visible = ESPEnabled and shouldShow
        if espData.Tracer then
            espData.Tracer.Visible = ESPEnabled and shouldShow
        end
        espData.Light.Enabled = ESPEnabled and shouldShow
    end
    
    espData.LastUpdate = tick()
    return true
end

local function handleNewObject(obj)
    if obj:IsA('Part') and obj.Parent and obj.Parent:IsA('Model') then
        local parentName = obj.Parent.Name
        if parentName == 'Pebble' or parentName == 'Rock' or parentName == 'Boulder' then
            if not highlightedObjects[obj] then
                createRockESP(obj)
            end
        end
    end
end

local function handleExistingObjects()
    for _, obj in ipairs(Workspace:GetDescendants()) do
        handleNewObject(obj)
    end
end

local function cleanupESP()
    local toRemove = {}
    
    for obj, espData in pairs(highlightedObjects) do
        if not obj or not obj.Parent then
            if espData.Billboard then espData.Billboard:Destroy() end
            if espData.Highlight then espData.Highlight:Destroy() end
            if espData.Tracer then espData.Tracer:Destroy() end
            if espData.Light then espData.Light:Destroy() end
            table.insert(toRemove, obj)
        end
    end
    
    for _, obj in ipairs(toRemove) do
        highlightedObjects[obj] = nil
    end
end

local function mainESPUpdate()
    local currentTime = tick()
    
    if currentTime - lastESPUpdate >= ESPUpdateInterval then
        cleanupESP()
        
        for obj, espData in pairs(highlightedObjects) do
            if currentTime - espData.LastUpdate >= ESPUpdateInterval then
                local stillExists = updateRockESP(obj, espData)
                if not stillExists then
                    highlightedObjects[obj] = nil
                end
            end
        end
        
        if currentTime - lastESPUpdate >= 1 then
            handleExistingObjects()
        end
        
        lastESPUpdate = currentTime
    end
end

local function toggleESP()
    ESPEnabled = not ESPEnabled
    
    for obj, espData in pairs(highlightedObjects) do
        if espData.Billboard then
            espData.Billboard.Enabled = ESPEnabled
        end
        if espData.Highlight then
            espData.Highlight.Visible = ESPEnabled
        end
        if espData.Tracer then
            espData.Tracer.Visible = ESPEnabled
        end
        if espData.Light then
            espData.Light.Enabled = ESPEnabled
        end
    end
    
    debugLog("ESP", ESPEnabled and "ENABLED" or "DISABLED")
    return ESPEnabled
end

local function setESPDistance(distance)
    ESPDistance = math.clamp(distance, 10, 1000)
    debugLog("ESP", "Distance set to: " .. ESPDistance .. " studs")
end

local function setESPUpdateInterval(interval)
    ESPUpdateInterval = math.clamp(interval, 0.05, 2)
    debugLog("ESP", "Update interval set to: " .. ESPUpdateInterval .. " seconds")
end

----------------------------------------------------------------
-- ==================== AUTO TWEEN ===========================
----------------------------------------------------------------

local function getRocksData()
    local rocks = {}
    local character = LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    if not humanoidRootPart then return rocks end
    
    for obj, espData in pairs(highlightedObjects) do
        if obj and obj.Parent then
            local parentName = obj.Parent.Name
            if RockConfigs[parentName] then
                local distance = (obj.Position - humanoidRootPart.Position).Magnitude
                table.insert(rocks, {
                    Type = parentName,
                    Position = obj.Position,
                    Distance = distance,
                    Object = obj,
                    Config = RockConfigs[parentName]
                })
            end
        end
    end
    
    return rocks
end

local function findNearestRock()
    local character = LocalPlayer.Character
    if not character then return nil end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return nil end
    
    local playerPosition = humanoidRootPart.Position
    local nearestRock = nil
    local nearestDistance = math.huge
    
    local rocks = getRocksData()
    
    for _, rockData in ipairs(rocks) do
        if rockData.Type and rockData.Position then
            local distance = rockData.Distance
            
            if distance <= SEARCH_RADIUS and distance < nearestDistance then
                nearestRock = rockData
                nearestDistance = distance
            end
        end
    end
    
    return nearestRock, nearestDistance
end

local function tweenToRock(rockData)
    if not rockData or not rockData.Position then return false end
    
    local character = LocalPlayer.Character
    if not character then return false end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end
    
    debugLog("TWEEN", "Tweening to " .. rockData.Type .. " at distance: " .. string.format("%.1f", rockData.Distance or 0))
    
    IsTweening = true
    CurrentTarget = rockData
    
    local targetPosition = rockData.Position + Vector3.new(0, HEIGHT_OFFSET, 0)
    
    local tweenInfo = TweenInfo.new(
        TWEEN_SPEED,
        Enum.EasingStyle.Quad,
        Enum.EasingDirection.Out
    )
    
    local tween = TweenService:Create(humanoidRootPart, tweenInfo, {
        Position = targetPosition
    })
    
    tween:Play()
    tween.Completed:Wait()
    
    task.wait(0.5)
    
    IsTweening = false
    LastTweenTime = tick()
    CurrentTarget = nil
    
    debugLog("TWEEN", "Tween completed")
    return true
end

local function startAutoTweenLoop()
    if TweenConnection then
        TweenConnection:Disconnect()
        TweenConnection = nil
    end
    
    TweenConnection = RunService.Heartbeat:Connect(function()
        if not AutoTweenEnabled then return end
        
        local currentTime = tick()
        if currentTime - LastTweenTime < TweenCooldown then
            return
        end
        
        if IsTweening then return end
        
        local nearestRock, distance = findNearestRock()
        
        if nearestRock then
            debugLog("TWEEN", "Found " .. nearestRock.Type .. " at " .. string.format("%.1f", distance) .. " studs")
            
            local success = tweenToRock(nearestRock)
            
            if success then
                debugLog("TWEEN", "Successfully tweened to " .. nearestRock.Type)
            else
                debugLog("TWEEN", "Tween failed")
            end
        end
    end)
end

local function toggleAutoTween()
    AutoTweenEnabled = not AutoTweenEnabled
    
    if AutoTweenEnabled then
        debugLog("TWEEN", "Enabled")
        startAutoTweenLoop()
    else
        debugLog("TWEEN", "Disabled")
        if TweenConnection then
            TweenConnection:Disconnect()
            TweenConnection = nil
        end
        IsTweening = false
        CurrentTarget = nil
    end
    
    return AutoTweenEnabled
end

local function setTweenCooldown(seconds)
    TweenCooldown = math.max(5, seconds)
    debugLog("TWEEN", "Cooldown set to: " .. TweenCooldown .. " seconds")
end

local function setSearchRadius(radius)
    SEARCH_RADIUS = math.max(10, math.min(2000, radius))
    debugLog("TWEEN", "Search radius set to: " .. SEARCH_RADIUS .. " studs")
end

local function setTweenSpeed(speed)
    TWEEN_SPEED = math.max(0.5, math.min(10, speed))
    debugLog("TWEEN", "Tween speed set to: " .. TWEEN_SPEED .. " seconds")
end

local function forceTweenToNearest()
    if IsTweening then
        debugLog("TWEEN", "Already tweening, please wait...")
        return false
    end
    
    local nearestRock, distance = findNearestRock()
    
    if nearestRock then
        debugLog("TWEEN", "Force tweening to " .. nearestRock.Type .. " at " .. string.format("%.1f", distance) .. " studs")
        
        local success = tweenToRock(nearestRock)
        
        if success then
            LastTweenTime = tick()
            return true
        else
            debugLog("TWEEN", "Force tween failed")
            return false
        end
    else
        debugLog("TWEEN", "No rocks found to tween to")
        return false
    end
end

----------------------------------------------------------------
-- ====================== WINDUI GUI ========================
----------------------------------------------------------------

local function toggleGUI()
    if not MainWindow then return end
    
    if guiVisible then
        MainWindow:Close()
        if MainWindow.OpenButtonMain then
            MainWindow.OpenButtonMain:Visible(true)
        end
        guiVisible = false
        
        if WindUI then
            WindUI:Notify({
                Title = "GUI",
                Content = "GUI hidden",
                Icon = "eye-off",
                Duration = 1.5
            })
        end
    else
        MainWindow:Open()
        if MainWindow.OpenButtonMain then
            MainWindow.OpenButtonMain:Visible(false)
        end
        guiVisible = true
        
        if WindUI then
            WindUI:Notify({
                Title = "GUI",
                Content = "GUI opened",
                Icon = "eye",
                Duration = 1.5
            })
        end
    end
    
    debugLog("GUI", "GUI toggled: " .. (guiVisible and "VISIBLE" or "HIDDEN"))
end

local function createMainWindow()
    if not loadUILibrary() then
        warn("[SYSTEM] Failed to load WindUI Library")
        return nil
    end
    
    MainWindow = WindUI:CreateWindow({
        Title = "JawirScript - Auto Forge System",
        Folder = "JawirScriptForgeSystem",
        Theme = "Dark",
        Size = UDim2.new(0, 550, 0, 600),
        Radius = 12,
        Resizable = true,
        Acrylic = true,
        Background = Color3.fromRGB(30, 30, 35),
        Author = "Auto Forge + Rock ESP + Tween",
        ToggleKey = Enum.KeyCode.RightControl,
        OpenButton = {
            Title = "Auto Forge System",
            Icon = "hammer",
            Enabled = true,
            Position = UDim2.new(0, 10, 0.5, -50),
            OnlyIcon = false,
            Draggable = true,
            Color = ColorSequence.new(
                Color3.fromHex("#FF6B6B"),
                Color3.fromHex("#4ECDC4")
            )
        }
    })
    
    MainWindow:OnOpen(function()
        if MainWindow.OpenButtonMain then
            MainWindow.OpenButtonMain:Visible(false)
        end
        guiVisible = true
        debugLog("GUI", "Window opened")
    end)
    
    MainWindow:OnClose(function()
        if MainWindow.OpenButtonMain then
            MainWindow.OpenButtonMain:Visible(true)
        end
        guiVisible = false
        debugLog("GUI", "Window closed")
    end)
    
    -- Tab 1: Forge System
    local ForgeTab = MainWindow:Tab({
        Title = "âš’ï¸ Forge",
        Desc = "Forge Skipper Settings"
    })
    
    ForgeTab:Paragraph({
        Title = "ðŸ”§ Auto Forge System",
        Desc = "Skip minigames and auto-hammer"
    })
    
    ForgeTab:Button({
        Title = "ðŸ”§ Activate Hooks",
        Desc = "Activate minigame hooks",
        Callback = function()
            local success = hookMinigameModules()
            if success then
                task.wait(0.5)
                WindUI:Notify({
                    Title = "Hooks Activated",
                    Content = "Minigame hooks activated successfully!",
                    Icon = "check-circle",
                    Duration = 3
                })
            end
        end
    })
    
    ForgeTab:Divider()
    
    ForgeTab:Toggle({
        Title = "ðŸ”¨ Auto Hammer",
        Desc = "Automatically hammer during minigame",
        Value = true,
        Callback = function(value)
            flags.AutoHammerEnabled = value
            WindUI:Notify({
                Title = "Auto Hammer",
                Content = value and "ENABLED" or "DISABLED",
                Icon = value and "hammer" or "hammer-off",
                Duration = 2
            })
        end
    })
    
    ForgeTab:Slider({
        Title = "â±ï¸ Hammer Speed",
        Desc = "Delay between hammer hits",
        Value = {Default = HAMMER_COOLDOWN, Min = 0.1, Max = 1.0, Step = 0.1},
        Callback = function(value)
            HAMMER_COOLDOWN = value
            WindUI:Notify({
                Title = "Hammer Speed",
                Content = "Set to: " .. string.format("%.1f", value) .. "s",
                Icon = "gauge",
                Duration = 2
            })
        end
    })
    
    ForgeTab:Toggle({
        Title = "ðŸ”¥ Skip Melt",
        Desc = "Skip the melt minigame",
        Value = true,
        Callback = function(value)
            flags.SkipMeltEnabled = value
            WindUI:Notify({
                Title = "Skip Melt",
                Content = value and "ENABLED" or "DISABLED",
                Icon = value and "fire" or "fire-off",
                Duration = 2
            })
        end
    })
    
    ForgeTab:Toggle({
        Title = "ðŸ’§ Skip Pour",
        Desc = "Skip the pour minigame",
        Value = true,
        Callback = function(value)
            flags.SkipPourEnabled = value
            WindUI:Notify({
                Title = "Skip Pour",
                Content = value and "ENABLED" or "DISABLED",
                Icon = value and "droplet" or "droplet-off",
                Duration = 2
            })
        end
    })
    
    -- Tab 2: Rock ESP
    local RockTab = MainWindow:Tab({
        Title = "ðŸ—¿ Rock ESP",
        Desc = "Rock ESP Settings"
    })
    
    RockTab:Paragraph({
        Title = "ðŸ—¿ Rock ESP System",
        Desc = "Highlight nearby rocks with ESP"
    })
    
    RockTab:Toggle({
        Title = "ðŸ‘ï¸ Enable ESP",
        Desc = "Toggle rock ESP visibility",
        Value = ESPEnabled,
        Callback = function(value)
            ESPEnabled = toggleESP()
            WindUI:Notify({
                Title = "Rock ESP",
                Content = ESPEnabled and "ENABLED" or "DISABLED",
                Icon = ESPEnabled and "eye" or "eye-off",
                Duration = 2
            })
        end
    })
    
    RockTab:Slider({
        Title = "ðŸ“ ESP Distance",
        Desc = "Maximum ESP render distance",
        Value = {Default = ESPDistance, Min = 10, Max = 1000, Step = 10},
        Callback = function(value)
            setESPDistance(value)
            WindUI:Notify({
                Title = "ESP Distance",
                Content = "Set to: " .. value .. " studs",
                Icon = "ruler",
                Duration = 2
            })
        end
    })
    
    RockTab:Button({
        Title = "ðŸ” Scan Rocks",
        Desc = "Perform new rock scan",
        Callback = function()
            handleExistingObjects()
            local count = 0
            for _ in pairs(highlightedObjects) do count = count + 1 end
            WindUI:Notify({
                Title = "Rock Scan",
                Content = "Found " .. count .. " rocks",
                Icon = "search",
                Duration = 2
            })
        end
    })
    
    RockTab:Button({
        Title = "ðŸ§¹ Clear ESP",
        Desc = "Remove all ESP highlights",
        Callback = function()
            cleanupESP()
            WindUI:Notify({
                Title = "ESP Cleared",
                Content = "All ESP objects removed",
                Icon = "broom",
                Duration = 2
            })
        end
    })
    
    -- Tab 3: Auto Tween
    local TweenTab = MainWindow:Tab({
        Title = "ðŸš€ Auto Tween",
        Desc = "Auto Teleport Settings"
    })
    
    TweenTab:Paragraph({
        Title = "ðŸš€ Auto Rock Tween",
        Desc = "Automatically teleport to nearest rock"
    })
    
    TweenTab:Toggle({
        Title = "âš¡ Enable Auto Tween",
        Desc = "Toggle automatic tweening to rocks",
        Value = AutoTweenEnabled,
        Callback = function(value)
            AutoTweenEnabled = toggleAutoTween()
            WindUI:Notify({
                Title = "Auto Tween",
                Content = AutoTweenEnabled and "ENABLED" or "DISABLED",
                Icon = AutoTweenEnabled and "navigation" or "navigation-off",
                Duration = 2
            })
        end
    })
    
    TweenTab:Slider({
        Title = "â° Tween Cooldown",
        Desc = "Time between auto tweens",
        Value = {Default = TweenCooldown, Min = 5, Max = 300, Step = 5},
        Callback = function(value)
            setTweenCooldown(value)
            WindUI:Notify({
                Title = "Cooldown",
                Content = "Set to: " .. value .. " seconds",
                Icon = "clock",
                Duration = 2
            })
        end
    })
    
    TweenTab:Slider({
        Title = "ðŸ“ Search Radius",
        Desc = "Maximum distance to search for rocks",
        Value = {Default = SEARCH_RADIUS, Min = 10, Max = 2000, Step = 10},
        Callback = function(value)
            setSearchRadius(value)
            WindUI:Notify({
                Title = "Search Radius",
                Content = "Set to: " .. value .. " studs",
                Icon = "ruler",
                Duration = 2
            })
        end
    })
    
    TweenTab:Slider({
        Title = "âš¡ Tween Speed",
        Desc = "Speed of teleport animation",
        Value = {Default = TWEEN_SPEED, Min = 0.5, Max = 10, Step = 0.5},
        Callback = function(value)
            setTweenSpeed(value)
            WindUI:Notify({
                Title = "Tween Speed",
                Content = "Set to: " .. value .. " seconds",
                Icon = "gauge",
                Duration = 2
            })
        end
    })
    
    TweenTab:Divider()
    
    TweenTab:Button({
        Title = "ðŸŽ¯ Force Tween",
        Desc = "Immediately tween to nearest rock",
        Callback = function()
            local success = forceTweenToNearest()
            WindUI:Notify({
                Title = "Manual Tween",
                Content = success and "SUCCESS" or "FAILED",
                Icon = success and "check-circle" or "x-circle",
                Duration = 2
            })
        end
    })
    
    -- Tab 4: Settings
    local SettingsTab = MainWindow:Tab({
        Title = "âš™ï¸ Settings",
        Desc = "System Settings"
    })
    
    SettingsTab:Paragraph({
        Title = "âš™ï¸ System Settings",
        Desc = "Configure system behavior"
    })
    
    SettingsTab:Toggle({
        Title = "ðŸ” Debug Mode",
        Desc = "Enable debug logging in console",
        Value = debugMode,
        Callback = function(value)
            debugMode = value
            WindUI:Notify({
                Title = "Debug Mode",
                Content = value and "ENABLED" or "DISABLED",
                Icon = value and "bug" or "bug-off",
                Duration = 2
            })
        end
    })
    
    SettingsTab:Keybind({
        Title = "ðŸŽ® GUI Toggle Key",
        Desc = "Key to toggle GUI visibility",
        Value = "RightControl",
        Callback = function(key)
            toggleKeybind = key
            WindUI:Notify({
                Title = "Keybind Updated",
                Content = "Press " .. key .. " to toggle GUI",
                Icon = "keyboard",
                Duration = 3
            })
        end
    })
    
    SettingsTab:Slider({
        Title = "ðŸ“ Tween Height",
        Desc = "Height above rock to tween to",
        Value = {Default = HEIGHT_OFFSET, Min = 0, Max = 10, Step = 0.5},
        Callback = function(value)
            HEIGHT_OFFSET = value
            WindUI:Notify({
                Title = "Height Offset",
                Content = "Set to: " .. value .. " studs",
                Icon = "move-vertical",
                Duration = 2
            })
        end
    })
    
    SettingsTab:Button({
        Title = "ðŸ“Š System Status",
        Desc = "Display current system status",
        Callback = function()
            local espCount = 0
            for _ in pairs(highlightedObjects) do espCount = espCount + 1 end
            
            local statusText = "=== JAWIRSCRIPT SYSTEM STATUS ===\n\n"
            statusText = statusText .. "ðŸ”§ FORGE SYSTEM:\n"
            statusText = statusText .. "   Minigame Active: " .. tostring(isHammerMinigameActive) .. "\n"
            statusText = statusText .. "   Auto Hammer: " .. tostring(autoHammerRunning) .. "\n"
            statusText = statusText .. "   Cooldown: " .. string.format("%.1f", HAMMER_COOLDOWN) .. "s\n\n"
            
            statusText = statusText .. "ðŸ—¿ ROCK ESP:\n"
            statusText = statusText .. "   Enabled: " .. tostring(ESPEnabled) .. "\n"
            statusText = statusText .. "   Rocks Found: " .. espCount .. "\n"
            statusText = statusText .. "   Distance: " .. ESPDistance .. " studs\n\n"
            
            statusText = statusText .. "ðŸš€ AUTO TWEEN:\n"
            statusText = statusText .. "   Enabled: " .. tostring(AutoTweenEnabled) .. "\n"
            statusText = statusText .. "   Is Tweening: " .. tostring(IsTweening) .. "\n"
            statusText = statusText .. "   Cooldown: " .. TweenCooldown .. "s\n"
            statusText = statusText .. "   Search Radius: " .. SEARCH_RADIUS .. " studs\n\n"
            
            statusText = statusText .. "ðŸŽ® GUI:\n"
            statusText = statusText .. "   Visible: " .. tostring(guiVisible) .. "\n"
            statusText = statusText .. "   Toggle Key: " .. toggleKeybind .. "\n"
            statusText = statusText .. "   Debug Mode: " .. tostring(debugMode)
            
            WindUI:Dialog({
                Title = "System Status",
                Content = statusText,
                Icon = "info",
                Buttons = {
                    {
                        Title = "OK",
                        Callback = function() end
                    }
                }
            })
        end
    })
    
    SettingsTab:Button({
        Title = "ðŸ›‘ Emergency Stop",
        Desc = "Stop all auto systems immediately",
        Callback = function()
            WindUI:Notify({
                Title = "Emergency Stop",
                Content = "Stopping all systems...",
                Icon = "alert-octagon",
                Duration = 2
            })
            stopAutoHammer()
            AutoTweenEnabled = false
            if TweenConnection then
                TweenConnection:Disconnect()
                TweenConnection = nil
            end
            IsTweening = false
        end
    })
    
    SettingsTab:Button({
        Title = "ðŸ§¹ Cleanup All",
        Desc = "Clean up all system resources",
        Callback = function()
            WindUI:Notify({
                Title = "Cleanup",
                Content = "Cleaning up all systems...",
                Icon = "broom",
                Duration = 2
            })
            stopAutoHammer()
            cleanupESP()
            if TweenConnection then
                TweenConnection:Disconnect()
                TweenConnection = nil
            end
        end
    })
    
    -- Tab 5: Info
    local InfoTab = MainWindow:Tab({
        Title = "ðŸ“– Info",
        Desc = "System Information"
    })
    
    InfoTab:Paragraph({
        Title = "ðŸ“– JawirScript Auto Forge System v2.0",
        Desc = "Complete system for automating forge gameplay\n\nFeatures:\nâ€¢ Auto skip melt minigame\nâ€¢ Auto skip pour minigame\nâ€¢ Auto hammer during hammer minigame\nâ€¢ Rock ESP with distance display\nâ€¢ Auto teleport to nearest rock\nâ€¢ Adjustable cooldowns\nâ€¢ Emergency stop\nâ€¢ Debug mode\nâ€¢ Modern WindUI interface"
    })
    
    InfoTab:Paragraph({
        Title = "ðŸŽ® Controls",
        Desc = "â€¢ Press RightControl to toggle GUI\nâ€¢ Use tabs to switch between features\nâ€¢ Configure each system individually\nâ€¢ Use emergency stop if needed"
    })
    
    InfoTab:Button({
        Title = "âš ï¸ Safety Warning",
        Desc = "Important safety information",
        Callback = function()
            WindUI:Dialog({
                Title = "âš ï¸ Safety Warning",
                Content = "Important Safety Information:\n\nâ€¢ Use at your own risk\nâ€¢ May be detected by anti-cheat\nâ€¢ Keep cooldowns reasonable\nâ€¢ Don't use in populated areas\nâ€¢ Test in safe area first\nâ€¢ Monitor system performance",
                Icon = "alert-triangle",
                Buttons = {
                    {
                        Title = "I Understand",
                        Callback = function() end
                    }
                }
            })
        end
    })
    
    -- Set default flags
    flags.AutoHammerEnabled = true
    flags.SkipMeltEnabled = true
    flags.SkipPourEnabled = true
    
    return MainWindow
end

----------------------------------------------------------------
-- ===================== INITIALIZATION ======================
----------------------------------------------------------------

local function setupEventListeners()
    -- Rock ESP listeners
    Workspace.ChildAdded:Connect(function(child)
        task.wait(0.1)
        handleNewObject(child)
        
        for _, descendant in ipairs(child:GetDescendants()) do
            handleNewObject(descendant)
        end
    end)
    
    Workspace.DescendantAdded:Connect(function(descendant)
        handleNewObject(descendant)
    end)
    
    Workspace.DescendantRemoving:Connect(function(descendant)
        if highlightedObjects[descendant] then
            local espData = highlightedObjects[descendant]
            if espData.Billboard then espData.Billboard:Destroy() end
            if espData.Highlight then espData.Highlight:Destroy() end
            if espData.Tracer then espData.Tracer:Destroy() end
            if espData.Light then espData.Light:Destroy() end
            highlightedObjects[descendant] = nil
        end
    end)
    
    -- GUI keybind listener
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed then
            if input.KeyCode == Enum.KeyCode[toggleKeybind] then
                toggleGUI()
            end
        end
    end)
end

local function startUpdateLoops()
    -- Rock ESP update loop
    local espConnection = RunService.Heartbeat:Connect(mainESPUpdate)
    
    -- Initial scan
    task.spawn(function()
        task.wait(5)
        debugLog("SYSTEM", "Performing initial rock scan...")
        handleExistingObjects()
        local count = 0
        for _ in pairs(highlightedObjects) do count = count + 1 end
        debugLog("SYSTEM", "Initial scan complete. Found " .. count .. " rocks.")
    end)
    
    -- Return cleanup function
    return function()
        if espConnection then
            espConnection:Disconnect()
        end
        if TweenConnection then
            TweenConnection:Disconnect()
        end
    end
end

local function initializeSystem()
    print("========================================")
    print("JAWIRSCRIPT AUTO FORGE SYSTEM v2.0")
    print("========================================")
    
    local remoteSuccess = initializeRemotes()
    if not remoteSuccess then
        warn("[SYSTEM] Remote initialization failed")
        return
    end
    
    createMainWindow()
    setupEventListeners()
    local cleanupLoops = startUpdateLoops()
    
    -- Cleanup on player leave
    Players.LocalPlayer.AncestryChanged:Connect(function()
        if not Players.LocalPlayer.Parent then
            debugLog("SYSTEM", "Player leaving, cleaning up...")
            cleanupLoops()
            stopAutoHammer()
        end
    end)
    
    -- Cleanup on game close
    game:BindToClose(function()
        debugLog("SYSTEM", "Game closing, cleaning up...")
        cleanupLoops()
        stopAutoHammer()
    end)
    
    print("[SYSTEM] Initialization complete")
    print("[SYSTEM] Press " .. toggleKeybind .. " to toggle GUI")
    print("========================================")
end

-- Delayed initialization
task.spawn(function()
    task.wait(6)
    
    local success, err = pcall(initializeSystem)
    if not success then
        warn("[SYSTEM] Initialization error:", err)
    end
end)

-- Return public API
return {
    -- Forge System
    StopHammer = stopAutoHammer,
    StartHammer = startAutoHammer,
    ActivateHooks = hookMinigameModules,
    
    -- Rock ESP
    ToggleESP = toggleESP,
    SetESPDistance = setESPDistance,
    ScanRocks = handleExistingObjects,
    ClearESP = cleanupESP,
    
    -- Auto Tween
    ToggleAutoTween = toggleAutoTween,
    SetTweenCooldown = setTweenCooldown,
    SetSearchRadius = setSearchRadius,
    ForceTween = forceTweenToNearest,
    
    -- GUI
    ToggleGUI = toggleGUI,
    SetDebugMode = function(value) debugMode = value end,
    
    -- Status
    GetStatus = function()
        local espCount = 0
        for _ in pairs(highlightedObjects) do espCount = espCount + 1 end
        
        return {
            Forge = {
                MinigameActive = isHammerMinigameActive,
                AutoHammerRunning = autoHammerRunning,
                HammerCooldown = HAMMER_COOLDOWN
            },
            ESP = {
                Enabled = ESPEnabled,
                Distance = ESPDistance,
                RockCount = espCount
            },
            Tween = {
                Enabled = AutoTweenEnabled,
                IsTweening = IsTweening,
                Cooldown = TweenCooldown,
                SearchRadius = SEARCH_RADIUS
            },
            GUI = {
                Visible = guiVisible,
                ToggleKey = toggleKeybind
            }
        }
    end
}
