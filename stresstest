-- ============================================================
-- JAWIRSCRIPT AUTO FORGE SYSTEM
-- ============================================================
-- Gabungan sistem: Forge Skipper + Auto Mine System + Mob ESP & Auto Attack
-- TIDAK DETEKSI PLAYER - HANYA MOB
-- GUI LENGKAP DENGAN SEMUA SETTING
-- ============================================================

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer

-- Remote references
local ForgeServiceRF
local ToolServiceRF
local Knit

-- FORGE STATE
local isHammerMinigameActive = false
local autoHammerRunning = false
local originalMinigames = {}
local lastHammerTime = 0
local HAMMER_COOLDOWN = 0.5
local hammerTask = nil
local stopRequested = false
local debugMode = false
local hammerMinigameUI = nil
local minigameCompleteFlag = false

-- AUTO MINE STATE
local AutoMineEnabled = false
local IsMining = false
local IsAttacking = false
local CurrentMineTarget = nil
local CurrentAttackTarget = nil
local MineConnection = nil
local AttackConnection = nil
local MINING_COOLDOWN = 0.5
local ATTACK_COOLDOWN = 1.0
local MINING_SPEED = 100
local ATTACK_SPEED = 150
local MINING_SEARCH_RADIUS = 1000
local ATTACK_SEARCH_RADIUS = 300
local SelectedRockType = "Any"
local SelectedMobType = "Any"
local NOCLIP_ENABLED = true
local FLY_HEIGHT = 15
local MINE_DELAY = 0.5
local ATTACK_DELAY = 0.3

-- ESP STATE
local highlightedObjects = {}
local highlightedMobs = {}
local ESPEnabled = true
local MobESPEnabled = true
local ESPDistance = 500
local MobESPDistance = 300
local ESPUpdateInterval = 0.5
local lastESPUpdate = 0
local ESPConnection = nil

-- Blacklist untuk player names
local PlayerBlacklist = {}

-- Priority mob untuk auto attack saat mining
local PriorityMobs = {
    ["Blight Pyromancer"] = true,  -- Highest priority for mining
    ["Reaper"] = true,             -- High priority mobs
    ["Elite Deathaxe Skeleton"] = true,
    ["Elite Rogue Skeleton"] = true,
    ["Deathaxe Skeleton"] = true,
    ["Axe Skeleton"] = true,
    ["Skeleton Rogue"] = true,
    ["Brute Zombie"] = true,
    ["Elite Zombie"] = true,
    ["Delver Zombie"] = true,
    ["Miner Zombie"] = true,
    ["Zombie3"] = true,
    ["Zombie"] = true,
    ["Bomber"] = true,
    ["Blazing Slime"] = true,
    ["Slime"] = true
}

-- Rock configurations - UPDATED WITH NEW ROCKS
local RockConfigs = {
    -- Original rocks
    Pebble = {
        Name = "Pebble",
        Color = Color3.fromRGB(180, 160, 140),
        SizeOffset = Vector3.new(0, 2, 0),
        BillboardSize = UDim2.new(0, 80, 0, 40),
        TextSize = 16,
        Priority = 12
    },
    Rock = {
        Name = "Rock",
        Color = Color3.fromRGB(150, 120, 90),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 100, 0, 50),
        TextSize = 18,
        Priority = 11
    },
    Boulder = {
        Name = "Boulder",
        Color = Color3.fromRGB(120, 85, 60),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 120, 0, 60),
        TextSize = 20,
        Priority = 10
    },
    
    -- New Basalt rocks
    ["Basalt"] = {
        Name = "Basalt",
        Color = Color3.fromRGB(50, 50, 60),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 110, 0, 55),
        TextSize = 18,
        Priority = 9
    },
    ["Basalt Core"] = {
        Name = "Basalt Core",
        Color = Color3.fromRGB(70, 30, 40),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 130, 0, 65),
        TextSize = 20,
        Priority = 8
    },
    ["Basalt Rock"] = {
        Name = "Basalt Rock",
        Color = Color3.fromRGB(60, 60, 70),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 120, 0, 60),
        TextSize = 19,
        Priority = 8
    },
    ["Basalt Vein"] = {
        Name = "Basalt Vein",
        Color = Color3.fromRGB(80, 40, 50),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 140, 0, 70),
        TextSize = 21,
        Priority = 7
    },
    
    -- Crystal rocks
    ["Crimson Crystal"] = {
        Name = "Crimson Crystal",
        Color = Color3.fromRGB(220, 20, 60),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 150, 0, 75),
        TextSize = 22,
        Priority = 5
    },
    ["Earth Crystal"] = {
        Name = "Earth Crystal",
        Color = Color3.fromRGB(139, 69, 19),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 140, 0, 70),
        TextSize = 21,
        Priority = 6
    },
    ["Light Crystal"] = {
        Name = "Light Crystal",
        Color = Color3.fromRGB(255, 255, 200),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 150, 0, 75),
        TextSize = 22,
        Priority = 4
    },
    ["Violet Crystal"] = {
        Name = "Violet Crystal",
        Color = Color3.fromRGB(138, 43, 226),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 150, 0, 75),
        TextSize = 22,
        Priority = 3
    },
    
    -- Volcanic rocks
    ["Lava Rock"] = {
        Name = "Lava Rock",
        Color = Color3.fromRGB(255, 69, 0),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 130, 0, 65),
        TextSize = 20,
        Priority = 6
    },
    ["Volcanic Rock"] = {
        Name = "Volcanic Rock",
        Color = Color3.fromRGB(178, 34, 34),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 140, 0, 70),
        TextSize = 21,
        Priority = 5
    },
    
    -- Special rocks
    ["Lucky Block"] = {
        Name = "Lucky Block",
        Color = Color3.fromRGB(255, 215, 0),
        SizeOffset = Vector3.new(0, 6, 0),
        BillboardSize = UDim2.new(0, 160, 0, 80),
        TextSize = 24,
        Priority = 1  -- Highest priority
    }
}

-- Mob configurations (HANYA MOB - TIDAK PLAYER)
local MobConfigs = {
    ["Blight Pyromancer"] = {
        Name = "Blight Pyromancer",
        Color = Color3.fromRGB(255, 69, 0),
        SizeOffset = Vector3.new(0, 6, 0),
        BillboardSize = UDim2.new(0, 180, 0, 90),
        TextSize = 22,
        Priority = 1,
        HealthBar = true,
        IsMob = true
    },
    ["Reaper"] = {
        Name = "Reaper",
        Color = Color3.fromRGB(0, 0, 0),
        SizeOffset = Vector3.new(0, 7, 0),
        BillboardSize = UDim2.new(0, 200, 0, 100),
        TextSize = 24,
        Priority = 2,
        HealthBar = true,
        IsMob = true
    },
    ["Elite Deathaxe Skeleton"] = {
        Name = "Elite Deathaxe Skeleton",
        Color = Color3.fromRGB(220, 20, 60),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 170, 0, 85),
        TextSize = 21,
        Priority = 3,
        HealthBar = true,
        IsMob = true
    },
    ["Elite Rogue Skeleton"] = {
        Name = "Elite Rogue Skeleton",
        Color = Color3.fromRGB(0, 191, 255),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 170, 0, 85),
        TextSize = 21,
        Priority = 4,
        HealthBar = true,
        IsMob = true
    },
    ["Deathaxe Skeleton"] = {
        Name = "Deathaxe Skeleton",
        Color = Color3.fromRGB(178, 34, 34),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 160, 0, 80),
        TextSize = 20,
        Priority = 5,
        HealthBar = true,
        IsMob = true
    },
    ["Axe Skeleton"] = {
        Name = "Axe Skeleton",
        Color = Color3.fromRGB(128, 128, 128),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 150, 0, 75),
        TextSize = 19,
        Priority = 6,
        HealthBar = true,
        IsMob = true
    },
    ["Skeleton Rogue"] = {
        Name = "Skeleton Rogue",
        Color = Color3.fromRGB(105, 105, 105),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 150, 0, 75),
        TextSize = 19,
        Priority = 7,
        HealthBar = true,
        IsMob = true
    },
    ["Brute Zombie"] = {
        Name = "Brute Zombie",
        Color = Color3.fromRGB(0, 100, 0),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 160, 0, 80),
        TextSize = 20,
        Priority = 8,
        HealthBar = true,
        IsMob = true
    },
    ["Elite Zombie"] = {
        Name = "Elite Zombie",
        Color = Color3.fromRGB(50, 205, 50),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 160, 0, 80),
        TextSize = 20,
        Priority = 9,
        HealthBar = true,
        IsMob = true
    },
    ["Delver Zombie"] = {
        Name = "Delver Zombie",
        Color = Color3.fromRGB(85, 107, 47),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 150, 0, 75),
        TextSize = 19,
        Priority = 10,
        HealthBar = true,
        IsMob = true
    },
    ["Miner Zombie"] = {
        Name = "Miner Zombie",
        Color = Color3.fromRGB(139, 69, 19),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 150, 0, 75),
        TextSize = 19,
        Priority = 11,
        HealthBar = true,
        IsMob = true
    },
    ["Zombie3"] = {
        Name = "Zombie3",
        Color = Color3.fromRGB(107, 142, 35),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 140, 0, 70),
        TextSize = 18,
        Priority = 12,
        HealthBar = true,
        IsMob = true
    },
    ["Zombie"] = {
        Name = "Zombie",
        Color = Color3.fromRGB(34, 139, 34),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 140, 0, 70),
        TextSize = 18,
        Priority = 13,
        HealthBar = true,
        IsMob = true
    },
    ["Bomber"] = {
        Name = "Bomber",
        Color = Color3.fromRGB(255, 0, 0),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 160, 0, 80),
        TextSize = 20,
        Priority = 14,
        HealthBar = true,
        IsMob = true
    },
    ["Blazing Slime"] = {
        Name = "Blazing Slime",
        Color = Color3.fromRGB(255, 140, 0),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 140, 0, 70),
        TextSize = 18,
        Priority = 15,
        HealthBar = true,
        IsMob = true
    },
    ["Slime"] = {
        Name = "Slime",
        Color = Color3.fromRGB(0, 255, 0),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 130, 0, 65),
        TextSize = 17,
        Priority = 16,
        HealthBar = true,
        IsMob = true
    }
}

-- GUI STATE
local guiVisible = true
local toggleKeybind = "RightControl"
local WindUI, MainWindow

-- FLAGS STATE
local flags = {
    AutoHammerEnabled = true,
    SkipMeltEnabled = true,
    SkipPourEnabled = true,
    AutoInitialize = true,
    AutoAttackEnabled = true,
    AttackWhileMining = true,
    DebugMode = false
}

----------------------------------------------------------------
-- LOAD WINDUI LIBRARY
----------------------------------------------------------------
local function loadUILibrary()
    local success, lib = pcall(function()
        local url = "https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"
        local response = game:HttpGet(url, true)
        return loadstring(response)()
    end)
    
    if success then
        WindUI = lib
        print("[WINDUI] Library loaded successfully")
        return true
    else
        warn("[WINDUI] Failed to load WindUI Library")
        local success2, lib2 = pcall(function()
            return loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/src/main.lua"))()
        end)
        
        if success2 then
            WindUI = lib2
            print("[WINDUI] Library loaded from alternative source")
            return true
        end
        return false
    end
end

----------------------------------------------------------------
-- INITIALIZE REMOTES
----------------------------------------------------------------
local function initializeRemotes()
    local Packages = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages")
    local success, result = pcall(function()
        Knit = require(Packages.Knit)
    end)
    
    if not success then
        print("[SYSTEM] Knit not found, trying alternative")
        for _, remote in pairs(ReplicatedStorage:GetDescendants()) do
            if remote.Name == "ChangeSequence" and remote:IsA("RemoteFunction") then
                ForgeServiceRF = remote
            elseif remote.Name == "ToolActivated" and remote:IsA("RemoteFunction") then
                ToolServiceRF = remote
            end
        end
        return ForgeServiceRF ~= nil and ToolServiceRF ~= nil
    end
    
    local Services = Packages.Knit.Services
    if Services then
        local ForgeService = Services:FindFirstChild("ForgeService")
        local ToolService = Services:FindFirstChild("ToolService")
        
        if ForgeService then
            ForgeServiceRF = ForgeService.RF.ChangeSequence
        end
        if ToolService then
            ToolServiceRF = ToolService.RF.ToolActivated
        end
    end
    
    return ForgeServiceRF ~= nil and ToolServiceRF ~= nil
end

----------------------------------------------------------------
-- ==================== FORGE SKIPPER ========================
----------------------------------------------------------------
local function getHammerMinigameUI()
    local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
    local forgeUI = playerGui:WaitForChild("Forge", 5)
    if forgeUI then
        return forgeUI:WaitForChild("HammerMinigame", 3)
    end
    return nil
end

local function isMinigameVisible()
    hammerMinigameUI = getHammerMinigameUI()
    if hammerMinigameUI then
        return hammerMinigameUI.Visible
    end
    return false
end

local function isMinigameTimerComplete()
    if not hammerMinigameUI then
        hammerMinigameUI = getHammerMinigameUI()
    end
    
    if hammerMinigameUI then
        local timerBar = hammerMinigameUI:FindFirstChild("Timer")
        if timerBar then
            local bar = timerBar:FindFirstChild("Bar")
            if bar then
                return bar.Size.X.Scale >= 0.95
            end
        end
    end
    return false
end

local function debugLog(message)
    if flags.DebugMode then
        print("[DEBUG] " .. message)
    end
end

local function hammerLoop()
    debugLog("Hammer loop started")
    local hammerCount = 0
    local lastCheckTime = tick()
    
    while isHammerMinigameActive and autoHammerRunning and not stopRequested do
        local currentTime = tick()
        if currentTime - lastCheckTime > 0.5 then
            if not isMinigameVisible() or isMinigameTimerComplete() then
                debugLog("Minigame no longer active, stopping hammer")
                stopRequested = true
                break
            end
            lastCheckTime = currentTime
        end
        
        local baseDelay = HAMMER_COOLDOWN
        local randomVariation = math.random(-20, 30) / 100
        local totalDelay = math.max(0.3, baseDelay + randomVariation)
        
        debugLog("Waiting " .. string.format("%.2f", totalDelay) .. "s before next hit")
        
        local startWait = tick()
        while tick() - startWait < totalDelay do
            if not isHammerMinigameActive or not autoHammerRunning or stopRequested then
                debugLog("Breaking during wait")
                return
            end
            task.wait(0.05)
        end
        
        if not isHammerMinigameActive or not autoHammerRunning or stopRequested then
            debugLog("Breaking before send")
            return
        end
        
        local success, result = pcall(function()
            return ForgeServiceRF:InvokeServer(
                "Hammer",
                { 
                    ClientTime = workspace:GetServerTimeNow(),
                    RandomSeed = math.random(1, 1000)
                }
            )
        end)
        
        if success then
            hammerCount = hammerCount + 1
            lastHammerTime = tick()
            debugLog("Hammer hit #" .. hammerCount .. " sent successfully")
            
            if isMinigameTimerComplete() then
                debugLog("Timer completed after hit #" .. hammerCount)
                stopRequested = true
                break
            end
        else
            debugLog("Hammer hit failed: " .. tostring(result))
        end
    end
    
    debugLog("Hammer loop ended. Total hits: " .. hammerCount)
end

local function startAutoHammer()
    if autoHammerRunning then
        debugLog("Auto hammer already running")
        return
    end
    
    debugLog("Starting auto hammer system")
    autoHammerRunning = true
    stopRequested = false
    minigameCompleteFlag = false
    
    if hammerTask then
        task.cancel(hammerTask)
        hammerTask = nil
    end
    
    hammerTask = task.spawn(function()
        hammerLoop()
        
        autoHammerRunning = false
        hammerTask = nil
        debugLog("Auto hammer task cleaned up")
    end)
end

local function stopAutoHammer()
    debugLog("Stopping auto hammer requested")
    stopRequested = true
    autoHammerRunning = false
    isHammerMinigameActive = false
    minigameCompleteFlag = true
    
    if hammerTask then
        task.cancel(hammerTask)
        hammerTask = nil
    end
    
    debugLog("Auto hammer fully stopped")
end

local function hookMinigameModules()
    if not Knit then
        print("[FORGE SKIP] Knit not available")
        return false
    end
    
    local ForgeController = Knit.GetController("ForgeController")
    if not ForgeController or not ForgeController.Minigames then
        warn("[FORGE SKIP] Cannot find ForgeController minigames")
        return false
    end

    print("[FORGE SKIP] Found ForgeController with minigames")

    -- MELT
    if ForgeController.Minigames.MeltMinigame then
        originalMinigames.MeltStart = ForgeController.Minigames.MeltMinigame.Start

        ForgeController.Minigames.MeltMinigame.Start = function(self, data)
            print("[FORGE SKIP] Skipping Melt...")
            local t = workspace:GetServerTimeNow()
            task.wait(0.3)
            print("[FORGE SKIP] Melt skipped!")
            return t - 0.001
        end
    end

    -- POUR
    if ForgeController.Minigames.PourMinigame then
        originalMinigames.PourStart = ForgeController.Minigames.PourMinigame.Start

        ForgeController.Minigames.PourMinigame.Start = function(self, data)
            print("[FORGE SKIP] Skipping Pour...")
            local t = workspace:GetServerTimeNow()
            task.wait(0.3)
            print("[FORGE SKIP] Pour skipped!")
            return t - 0.001
        end
    end

    -- HAMMER
    if ForgeController.Minigames.HammerMinigame then
        local originalHammerStart = ForgeController.Minigames.HammerMinigame.Start
        local originalHammerStop = ForgeController.Minigames.HammerMinigame.Stop
        
        hammerMinigameUI = getHammerMinigameUI()
        
        ForgeController.Minigames.HammerMinigame.Start = function(self, ...)
            print("[FORGE HOOK] ===== HAMMER MINIGAME STARTED =====")
            
            isHammerMinigameActive = true
            autoHammerRunning = false
            stopRequested = false
            minigameCompleteFlag = false
            
            hammerMinigameUI = getHammerMinigameUI()
            
            if flags.AutoHammerEnabled then
                task.spawn(function()
                    task.wait(0.5)
                    if isMinigameVisible() then
                        print("[FORGE HOOK] UI detected, starting auto hammer...")
                        startAutoHammer()
                    end
                end)
            end
            
            if originalHammerStart then
                return originalHammerStart(self, ...)
            end
            return nil
        end

        ForgeController.Minigames.HammerMinigame.Stop = function(self, ...)
            print("[FORGE HOOK] ===== HAMMER MINIGAME STOPPED =====")
            
            stopAutoHammer()
            
            if originalHammerStop then
                return originalHammerStop(self, ...)
            end
            return nil
        end
        
        print("[FORGE HOOK] Hammer minigame hooks installed")
    end

    print("[FORGE SKIP] All minigames hooked successfully")
    return true
end

----------------------------------------------------------------
-- ====================== ESP SYSTEM =========================
----------------------------------------------------------------
local function isPlayerModel(model)
    if not model or not model:IsA("Model") then
        return false
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character == model then
            return true
        end
    end
    
    if model == LocalPlayer.Character then
        return true
    end
    
    local hasLeaderstats = model:FindFirstChild("leaderstats")
    local hasPlayerScripts = model:FindFirstChild("PlayerScripts")
    local hasPlayerGui = model:FindFirstChild("PlayerGui")
    local hasBackpack = model:FindFirstChild("Backpack")
    
    if hasLeaderstats or hasPlayerScripts or hasPlayerGui or hasBackpack then
        return true
    end
    
    if PlayerBlacklist[model.Name] then
        return true
    end
    
    return false
end

local function createRockESP(obj, rockType)
    local config = RockConfigs[rockType]
    if not config then 
        config = {
            Name = rockType,
            Color = Color3.fromRGB(200, 200, 200),
            SizeOffset = Vector3.new(0, 3, 0),
            BillboardSize = UDim2.new(0, 100, 0, 50),
            TextSize = 18,
            Priority = 15
        }
    end
    
    if highlightedObjects[obj] then return end
    
    local BillboardGui = Instance.new('BillboardGui')
    local TextLabel = Instance.new('TextLabel')
    local DistanceLabel = Instance.new('TextLabel')
    
    BillboardGui.Name = "RockESP"
    BillboardGui.Parent = obj
    BillboardGui.AlwaysOnTop = true
    BillboardGui.Size = config.BillboardSize
    BillboardGui.StudsOffset = config.SizeOffset
    BillboardGui.MaxDistance = ESPDistance
    BillboardGui.Enabled = ESPEnabled
    
    TextLabel.Name = "TypeLabel"
    TextLabel.Parent = BillboardGui
    TextLabel.BackgroundTransparency = 1
    TextLabel.Size = UDim2.new(1, 0, 0.6, 0)
    TextLabel.Position = UDim2.new(0, 0, 0, 0)
    TextLabel.Text = config.Name
    TextLabel.TextColor3 = config.Color
    TextLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    TextLabel.TextStrokeTransparency = 0.5
    TextLabel.TextSize = config.TextSize
    TextLabel.Font = Enum.Font.SourceSansBold
    TextLabel.TextScaled = false
    
    DistanceLabel.Name = "DistanceLabel"
    DistanceLabel.Parent = BillboardGui
    DistanceLabel.BackgroundTransparency = 1
    DistanceLabel.Size = UDim2.new(1, 0, 0.4, 0)
    DistanceLabel.Position = UDim2.new(0, 0, 0.6, 0)
    DistanceLabel.Text = "0 studs"
    DistanceLabel.TextColor3 = Color3.new(1, 1, 1)
    DistanceLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    DistanceLabel.TextStrokeTransparency = 0.5
    DistanceLabel.TextSize = config.TextSize - 2
    DistanceLabel.Font = Enum.Font.SourceSans
    
    local highlight = Instance.new("BoxHandleAdornment")
    highlight.Name = "RockHighlight"
    highlight.Adornee = obj
    highlight.AlwaysOnTop = true
    highlight.ZIndex = 10
    highlight.Size = obj.Size + Vector3.new(1, 1, 1)
    highlight.Color3 = config.Color
    highlight.Transparency = 0.2
    highlight.Visible = ESPEnabled
    highlight.Parent = obj
    
    local pointLight = Instance.new("PointLight")
    pointLight.Name = "RockGlow"
    pointLight.Color = config.Color
    pointLight.Brightness = 2
    pointLight.Range = 20
    pointLight.Enabled = ESPEnabled
    pointLight.Shadows = false
    pointLight.Parent = obj
    
    highlightedObjects[obj] = {
        Billboard = BillboardGui,
        Highlight = highlight,
        Light = pointLight,
        Config = config,
        Type = rockType,
        ObjectType = "Rock",
        LastUpdate = tick()
    }
end

local function createMobESP(obj, mobType, model)
    if isPlayerModel(model) then
        print("[MOB ESP] Skipping player model: " .. model.Name)
        return
    end
    
    local config = MobConfigs[mobType]
    if not config then 
        config = {
            Name = mobType,
            Color = Color3.fromRGB(255, 0, 0),
            SizeOffset = Vector3.new(0, 5, 0),
            BillboardSize = UDim2.new(0, 150, 0, 75),
            TextSize = 20,
            Priority = 20,
            HealthBar = false,
            IsMob = true
        }
    end
    
    if highlightedMobs[obj] then return end
    
    local BillboardGui = Instance.new('BillboardGui')
    local TextLabel = Instance.new('TextLabel')
    local DistanceLabel = Instance.new('TextLabel')
    local HealthBar = nil
    local HealthText = nil
    
    BillboardGui.Name = "MobESP"
    BillboardGui.Parent = obj
    BillboardGui.AlwaysOnTop = true
    BillboardGui.Size = config.BillboardSize
    BillboardGui.StudsOffset = config.SizeOffset
    BillboardGui.MaxDistance = MobESPDistance
    BillboardGui.Enabled = MobESPEnabled
    
    TextLabel.Name = "TypeLabel"
    TextLabel.Parent = BillboardGui
    TextLabel.BackgroundTransparency = 1
    TextLabel.Size = UDim2.new(1, 0, 0.4, 0)
    TextLabel.Position = UDim2.new(0, 0, 0, 0)
    TextLabel.Text = config.Name
    TextLabel.TextColor3 = config.Color
    TextLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    TextLabel.TextStrokeTransparency = 0.3
    TextLabel.TextSize = config.TextSize
    TextLabel.Font = Enum.Font.SourceSansBold
    TextLabel.TextScaled = false
    
    DistanceLabel.Name = "DistanceLabel"
    DistanceLabel.Parent = BillboardGui
    DistanceLabel.BackgroundTransparency = 1
    DistanceLabel.Size = UDim2.new(1, 0, 0.3, 0)
    DistanceLabel.Position = UDim2.new(0, 0, 0.4, 0)
    DistanceLabel.Text = "0 studs"
    DistanceLabel.TextColor3 = Color3.new(1, 1, 1)
    DistanceLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    DistanceLabel.TextStrokeTransparency = 0.5
    DistanceLabel.TextSize = config.TextSize - 2
    DistanceLabel.Font = Enum.Font.SourceSans
    
    if config.HealthBar then
        local healthBarFrame = Instance.new("Frame")
        healthBarFrame.Name = "HealthBarFrame"
        healthBarFrame.Size = UDim2.new(0.8, 0, 0.2, 0)
        healthBarFrame.Position = UDim2.new(0.1, 0, 0.7, 0)
        healthBarFrame.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
        healthBarFrame.BorderSizePixel = 1
        healthBarFrame.BorderColor3 = Color3.new(0, 0, 0)
        healthBarFrame.Parent = BillboardGui
        
        local healthBar = Instance.new("Frame")
        healthBar.Name = "HealthBar"
        healthBar.Size = UDim2.new(1, 0, 1, 0)
        healthBar.Position = UDim2.new(0, 0, 0, 0)
        healthBar.BackgroundColor3 = Color3.new(0, 1, 0)
        healthBar.BorderSizePixel = 0
        healthBar.Parent = healthBarFrame
        
        HealthText = Instance.new("TextLabel")
        HealthText.Name = "HealthText"
        HealthText.Size = UDim2.new(1, 0, 0.1, 0)
        HealthText.Position = UDim2.new(0, 0, 0.9, 0)
        HealthText.BackgroundTransparency = 1
        HealthText.Text = "100%"
        HealthText.TextColor3 = Color3.new(1, 1, 1)
        HealthText.TextStrokeTransparency = 0.5
        HealthText.TextSize = config.TextSize - 4
        HealthText.Font = Enum.Font.SourceSansBold
        HealthText.Parent = BillboardGui
        
        HealthBar = healthBar
    end
    
    local highlight = Instance.new("BoxHandleAdornment")
    highlight.Name = "MobHighlight"
    highlight.Adornee = obj
    highlight.AlwaysOnTop = true
    highlight.ZIndex = 10
    highlight.Size = obj.Size + Vector3.new(1, 1, 1)
    highlight.Color3 = config.Color
    highlight.Transparency = 0.3
    highlight.Visible = MobESPEnabled
    highlight.Parent = obj
    
    local pointLight = Instance.new("PointLight")
    pointLight.Name = "MobGlow"
    pointLight.Color = config.Color
    pointLight.Brightness = 3
    pointLight.Range = 25
    pointLight.Enabled = MobESPEnabled
    pointLight.Shadows = false
    pointLight.Parent = obj
    
    highlightedMobs[obj] = {
        Billboard = BillboardGui,
        Highlight = highlight,
        Light = pointLight,
        HealthBar = HealthBar,
        HealthText = HealthText,
        Config = config,
        Type = mobType,
        Model = model,
        ObjectType = "Mob",
        LastUpdate = tick()
    }
end

local function updateRockESP(obj, espData)
    if not obj or not obj.Parent then
        return false
    end
    
    local character = LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    if not humanoidRootPart then return true end
    
    local distance = (obj.Position - humanoidRootPart.Position).Magnitude
    
    if espData.Billboard and espData.Billboard:FindFirstChild("DistanceLabel") then
        espData.Billboard.DistanceLabel.Text = string.format("%.0f studs", distance)
        
        if distance < 50 then
            espData.Billboard.TypeLabel.TextColor3 = Color3.new(0, 1, 0)
        elseif distance < 100 then
            espData.Billboard.TypeLabel.TextColor3 = Color3.new(1, 1, 0)
        else
            espData.Billboard.TypeLabel.TextColor3 = espData.Config.Color
        end
        
        if espData.Highlight then
            espData.Highlight.Color3 = espData.Billboard.TypeLabel.TextColor3
        end
        
        if espData.Light then
            espData.Light.Brightness = math.clamp(30 / distance, 1, 3)
        end
        
        local shouldShow = distance <= ESPDistance
        if SelectedRockType ~= "Any" and SelectedRockType ~= espData.Type then
            shouldShow = false
        end
        
        espData.Billboard.Enabled = ESPEnabled and shouldShow
        espData.Highlight.Visible = ESPEnabled and shouldShow
        espData.Light.Enabled = ESPEnabled and shouldShow
    end
    
    espData.LastUpdate = tick()
    return true
end

local function updateMobESP(obj, espData)
    if not obj or not obj.Parent then
        return false
    end
    
    if isPlayerModel(espData.Model) then
        print("[MOB ESP] Removing ESP from player: " .. espData.Model.Name)
        return false
    end
    
    local character = LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    if not humanoidRootPart then return true end
    
    local distance = (obj.Position - humanoidRootPart.Position).Magnitude
    
    if espData.Billboard and espData.Billboard:FindFirstChild("DistanceLabel") then
        espData.Billboard.DistanceLabel.Text = string.format("%.0f studs", distance)
        
        if distance < 30 then
            espData.Billboard.TypeLabel.TextColor3 = Color3.new(1, 0, 0)
        elseif distance < 100 then
            espData.Billboard.TypeLabel.TextColor3 = Color3.new(1, 0.5, 0)
        else
            espData.Billboard.TypeLabel.TextColor3 = espData.Config.Color
        end
        
        if espData.HealthBar and espData.Model then
            local humanoid = espData.Model:FindFirstChildWhichIsA("Humanoid")
            if humanoid then
                local healthPercent = humanoid.Health / humanoid.MaxHealth
                espData.HealthBar.Size = UDim2.new(healthPercent, 0, 1, 0)
                
                if healthPercent > 0.6 then
                    espData.HealthBar.BackgroundColor3 = Color3.new(0, 1, 0)
                elseif healthPercent > 0.3 then
                    espData.HealthBar.BackgroundColor3 = Color3.new(1, 1, 0)
                else
                    espData.HealthBar.BackgroundColor3 = Color3.new(1, 0, 0)
                end
                
                if espData.HealthText then
                    espData.HealthText.Text = string.format("%.0f%%", healthPercent * 100)
                end
            end
        end
        
        if espData.Highlight then
            espData.Highlight.Color3 = espData.Billboard.TypeLabel.TextColor3
        end
        
        if espData.Light then
            espData.Light.Brightness = math.clamp(40 / distance, 2, 5)
        end
        
        local shouldShow = distance <= MobESPDistance
        if SelectedMobType ~= "Any" and SelectedMobType ~= espData.Type then
            shouldShow = false
        end
        
        espData.Billboard.Enabled = MobESPEnabled and shouldShow
        espData.Highlight.Visible = MobESPEnabled and shouldShow
        espData.Light.Enabled = MobESPEnabled and shouldShow
        
        if espData.HealthBar and espData.HealthBar.Parent then
            espData.HealthBar.Parent.Visible = MobESPEnabled and shouldShow
        end
        if espData.HealthText then
            espData.HealthText.Visible = MobESPEnabled and shouldShow
        end
    end
    
    espData.LastUpdate = tick()
    return true
end

local function scanForRocks()
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj:IsA("Model") then
            local rockType = obj.Name
            if RockConfigs[rockType] then
                local mainPart = obj:FindFirstChild("MainPart") or 
                                obj:FindFirstChild("Part") or 
                                obj:FindFirstChild("Handle") or
                                obj:FindFirstChildWhichIsA("BasePart")
                
                if mainPart then
                    if not highlightedObjects[mainPart] then
                        createRockESP(mainPart, rockType)
                    end
                end
            end
        end
    end
end

local function scanForMobs()
    local livingFolder = Workspace:FindFirstChild("Living")
    
    if livingFolder then
        for _, mobModel in pairs(livingFolder:GetChildren()) do
            if mobModel:IsA("Model") then
                if isPlayerModel(mobModel) then
                    continue
                end
                
                local mobType = mobModel.Name
                
                if MobConfigs[mobType] then
                    local humanoidRootPart = mobModel:FindFirstChild("HumanoidRootPart")
                    local torso = mobModel:FindFirstChild("Torso") or mobModel:FindFirstChild("UpperTorso")
                    local head = mobModel:FindFirstChild("Head")
                    
                    local targetPart = humanoidRootPart or torso or head
                    
                    if targetPart then
                        if not highlightedMobs[targetPart] then
                            createMobESP(targetPart, mobType, mobModel)
                        end
                    end
                else
                    local humanoid = mobModel:FindFirstChildWhichIsA("Humanoid")
                    if humanoid and not isPlayerModel(mobModel) then
                        local humanoidRootPart = mobModel:FindFirstChild("HumanoidRootPart")
                        local torso = mobModel:FindFirstChild("Torso") or mobModel:FindFirstChild("UpperTorso")
                        local head = mobModel:FindFirstChild("Head")
                        
                        local targetPart = humanoidRootPart or torso or head
                        
                        if targetPart and not highlightedMobs[targetPart] then
                            createMobESP(targetPart, mobType, mobModel)
                        end
                    end
                end
            end
        end
    else
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj:IsA("Model") then
                if isPlayerModel(obj) then
                    continue
                end
                
                local mobType = obj.Name
                
                if MobConfigs[mobType] then
                    local humanoidRootPart = obj:FindFirstChild("HumanoidRootPart")
                    local torso = obj:FindFirstChild("Torso") or obj:FindFirstChild("UpperTorso")
                    local head = obj:FindFirstChild("Head")
                    
                    local targetPart = humanoidRootPart or torso or head
                    
                    if targetPart then
                        if not highlightedMobs[targetPart] then
                            createMobESP(targetPart, mobType, obj)
                        end
                    end
                end
            end
        end
    end
end

local function autoESPUpdate()
    while true do
        scanForRocks()
        scanForMobs()
        
        for obj, espData in pairs(highlightedObjects) do
            if not updateRockESP(obj, espData) then
                if espData.Billboard then espData.Billboard:Destroy() end
                if espData.Highlight then espData.Highlight:Destroy() end
                if espData.Light then espData.Light:Destroy() end
                highlightedObjects[obj] = nil
            end
        end
        
        for obj, espData in pairs(highlightedMobs) do
            if isPlayerModel(espData.Model) then
                if espData.Billboard then espData.Billboard:Destroy() end
                if espData.Highlight then espData.Highlight:Destroy() end
                if espData.Light then espData.Light:Destroy() end
                if espData.HealthBar then espData.HealthBar.Parent:Destroy() end
                if espData.HealthText then espData.HealthText:Destroy() end
                highlightedMobs[obj] = nil
            elseif not updateMobESP(obj, espData) then
                if espData.Billboard then espData.Billboard:Destroy() end
                if espData.Highlight then espData.Highlight:Destroy() end
                if espData.Light then espData.Light:Destroy() end
                if espData.HealthBar then espData.HealthBar.Parent:Destroy() end
                if espData.HealthText then espData.HealthText:Destroy() end
                highlightedMobs[obj] = nil
            end
        end
        
        task.wait(3)
    end
end

local function cleanupESP()
    for obj, espData in pairs(highlightedObjects) do
        if espData.Billboard then espData.Billboard:Destroy() end
        if espData.Highlight then espData.Highlight:Destroy() end
        if espData.Light then espData.Light:Destroy() end
    end
    highlightedObjects = {}
    
    for obj, espData in pairs(highlightedMobs) do
        if espData.Billboard then espData.Billboard:Destroy() end
        if espData.Highlight then espData.Highlight:Destroy() end
        if espData.Light then espData.Light:Destroy() end
        if espData.HealthBar then espData.HealthBar.Parent:Destroy() end
        if espData.HealthText then espData.HealthText:Destroy() end
    end
    highlightedMobs = {}
end

local function toggleRockESP()
    ESPEnabled = not ESPEnabled
    
    for obj, espData in pairs(highlightedObjects) do
        if espData.Billboard then
            espData.Billboard.Enabled = ESPEnabled
        end
        if espData.Highlight then
            espData.Highlight.Visible = ESPEnabled
        end
        if espData.Light then
            espData.Light.Enabled = ESPEnabled
        end
    end
    
    return ESPEnabled
end

local function toggleMobESP()
    MobESPEnabled = not MobESPEnabled
    
    for obj, espData in pairs(highlightedMobs) do
        if espData.Billboard then
            espData.Billboard.Enabled = MobESPEnabled
        end
        if espData.Highlight then
            espData.Highlight.Visible = MobESPEnabled
        end
        if espData.Light then
            espData.Light.Enabled = MobESPEnabled
        end
        if espData.HealthBar and espData.HealthBar.Parent then
            espData.HealthBar.Parent.Visible = MobESPEnabled
        end
        if espData.HealthText then
            espData.HealthText.Visible = MobESPEnabled
        end
    end
    
    return MobESPEnabled
end

local function setESPDistance(distance)
    ESPDistance = math.clamp(distance, 10, 2000)
    return ESPDistance
end

local function setMobESPDistance(distance)
    MobESPDistance = math.clamp(distance, 10, 1000)
    return MobESPDistance
end

local function setRockType(rockType)
    SelectedRockType = rockType
    return SelectedRockType
end

local function setMobType(mobType)
    SelectedMobType = mobType
    return SelectedMobType
end

local function getAllRockTypes()
    local rockTypes = {}
    for rockName, _ in pairs(RockConfigs) do
        table.insert(rockTypes, rockName)
    end
    table.sort(rockTypes)
    return rockTypes
end

local function getAllMobTypes()
    local mobTypes = {}
    for mobName, config in pairs(MobConfigs) do
        if config.IsMob then
            table.insert(mobTypes, mobName)
        end
    end
    table.sort(mobTypes)
    return mobTypes
end

local function getRocksCountByType()
    local counts = {}
    
    for rockName, _ in pairs(RockConfigs) do
        counts[rockName] = 0
    end
    counts["Other"] = 0
    counts["Total"] = 0
    
    for obj, espData in pairs(highlightedObjects) do
        if espData.Type then
            if RockConfigs[espData.Type] then
                counts[espData.Type] = (counts[espData.Type] or 0) + 1
            else
                counts["Other"] = counts["Other"] + 1
            end
            counts.Total = counts.Total + 1
        end
    end
    
    return counts
end

local function getMobsCountByType()
    local counts = {}
    
    for mobName, config in pairs(MobConfigs) do
        if config.IsMob then
            counts[mobName] = 0
        end
    end
    counts["Other"] = 0
    counts["Total"] = 0
    
    for obj, espData in pairs(highlightedMobs) do
        if espData.Type then
            if isPlayerModel(espData.Model) then
                continue
            end
            
            if MobConfigs[espData.Type] and MobConfigs[espData.Type].IsMob then
                counts[espData.Type] = (counts[espData.Type] or 0) + 1
            else
                counts["Other"] = counts["Other"] + 1
            end
            counts.Total = counts.Total + 1
        end
    end
    
    return counts
end

----------------------------------------------------------------
-- ==================== AUTO ATTACK SYSTEM ====================
----------------------------------------------------------------
local function callAttackRemotes()
    local success1, result1 = pcall(function()
        local args = {"Weapon"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    task.wait(0.1)
    
    local success2, result2 = pcall(function()
        local args = {"Weapon"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    return success1 and success2
end

local function getMobsData()
    local mobs = {}
    local character = LocalPlayer.Character
    
    if not character then return mobs end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return mobs end
    
    for obj, espData in pairs(highlightedMobs) do
        if obj and obj.Parent and espData.Type then
            if isPlayerModel(espData.Model) then
                continue
            end
            
            local isAlive = true
            if espData.Model then
                local humanoid = espData.Model:FindFirstChildWhichIsA("Humanoid")
                if humanoid and humanoid.Health <= 0 then
                    isAlive = false
                end
            end
            
            if isAlive then
                if SelectedMobType == "Any" or SelectedMobType == espData.Type then
                    local distance = (obj.Position - humanoidRootPart.Position).Magnitude
                    
                    if distance <= ATTACK_SEARCH_RADIUS then
                        table.insert(mobs, {
                            Type = espData.Type,
                            Position = obj.Position,
                            Distance = distance,
                            Object = obj,
                            Model = espData.Model,
                            Config = espData.Config,
                            Priority = espData.Config.Priority or 20
                        })
                    end
                end
            end
        end
    end
    
    table.sort(mobs, function(a, b)
        if a.Priority ~= b.Priority then
            return a.Priority < b.Priority
        end
        return a.Distance < b.Distance
    end)
    
    return mobs
end

local function findNearestMob()
    local mobs = getMobsData()
    if #mobs == 0 then return nil end
    return mobs[1]
end

local function findPriorityMobs()
    local mobs = getMobsData()
    local priorityMobs = {}
    
    for _, mob in ipairs(mobs) do
        if PriorityMobs[mob.Type] then
            table.insert(priorityMobs, mob)
        end
    end
    
    table.sort(priorityMobs, function(a, b)
        if a.Priority ~= b.Priority then
            return a.Priority < b.Priority
        end
        return a.Distance < b.Distance
    end)
    
    return priorityMobs
end

local function enableNoclip()
    if not NOCLIP_ENABLED then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.CanCollide then
            part.CanCollide = false
        end
    end
end

local function disableNoclip()
    local character = LocalPlayer.Character
    if not character then return end
    
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
end

local function tweenToTargetAndAttack(targetData, isMob)
    if not targetData or not targetData.Position then 
        print("[AUTO ATTACK] Invalid target data")
        return false 
    end
    
    local character = LocalPlayer.Character
    if not character then 
        print("[AUTO ATTACK] No character found")
        return false 
    end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then 
        print("[AUTO ATTACK] No HumanoidRootPart found")
        return false 
    end
    
    if isMob and targetData.Model and isPlayerModel(targetData.Model) then
        print("[AUTO ATTACK] Cannot attack player: " .. targetData.Model.Name)
        return false
    end
    
    if isMob then
        CurrentAttackTarget = targetData
        print("[AUTO ATTACK] Setting attack target: " .. targetData.Type)
    else
        CurrentMineTarget = targetData
        print("[AUTO MINE] Setting mine target: " .. targetData.Type)
    end
    
    enableNoclip()
    
    local targetPosition
    if isMob then
        targetPosition = targetData.Position + Vector3.new(0, 5, 0)
    else
        targetPosition = targetData.Position + Vector3.new(0, FLY_HEIGHT, 0)
    end
    
    local distance = (humanoidRootPart.Position - targetPosition).Magnitude
    local speed = isMob and ATTACK_SPEED or MINING_SPEED
    local duration = math.max(0.5, distance / speed)
    
    print(string.format("[AUTO %s] Moving to target: %s (Distance: %.0f studs, Duration: %.1f sec)", 
        isMob and "ATTACK" or "MINE", targetData.Type, distance, duration))
    
    local tweenInfo = TweenInfo.new(
        duration,
        Enum.EasingStyle.Linear,
        Enum.EasingDirection.Out
    )
    
    local tween = TweenService:Create(humanoidRootPart, tweenInfo, {
        CFrame = CFrame.new(targetPosition)
    })
    
    tween:Play()
    
    local completed = false
    tween.Completed:Connect(function()
        completed = true
    end)
    
    local startTime = tick()
    while not completed and tick() - startTime < duration + 5 do
        task.wait(0.1)
        enableNoclip()
    end
    
    if completed then
        print(string.format("[AUTO %s] Arrived at target, starting action...", isMob and "ATTACK" or "MINE"))
        
        local actionStartTime = tick()
        local actionCount = 0
        
        local maxTime = isMob and 10 or 15
        local actionDelay = isMob and ATTACK_DELAY or MINE_DELAY
        
        while (isMob and IsAttacking) or (not isMob and AutoMineEnabled and IsMining) do
            if tick() - actionStartTime > maxTime then
                print(string.format("[AUTO %s] Max time reached", isMob and "ATTACK" or "MINE"))
                break
            end
            
            if not targetData.Object or not targetData.Object.Parent then
                print("[AUTO " .. (isMob and "ATTACK" or "MINE") .. "] Target disappeared")
                break
            end
            
            if isMob and targetData.Model and isPlayerModel(targetData.Model) then
                print("[AUTO ATTACK] Target is player, stopping attack")
                break
            end
            
            if isMob and targetData.Model then
                local humanoid = targetData.Model:FindFirstChildWhichIsA("Humanoid")
                if humanoid and humanoid.Health <= 0 then
                    print("[AUTO ATTACK] Mob defeated: " .. targetData.Type)
                    break
                end
            end
            
            local success
            if isMob then
                success = callAttackRemotes()
            else
                success = callMiningRemotes()
            end
            
            actionCount = actionCount + 1
            
            if success then
                print(string.format("[AUTO %s] Action cycle #%d successful", 
                    isMob and "ATTACK" or "MINE", actionCount))
            else
                print("[AUTO " .. (isMob and "ATTACK" or "MINE") .. "] Remote call failed")
            end
            
            task.wait(actionDelay)
        end
        
        print(string.format("[AUTO %s] Finished %s %s - %d cycles completed", 
            isMob and "ATTACK" or "MINE", isMob and "attacking" or "mining", targetData.Type, actionCount))
    else
        print("[AUTO " .. (isMob and "ATTACK" or "MINE") .. "] Tween failed to complete")
    end
    
    if isMob then
        IsAttacking = false
        CurrentAttackTarget = nil
    else
        IsMining = false
        CurrentMineTarget = nil
    end
    
    return true
end

local function attackPriorityMobs()
    if IsAttacking then 
        print("[AUTO ATTACK] Already attacking, skipping")
        return 
    end
    
    local priorityMobs = findPriorityMobs()
    
    if #priorityMobs > 0 then
        IsAttacking = true
        task.spawn(function()
            for _, mob in ipairs(priorityMobs) do
                if not IsAttacking then break end
                
                print(string.format("[AUTO ATTACK] Attacking priority mob %s (%.0f studs away)", 
                    mob.Type, mob.Distance))
                
                local success = tweenToTargetAndAttack(mob, true)
                
                if success then
                    print("[AUTO ATTACK] Finished attacking " .. mob.Type)
                    task.wait(ATTACK_COOLDOWN)
                else
                    print("[AUTO ATTACK] Attack failed on " .. mob.Type)
                    task.wait(2)
                end
            end
            IsAttacking = false
        end)
        return true
    end
    
    return false
end

local function startAutoAttackLoop()
    if AttackConnection then
        AttackConnection:Disconnect()
        AttackConnection = nil
    end
    
    AttackConnection = RunService.Heartbeat:Connect(function()
        if not flags.AutoAttackEnabled then return end
        if IsAttacking then return end
        
        if not LocalPlayer.Character then
            return
        end
        
        if isHammerMinigameActive then
            return
        end
        
        if flags.AttackWhileMining and (AutoMineEnabled or IsMining) then
            local priorityMobs = findPriorityMobs()
            if #priorityMobs > 0 then
                print("[AUTO ATTACK] Priority mobs detected, attacking first")
                attackPriorityMobs()
                return
            end
        end
        
        local nearestMob = findNearestMob()
        
        if nearestMob then
            if isPlayerModel(nearestMob.Model) then
                print("[AUTO ATTACK] Skipping player target: " .. nearestMob.Model.Name)
                return
            end
            
            IsAttacking = true
            task.spawn(function()
                print(string.format("[AUTO ATTACK] Starting attack on %s (%.0f studs away)", 
                    nearestMob.Type, nearestMob.Distance))
                
                local success = tweenToTargetAndAttack(nearestMob, true)
                IsAttacking = false
                
                if success then
                    print("[AUTO ATTACK] Moving to next mob in " .. ATTACK_COOLDOWN .. " seconds")
                    task.wait(ATTACK_COOLDOWN)
                else
                    print("[AUTO ATTACK] Attack failed, waiting before retry")
                    task.wait(2)
                end
            end)
        end
    end)
end

local function toggleAutoAttack()
    flags.AutoAttackEnabled = not flags.AutoAttackEnabled
    
    if flags.AutoAttackEnabled then
        print("[AUTO ATTACK] Auto attack system ENABLED")
        startAutoAttackLoop()
    else
        print("[AUTO ATTACK] Auto attack system DISABLED")
        if AttackConnection then
            AttackConnection:Disconnect()
            AttackConnection = nil
        end
        IsAttacking = false
        CurrentAttackTarget = nil
    end
    
    return flags.AutoAttackEnabled
end

local function setAttackCooldown(seconds)
    ATTACK_COOLDOWN = math.max(0.5, seconds)
    print("[AUTO ATTACK] Attack cooldown set to: " .. ATTACK_COOLDOWN .. " seconds")
    return ATTACK_COOLDOWN
end

local function setAttackSpeed(speed)
    ATTACK_SPEED = math.max(10, math.min(500, speed))
    print("[AUTO ATTACK] Attack speed set to: " .. ATTACK_SPEED .. " studs/sec")
    return ATTACK_SPEED
end

local function setAttackSearchRadius(radius)
    ATTACK_SEARCH_RADIUS = math.max(10, math.min(1000, radius))
    print("[AUTO ATTACK] Attack search radius set to: " .. ATTACK_SEARCH_RADIUS .. " studs")
    return ATTACK_SEARCH_RADIUS
end

local function setAttackDelay(delay)
    ATTACK_DELAY = math.max(0.1, math.min(2, delay))
    print("[AUTO ATTACK] Attack delay set to: " .. ATTACK_DELAY .. " seconds")
    return ATTACK_DELAY
end

local function forceAttackNearest()
    if IsAttacking then
        print("[AUTO ATTACK] Already attacking, please wait")
        return false
    end
    
    local nearestMob = findNearestMob()
    
    if nearestMob then
        if isPlayerModel(nearestMob.Model) then
            print("[AUTO ATTACK] Cannot attack player: " .. nearestMob.Model.Name)
            return false
        end
        
        print(string.format("[AUTO ATTACK] Force attacking %s (%.0f studs away)", 
            nearestMob.Type, nearestMob.Distance))
        
        IsAttacking = true
        task.spawn(function()
            local success = tweenToTargetAndAttack(nearestMob, true)
            IsAttacking = false
            return success
        end)
        return true
    else
        print("[AUTO ATTACK] No mobs found to attack")
        return false
    end
end

----------------------------------------------------------------
-- ==================== AUTO MINE SYSTEM =====================
----------------------------------------------------------------
local function getRocksData()
    local rocks = {}
    local character = LocalPlayer.Character
    
    if not character then return rocks end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return rocks end
    
    for obj, espData in pairs(highlightedObjects) do
        if obj and obj.Parent and espData.Type then
            if SelectedRockType == "Any" or SelectedRockType == espData.Type then
                local distance = (obj.Position - humanoidRootPart.Position).Magnitude
                
                if distance <= MINING_SEARCH_RADIUS then
                    table.insert(rocks, {
                        Type = espData.Type,
                        Position = obj.Position,
                        Distance = distance,
                        Object = obj,
                        Config = espData.Config,
                        Priority = espData.Config.Priority or 15
                    })
                end
            end
        end
    end
    
    table.sort(rocks, function(a, b)
        if a.Priority ~= b.Priority then
            return a.Priority < b.Priority
        end
        return a.Distance < b.Distance
    end)
    
    return rocks
end

local function findNearestRock()
    local rocks = getRocksData()
    if #rocks == 0 then return nil end
    return rocks[1]
end

local function callMiningRemotes()
    local success1, result1 = pcall(function()
        local args = {"Weapon"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    task.wait(0.1)
    
    local success2, result2 = pcall(function()
        local args = {"Pickaxe"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    task.wait(0.1)
    
    local success3, result3 = pcall(function()
        local args = {"Weapon"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    task.wait(0.1)
    
    local success4, result4 = pcall(function()
        local args = {"Pickaxe"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    return success1 and success2 and success3 and success4
end

local function tweenToRockAndMine(rockData)
    return tweenToTargetAndAttack(rockData, false)
end

local function startAutoMineLoop()
    if MineConnection then
        MineConnection:Disconnect()
        MineConnection = nil
    end
    
    MineConnection = RunService.Heartbeat:Connect(function()
        if not AutoMineEnabled then return end
        if IsMining or IsAttacking then return end
        
        if not LocalPlayer.Character then
            return
        end
        
        if isHammerMinigameActive then
            return
        end
        
        if flags.AttackWhileMining then
            local priorityMobs = findPriorityMobs()
            if #priorityMobs > 0 then
                print("[AUTO MINE] Priority mobs detected, attacking first")
                attackPriorityMobs()
                return
            end
        end
        
        local nearestRock = findNearestRock()
        
        if nearestRock then
            IsMining = true
            task.spawn(function()
                print(string.format("[AUTO MINE] Starting mining on %s (%.0f studs away)", 
                    nearestRock.Type, nearestRock.Distance))
                
                local success = tweenToRockAndMine(nearestRock)
                IsMining = false
                
                if success then
                    print("[AUTO MINE] Moving to next rock in " .. MINING_COOLDOWN .. " seconds")
                    task.wait(MINING_COOLDOWN)
                else
                    print("[AUTO MINE] Mining failed, waiting before retry")
                    task.wait(2)
                end
            end)
        end
    end)
end

local function toggleAutoMine()
    AutoMineEnabled = not AutoMineEnabled
    
    if AutoMineEnabled then
        print("[AUTO MINE] Auto mining system ENABLED")
        startAutoMineLoop()
    else
        print("[AUTO MINE] Auto mining system DISABLED")
        if MineConnection then
            MineConnection:Disconnect()
            MineConnection = nil
        end
        IsMining = false
        CurrentMineTarget = nil
        disableNoclip()
    end
    
    return AutoMineEnabled
end

local function setMiningCooldown(seconds)
    MINING_COOLDOWN = math.max(0.5, seconds)
    print("[AUTO MINE] Mining cooldown set to: " .. MINING_COOLDOWN .. " seconds")
    return MINING_COOLDOWN
end

local function setMiningSpeed(speed)
    MINING_SPEED = math.max(10, math.min(500, speed))
    print("[AUTO MINE] Mining speed set to: " .. MINING_SPEED .. " studs/sec")
    return MINING_SPEED
end

local function setSearchRadius(radius)
    MINING_SEARCH_RADIUS = math.max(10, math.min(5000, radius))
    print("[AUTO MINE] Search radius set to: " .. MINING_SEARCH_RADIUS .. " studs")
    return MINING_SEARCH_RADIUS
end

local function setFlyHeight(height)
    FLY_HEIGHT = math.max(0, math.min(100, height))
    print("[AUTO MINE] Fly height set to: " .. FLY_HEIGHT .. " studs")
    return FLY_HEIGHT
end

local function toggleNoclip()
    NOCLIP_ENABLED = not NOCLIP_ENABLED
    
    if not NOCLIP_ENABLED then
        disableNoclip()
    end
    
    print("[AUTO MINE] Noclip: " .. (NOCLIP_ENABLED and "ENABLED" or "DISABLED"))
    return NOCLIP_ENABLED
end

local function setMineDelay(delay)
    MINE_DELAY = math.max(0.1, math.min(2, delay))
    print("[AUTO MINE] Mining delay set to: " .. MINE_DELAY .. " seconds")
    return MINE_DELAY
end

local function forceMineNearest()
    if IsMining then
        print("[AUTO MINE] Already mining, please wait")
        return false
    end
    
    local nearestRock = findNearestRock()
    
    if nearestRock then
        print(string.format("[AUTO MINE] Force mining %s (%.0f studs away)", 
            nearestRock.Type, nearestRock.Distance))
        
        IsMining = true
        task.spawn(function()
            local success = tweenToRockAndMine(nearestRock)
            IsMining = false
            return success
        end)
        return true
    else
        print("[AUTO MINE] No rocks found to mine")
        return false
    end
end

----------------------------------------------------------------
-- ====================== WINDUI GUI ========================
----------------------------------------------------------------
local function toggleGUI()
    if not MainWindow then 
        print("[GUI] MainWindow not created yet")
        return 
    end
    
    if guiVisible then
        MainWindow:Close()
        if MainWindow.OpenButtonMain then
            MainWindow.OpenButtonMain:Visible(true)
        end
        guiVisible = false
        print("[GUI] GUI hidden")
    else
        MainWindow:Open()
        if MainWindow.OpenButtonMain then
            MainWindow.OpenButtonMain:Visible(false)
        end
        guiVisible = true
        print("[GUI] GUI shown")
    end
end

local function createMainWindow()
    if not loadUILibrary() then
        print("[GUI] WindUI failed to load, using fallback GUI")
        local ScreenGui = Instance.new("ScreenGui")
        ScreenGui.Name = "JawirScriptFallbackGUI"
        ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
        
        local MainFrame = Instance.new("Frame")
        MainFrame.Size = UDim2.new(0, 500, 0, 600)
        MainFrame.Position = UDim2.new(0.5, -250, 0.5, -300)
        MainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        MainFrame.BorderSizePixel = 0
        MainFrame.Active = true
        MainFrame.Draggable = true
        MainFrame.Visible = guiVisible
        MainFrame.Parent = ScreenGui
        
        local Title = Instance.new("TextLabel")
        Title.Size = UDim2.new(1, 0, 0, 40)
        Title.Position = UDim2.new(0, 0, 0, 0)
        Title.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
        Title.Text = "JawirScript - Fallback GUI"
        Title.TextColor3 = Color3.fromRGB(255, 255, 255)
        Title.Font = Enum.Font.SourceSansBold
        Title.TextSize = 18
        Title.Parent = MainFrame
        
        local CloseButton = Instance.new("TextButton")
        CloseButton.Size = UDim2.new(0, 30, 0, 30)
        CloseButton.Position = UDim2.new(1, -35, 0, 5)
        CloseButton.Text = "X"
        CloseButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
        CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        CloseButton.Font = Enum.Font.SourceSansBold
        CloseButton.TextSize = 18
        CloseButton.Parent = MainFrame
        CloseButton.MouseButton1Click:Connect(function()
            MainFrame.Visible = not MainFrame.Visible
            guiVisible = MainFrame.Visible
        end)
        
        local TabFrame = Instance.new("Frame")
        TabFrame.Size = UDim2.new(1, -10, 1, -50)
        TabFrame.Position = UDim2.new(0, 5, 0, 45)
        TabFrame.BackgroundTransparency = 1
        TabFrame.Parent = MainFrame
        
        local Tabs = Instance.new("Frame")
        Tabs.Size = UDim2.new(0, 150, 1, 0)
        Tabs.BackgroundTransparency = 1
        Tabs.Parent = TabFrame
        
        local Content = Instance.new("ScrollingFrame")
        Content.Size = UDim2.new(1, -160, 1, 0)
        Content.Position = UDim2.new(0, 160, 0, 0)
        Content.BackgroundTransparency = 1
        Content.CanvasSize = UDim2.new(0, 0, 0, 1500)
        Content.ScrollBarThickness = 5
        Content.Parent = TabFrame
        
        local UIListLayout = Instance.new("UIListLayout")
        UIListLayout.Padding = UDim.new(0, 5)
        UIListLayout.Parent = Content
        
        local tabButtons = {}
        local currentTab = nil
        
        local function showTab(tabName)
            if currentTab then
                currentTab.Visible = false
            end
            currentTab = Content
            Content.Visible = true
            
            for _, button in pairs(tabButtons) do
                button.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
            end
            if tabButtons[tabName] then
                tabButtons[tabName].BackgroundColor3 = Color3.fromRGB(80, 80, 90)
            end
        end
        
        local function createTab(name, callback)
            local tabButton = Instance.new("TextButton")
            tabButton.Size = UDim2.new(1, -10, 0, 40)
            tabButton.Position = UDim2.new(0, 5, 0, #tabButtons * 45)
            tabButton.Text = name
            tabButton.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
            tabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            tabButton.Font = Enum.Font.SourceSans
            tabButton.TextSize = 16
            tabButton.Parent = Tabs
            tabButtons[name] = tabButton
            
            tabButton.MouseButton1Click:Connect(function()
                showTab(name)
                Content:ClearAllChildren()
                Content.CanvasSize = UDim2.new(0, 0, 0, 0)
                UIListLayout.Parent = Content
                callback()
            end)
            
            if #tabButtons == 1 then
                tabButton.BackgroundColor3 = Color3.fromRGB(80, 80, 90)
                showTab(name)
                callback()
            end
        end
        
        local function createButton(text, func)
            local button = Instance.new("TextButton")
            button.Size = UDim2.new(1, -10, 0, 40)
            button.Text = text
            button.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
            button.TextColor3 = Color3.fromRGB(255, 255, 255)
            button.Font = Enum.Font.SourceSans
            button.TextSize = 16
            button.Parent = Content
            button.MouseButton1Click:Connect(func)
        end
        
        local function createToggle(text, getFunc, setFunc)
            local frame = Instance.new("Frame")
            frame.Size = UDim2.new(1, -10, 0, 40)
            frame.BackgroundTransparency = 1
            frame.Parent = Content
            
            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(0.7, 0, 1, 0)
            label.Text = text
            label.TextColor3 = Color3.fromRGB(255, 255, 255)
            label.Font = Enum.Font.SourceSans
            label.TextSize = 16
            label.BackgroundTransparency = 1
            label.TextXAlignment = Enum.TextXAlignment.Left
            label.Parent = frame
            
            local toggle = Instance.new("TextButton")
            toggle.Size = UDim2.new(0.25, 0, 0.7, 0)
            toggle.Position = UDim2.new(0.73, 0, 0.15, 0)
            toggle.Text = getFunc() and "ON" or "OFF"
            toggle.BackgroundColor3 = getFunc() and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
            toggle.TextColor3 = Color3.fromRGB(255, 255, 255)
            toggle.Font = Enum.Font.SourceSansBold
            toggle.TextSize = 14
            toggle.Parent = frame
            
            toggle.MouseButton1Click:Connect(function()
                local newValue = setFunc(not getFunc())
                toggle.Text = newValue and "ON" or "OFF"
                toggle.BackgroundColor3 = newValue and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
            end)
        end
        
        local function createSlider(text, min, max, current, func)
            local frame = Instance.new("Frame")
            frame.Size = UDim2.new(1, -10, 0, 60)
            frame.BackgroundTransparency = 1
            frame.Parent = Content
            
            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(1, 0, 0.5, 0)
            label.Text = text .. ": " .. current
            label.TextColor3 = Color3.fromRGB(255, 255, 255)
            label.Font = Enum.Font.SourceSans
            label.TextSize = 16
            label.BackgroundTransparency = 1
            label.TextXAlignment = Enum.TextXAlignment.Left
            label.Parent = frame
            
            local slider = Instance.new("Frame")
            slider.Size = UDim2.new(1, 0, 0.3, 0)
            slider.Position = UDim2.new(0, 0, 0.5, 0)
            slider.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
            slider.BorderSizePixel = 1
            slider.BorderColor3 = Color3.fromRGB(30, 30, 30)
            slider.Parent = frame
            
            local fill = Instance.new("Frame")
            fill.Size = UDim2.new((current - min) / (max - min), 0, 1, 0)
            fill.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
            fill.BorderSizePixel = 0
            fill.Parent = slider
            
            local dragging = false
            slider.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    dragging = true
                end
            end)
            
            slider.InputEnded:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    dragging = false
                end
            end)
            
            game:GetService("UserInputService").InputChanged:Connect(function(input)
                if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                    local mouse = game:GetService("Players").LocalPlayer:GetMouse()
                    local relativeX = math.clamp(mouse.X - slider.AbsolutePosition.X, 0, slider.AbsoluteSize.X)
                    local percentage = relativeX / slider.AbsoluteSize.X
                    local value = math.floor(min + (max - min) * percentage + 0.5)
                    
                    fill.Size = UDim2.new(percentage, 0, 1, 0)
                    label.Text = text .. ": " .. value
                    func(value)
                end
            end)
        end
        
        local function createDropdown(text, options, current, func)
            local frame = Instance.new("Frame")
            frame.Size = UDim2.new(1, -10, 0, 60)
            frame.BackgroundTransparency = 1
            frame.Parent = Content
            
            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(1, 0, 0.5, 0)
            label.Text = text
            label.TextColor3 = Color3.fromRGB(255, 255, 255)
            label.Font = Enum.Font.SourceSans
            label.TextSize = 16
            label.BackgroundTransparency = 1
            label.TextXAlignment = Enum.TextXAlignment.Left
            label.Parent = frame
            
            local dropdown = Instance.new("TextButton")
            dropdown.Size = UDim2.new(1, 0, 0.5, 0)
            dropdown.Position = UDim2.new(0, 0, 0.5, 0)
            dropdown.Text = current
            dropdown.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
            dropdown.TextColor3 = Color3.fromRGB(255, 255, 255)
            dropdown.Font = Enum.Font.SourceSans
            dropdown.TextSize = 14
            dropdown.Parent = frame
            
            local open = false
            local dropdownFrame = Instance.new("Frame")
            dropdownFrame.Size = UDim2.new(1, 0, 0, 200)
            dropdownFrame.Position = UDim2.new(0, 0, 1, 0)
            dropdownFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 55)
            dropdownFrame.BorderSizePixel = 1
            dropdownFrame.BorderColor3 = Color3.fromRGB(30, 30, 35)
            dropdownFrame.Visible = false
            dropdownFrame.Parent = dropdown
            
            local dropdownList = Instance.new("ScrollingFrame")
            dropdownList.Size = UDim2.new(1, 0, 1, 0)
            dropdownList.BackgroundTransparency = 1
            dropdownList.CanvasSize = UDim2.new(0, 0, 0, #options * 30)
            dropdownList.ScrollBarThickness = 5
            dropdownList.Parent = dropdownFrame
            
            local listLayout = Instance.new("UIListLayout")
            listLayout.Padding = UDim.new(0, 2)
            listLayout.Parent = dropdownList
            
            for _, option in ipairs(options) do
                local optionButton = Instance.new("TextButton")
                optionButton.Size = UDim2.new(1, -10, 0, 28)
                optionButton.Text = option
                optionButton.BackgroundColor3 = Color3.fromRGB(70, 70, 75)
                optionButton.TextColor3 = Color3.fromRGB(255, 255, 255)
                optionButton.Font = Enum.Font.SourceSans
                optionButton.TextSize = 14
                optionButton.Parent = dropdownList
                
                optionButton.MouseButton1Click:Connect(function()
                    dropdown.Text = option
                    func(option)
                    dropdownFrame.Visible = false
                    open = false
                end)
            end
            
            dropdown.MouseButton1Click:Connect(function()
                open = not open
                dropdownFrame.Visible = open
            end)
        end
        
        -- Create tabs dengan semua setting
        createTab(" Forge", function()
            createButton(" Activate Hooks", hookMinigameModules)
            createToggle(" Auto Hammer", function() return flags.AutoHammerEnabled end, 
                function(val) flags.AutoHammerEnabled = val return val end)
            createToggle(" Skip Melt", function() return flags.SkipMeltEnabled end,
                function(val) flags.SkipMeltEnabled = val return val end)
            createToggle(" Skip Pour", function() return flags.SkipPourEnabled end,
                function(val) flags.SkipPourEnabled = val return val end)
            createToggle(" Debug Mode", function() return flags.DebugMode end,
                function(val) flags.DebugMode = val return val end)
            createSlider("Hammer Cooldown", 0.1, 2.0, HAMMER_COOLDOWN, 
                function(val) HAMMER_COOLDOWN = val end)
        end)
        
        createTab(" Mining", function()
            createToggle(" Enable Auto Mine", function() return AutoMineEnabled end,
                function() return toggleAutoMine() end)
            createToggle(" Enable Noclip", function() return NOCLIP_ENABLED end,
                function() return toggleNoclip() end)
            createButton(" Mine Nearest Rock", forceMineNearest)
            createDropdown("Select Rock Type", getAllRockTypes(), SelectedRockType, setRockType)
            createSlider("Mining Speed", 10, 500, MINING_SPEED, setMiningSpeed)
            createSlider("Search Radius", 10, 5000, MINING_SEARCH_RADIUS, setSearchRadius)
            createSlider("Fly Height", 0, 100, FLY_HEIGHT, setFlyHeight)
            createSlider("Mining Cooldown", 0.1, 5, MINING_COOLDOWN, setMiningCooldown)
            createSlider("Mining Delay", 0.1, 2, MINE_DELAY, setMineDelay)
            createButton(" Show Rock Counts", function()
                local counts = getRocksCountByType()
                print("=== Rock Counts ===")
                for name, count in pairs(counts) do
                    print(name .. ": " .. count)
                end
            end)
        end)
        
        createTab(" Attack", function()
            createToggle(" Enable Auto Attack", function() return flags.AutoAttackEnabled end,
                function() return toggleAutoAttack() end)
            createToggle(" Attack While Mining", function() return flags.AttackWhileMining end,
                function(val) flags.AttackWhileMining = val return val end)
            createButton(" Attack Nearest Mob", forceAttackNearest)
            createDropdown("Select Mob Type", getAllMobTypes(), SelectedMobType, setMobType)
            createSlider("Attack Speed", 10, 500, ATTACK_SPEED, setAttackSpeed)
            createSlider("Attack Radius", 10, 1000, ATTACK_SEARCH_RADIUS, setAttackSearchRadius)
            createSlider("Attack Cooldown", 0.1, 5, ATTACK_COOLDOWN, setAttackCooldown)
            createSlider("Attack Delay", 0.1, 2, ATTACK_DELAY, setAttackDelay)
            createButton(" Show Mob Counts", function()
                local counts = getMobsCountByType()
                print("=== Mob Counts ===")
                for name, count in pairs(counts) do
                    print(name .. ": " .. count)
                end
            end)
            createButton(" Attack Priority Mobs", function()
                if not IsAttacking then
                    attackPriorityMobs()
                end
            end)
        end)
        
        createTab(" ESP", function()
            createToggle(" Rock ESP", function() return ESPEnabled end,
                function() return toggleRockESP() end)
            createToggle(" Mob ESP", function() return MobESPEnabled end,
                function() return toggleMobESP() end)
            createSlider("Rock ESP Distance", 10, 2000, ESPDistance, setESPDistance)
            createSlider("Mob ESP Distance", 10, 1000, MobESPDistance, setMobESPDistance)
            createButton(" Clear All ESP", cleanupESP)
            createToggle(" Show Health Bars", function() 
                for _, config in pairs(MobConfigs) do
                    if config.HealthBar then return true end
                end
                return false
            end, function(val)
                for _, config in pairs(MobConfigs) do
                    config.HealthBar = val
                end
                cleanupESP()
                return val
            end)
            createButton(" Refresh ESP", function()
                cleanupESP()
                task.wait(0.5)
                scanForRocks()
                scanForMobs()
            end)
        end)
        
        createTab(" Settings", function()
            createButton(" Reinitialize System", function()
                print("[SYSTEM] Reinitializing...")
                pcall(initializeRemotes)
                pcall(hookMinigameModules)
            end)
            createButton(" Restart ESP Scanner", function()
                if ESPConnection then
                    task.cancel(ESPConnection)
                end
                ESPConnection = task.spawn(autoESPUpdate)
            end)
            createDropdown("Toggle Keybind", 
                {"RightControl", "LeftControl", "RightShift", "LeftShift", "F1", "F2", "F3", "F4"}, 
                toggleKeybind, function(val) toggleKeybind = val end)
            createToggle("Auto Initialize", function() return flags.AutoInitialize end,
                function(val) flags.AutoInitialize = val return val end)
            createButton(" View Logs", function()
                print("=== System Status ===")
                print("Auto Mine: " .. tostring(AutoMineEnabled))
                print("Auto Attack: " .. tostring(flags.AutoAttackEnabled))
                print("Rock ESP: " .. tostring(ESPEnabled))
                print("Mob ESP: " .. tostring(MobESPEnabled))
                print("Noclip: " .. tostring(NOCLIP_ENABLED))
                print("Forge Hooks Active: " .. tostring(isHammerMinigameActive))
                print("Rocks Found: " .. tostring(getRocksCountByType().Total))
                print("Mobs Found: " .. tostring(getMobsCountByType().Total))
            end)
            createButton(" Save Settings", function()
                print("[SETTINGS] Save feature coming soon!")
            end)
            createButton(" Load Settings", function()
                print("[SETTINGS] Load feature coming soon!")
            end)
        end)
        
        createTab(" Info", function()
            local infoFrame = Instance.new("Frame")
            infoFrame.Size = UDim2.new(1, -10, 0, 400)
            infoFrame.BackgroundTransparency = 1
            infoFrame.Parent = Content
            
            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(1, 0, 0, 40)
            title.Text = "JawirScript v2.0"
            title.TextColor3 = Color3.fromRGB(255, 255, 255)
            title.Font = Enum.Font.SourceSansBold
            title.TextSize = 24
            title.BackgroundTransparency = 1
            title.Parent = infoFrame
            
            local desc = Instance.new("TextLabel")
            desc.Size = UDim2.new(1, 0, 0, 150)
            desc.Position = UDim2.new(0, 0, 0, 50)
            desc.Text = "Features:\n Auto Forge Skipper\n Auto Mining System\n Auto Attack System\n Rock & Mob ESP\n NoClip & Flight\n Priority Target System\n GUI with Full Settings"
            desc.TextColor3 = Color3.fromRGB(200, 200, 200)
            desc.Font = Enum.Font.SourceSans
            desc.TextSize = 16
            desc.TextYAlignment = Enum.TextYAlignment.Top
            desc.BackgroundTransparency = 1
            desc.Parent = infoFrame
            
            local warning = Instance.new("TextLabel")
            warning.Size = UDim2.new(1, 0, 0, 100)
            warning.Position = UDim2.new(0, 0, 0, 210)
            warning.Text = " Note: This script only detects MOBS, not PLAYERS.\nAll attacks are directed only at game mobs."
            warning.TextColor3 = Color3.fromRGB(255, 255, 0)
            warning.Font = Enum.Font.SourceSansBold
            warning.TextSize = 14
            warning.TextYAlignment = Enum.TextYAlignment.Top
            warning.BackgroundTransparency = 1
            warning.Parent = infoFrame
            
            local controls = Instance.new("TextLabel")
            controls.Size = UDim2.new(1, 0, 0, 80)
            controls.Position = UDim2.new(0, 0, 0, 320)
            controls.Text = "Controls:\n" .. toggleKeybind .. " - Toggle GUI\nGUI contains all settings"
            controls.TextColor3 = Color3.fromRGB(150, 200, 255)
            controls.Font = Enum.Font.SourceSans
            controls.TextSize = 14
            controls.TextYAlignment = Enum.TextYAlignment.Top
            controls.BackgroundTransparency = 1
            controls.Parent = infoFrame
        end)
        
        print("[GUI] Fallback GUI created with all settings")
        
        return {
            Open = function() 
                MainFrame.Visible = true 
                guiVisible = true
            end,
            Close = function() 
                MainFrame.Visible = false 
                guiVisible = false
            end,
            OpenButtonMain = {
                Visible = function(visible)
                end
            }
        }
    end
    
    print("[GUI] Creating WindUI Window with all settings...")
    
    local success, window = pcall(function()
        return WindUI:CreateWindow({
            Title = "JawirScript - Complete System",
            Folder = "JawirScriptCompleteSystem",
            Theme = "Dark",
            Size = UDim2.new(0, 700, 0, 750),
            Radius = 12,
            Resizable = true,
            Acrylic = true,
            Background = Color3.fromRGB(30, 30, 35),
            Author = "Auto Forge + Auto Mine + Auto Attack + ESP",
            ToggleKey = Enum.KeyCode.RightControl,
            OpenButton = {
                Title = "Jawir Script",
                Icon = "hammer",
                Enabled = true,
                Position = UDim2.new(0.5, -75, 0, 15),
                OnlyIcon = false,
                Draggable = true,
                Color = ColorSequence.new(
                    Color3.fromHex("#FF6B6B"),
                    Color3.fromHex("#4ECDC4")
                )
            }
        })
    end)
    
    if not success then
        print("[GUI] Failed to create WindUI window: " .. tostring(window))
        return nil
    end
    
    MainWindow = window
    
    -- Tab 1: Forge System
    local ForgeTab = MainWindow:Tab({
        Title = " Forge",
        Desc = "Auto Forge Skipper Settings"
    })
    
    ForgeTab:Button({
        Title = " Activate Hooks",
        Desc = "Activate minigame hooks immediately",
        Callback = hookMinigameModules
    })
    
    ForgeTab:Toggle({
        Title = " Auto Hammer",
        Desc = "Auto hammer during minigame",
        Value = flags.AutoHammerEnabled,
        Callback = function(value)
            flags.AutoHammerEnabled = value
        end
    })
    
    ForgeTab:Toggle({
        Title = " Skip Melt",
        Desc = "Skip melt minigame",
        Value = flags.SkipMeltEnabled,
        Callback = function(value)
            flags.SkipMeltEnabled = value
        end
    })
    
    ForgeTab:Toggle({
        Title = " Skip Pour",
        Desc = "Skip pour minigame",
        Value = flags.SkipPourEnabled,
        Callback = function(value)
            flags.SkipPourEnabled = value
        end
    })
    
    ForgeTab:Slider({
        Title = "Hammer Cooldown",
        Desc = "Delay between hammer hits",
        Value = HAMMER_COOLDOWN,
        Min = 0.1,
        Max = 2.0,
        Callback = function(value)
            HAMMER_COOLDOWN = value
        end
    })
    
    ForgeTab:Toggle({
        Title = " Debug Mode",
        Desc = "Enable debug logging",
        Value = flags.DebugMode,
        Callback = function(value)
            flags.DebugMode = value
            debugMode = value
        end
    })
    
    -- Tab 2: Auto Mine
    local MineTab = MainWindow:Tab({
        Title = " Mining",
        Desc = "Auto Mine System Settings"
    })
    
    MineTab:Toggle({
        Title = " Enable Auto Mine",
        Desc = "Toggle auto mining system",
        Value = AutoMineEnabled,
        Callback = function(value)
            AutoMineEnabled = toggleAutoMine()
        end
    })
    
    MineTab:Toggle({
        Title = " Enable Noclip",
        Desc = "Enable noclip while mining",
        Value = NOCLIP_ENABLED,
        Callback = function(value)
            NOCLIP_ENABLED = toggleNoclip()
        end
    })
    
    MineTab:Button({
        Title = " Mine Nearest Rock",
        Desc = "Immediately mine nearest rock",
        Callback = forceMineNearest
    })
    
    local rockTypes = getAllRockTypes()
    table.insert(rockTypes, 1, "Any")
    MineTab:Dropdown({
        Title = "Select Rock Type",
        Desc = "Filter rocks by type",
        Value = SelectedRockType,
        Options = rockTypes,
        Callback = function(value)
            SelectedRockType = value
        end
    })
    
    MineTab:Slider({
        Title = "Mining Speed",
        Desc = "Movement speed while mining",
        Value = MINING_SPEED,
        Min = 10,
        Max = 500,
        Callback = setMiningSpeed
    })
    
    MineTab:Slider({
        Title = "Search Radius",
        Desc = "Distance to search for rocks",
        Value = MINING_SEARCH_RADIUS,
        Min = 10,
        Max = 5000,
        Callback = setSearchRadius
    })
    
    MineTab:Slider({
        Title = "Fly Height",
        Desc = "Height to fly while mining",
        Value = FLY_HEIGHT,
        Min = 0,
        Max = 100,
        Callback = setFlyHeight
    })
    
    MineTab:Slider({
        Title = "Mining Cooldown",
        Desc = "Delay between mining cycles",
        Value = MINING_COOLDOWN,
        Min = 0.1,
        Max = 5,
        Callback = setMiningCooldown
    })
    
    MineTab:Slider({
        Title = "Mining Delay",
        Desc = "Delay between mining hits",
        Value = MINE_DELAY,
        Min = 0.1,
        Max = 2,
        Callback = setMineDelay
    })
    
    MineTab:Button({
        Title = " Show Rock Counts",
        Desc = "Display counts of each rock type",
        Callback = function()
            local counts = getRocksCountByType()
            print("=== Rock Counts ===")
            for name, count in pairs(counts) do
                print(name .. ": " .. count)
            end
        end
    })
    
    -- Tab 3: Auto Attack
    local AttackTab = MainWindow:Tab({
        Title = " Attack",
        Desc = "Auto Attack System Settings"
    })
    
    AttackTab:Toggle({
        Title = " Enable Auto Attack",
        Desc = "Toggle auto attack system",
        Value = flags.AutoAttackEnabled,
        Callback = function(value)
            flags.AutoAttackEnabled = toggleAutoAttack()
        end
    })
    
    AttackTab:Toggle({
        Title = " Attack While Mining",
        Desc = "Attack mobs while mining",
        Value = flags.AttackWhileMining,
        Callback = function(value)
            flags.AttackWhileMining = value
        end
    })
    
    AttackTab:Button({
        Title = " Attack Nearest Mob",
        Desc = "Immediately attack nearest mob",
        Callback = forceAttackNearest
    })
    
    AttackTab:Button({
        Title = " Attack Priority Mobs",
        Desc = "Attack priority mobs first",
        Callback = function()
            if not IsAttacking then
                attackPriorityMobs()
            end
        end
    })
    
    local mobTypes = getAllMobTypes()
    table.insert(mobTypes, 1, "Any")
    AttackTab:Dropdown({
        Title = "Select Mob Type",
        Desc = "Filter mobs by type",
        Value = SelectedMobType,
        Options = mobTypes,
        Callback = function(value)
            SelectedMobType = value
        end
    })
    
    AttackTab:Slider({
        Title = "Attack Speed",
        Desc = "Movement speed while attacking",
        Value = ATTACK_SPEED,
        Min = 10,
        Max = 500,
        Callback = setAttackSpeed
    })
    
    AttackTab:Slider({
        Title = "Attack Radius",
        Desc = "Distance to search for mobs",
        Value = ATTACK_SEARCH_RADIUS,
        Min = 10,
        Max = 1000,
        Callback = setAttackSearchRadius
    })
    
    AttackTab:Slider({
        Title = "Attack Cooldown",
        Desc = "Delay between attack cycles",
        Value = ATTACK_COOLDOWN,
        Min = 0.1,
        Max = 5,
        Callback = setAttackCooldown
    })
    
    AttackTab:Slider({
        Title = "Attack Delay",
        Desc = "Delay between attack hits",
        Value = ATTACK_DELAY,
        Min = 0.1,
        Max = 2,
        Callback = setAttackDelay
    })
    
    AttackTab:Button({
        Title = " Show Mob Counts",
        Desc = "Display counts of each mob type",
        Callback = function()
            local counts = getMobsCountByType()
            print("=== Mob Counts ===")
            for name, count in pairs(counts) do
                print(name .. ": " .. count)
            end
        end
    })
    
    -- Tab 4: ESP Settings
    local ESPTab = MainWindow:Tab({
        Title = " ESP",
        Desc = "Rock & Mob ESP Settings"
    })
    
    ESPTab:Toggle({
        Title = " Rock ESP",
        Desc = "Toggle rock ESP visibility",
        Value = ESPEnabled,
        Callback = function(value)
            ESPEnabled = toggleRockESP()
        end
    })
    
    ESPTab:Toggle({
        Title = " Mob ESP",
        Desc = "Toggle mob ESP visibility",
        Value = MobESPEnabled,
        Callback = function(value)
            MobESPEnabled = toggleMobESP()
        end
    })
    
    ESPTab:Slider({
        Title = "Rock ESP Distance",
        Desc = "Maximum distance to show rock ESP",
        Value = ESPDistance,
        Min = 10,
        Max = 2000,
        Callback = function(value)
            ESPDistance = setESPDistance(value)
        end
    })
    
    ESPTab:Slider({
        Title = "Mob ESP Distance",
        Desc = "Maximum distance to show mob ESP",
        Value = MobESPDistance,
        Min = 10,
        Max = 1000,
        Callback = function(value)
            MobESPDistance = setMobESPDistance(value)
        end
    })
    
    ESPTab:Toggle({
        Title = " Show Health Bars",
        Desc = "Show health bars on mobs",
        Value = true,
        Callback = function(value)
            for _, config in pairs(MobConfigs) do
                config.HealthBar = value
            end
            cleanupESP()
        end
    })
    
    ESPTab:Button({
        Title = " Clear All ESP",
        Desc = "Remove all ESP highlights",
        Callback = cleanupESP
    })
    
    ESPTab:Button({
        Title = " Refresh ESP",
        Desc = "Refresh ESP displays",
        Callback = function()
            cleanupESP()
            task.wait(0.5)
            scanForRocks()
            scanForMobs()
        end
    })
    
    -- Tab 5: Settings
    local SettingsTab = MainWindow:Tab({
        Title = " Settings",
        Desc = "System Configuration"
    })
    
    SettingsTab:Button({
        Title = " Reinitialize System",
        Desc = "Reinitialize all systems",
        Callback = function()
            print("[SYSTEM] Reinitializing...")
            pcall(initializeRemotes)
            pcall(hookMinigameModules)
        end
    })
    
    SettingsTab:Button({
        Title = " Restart ESP Scanner",
        Desc = "Restart ESP scanning service",
        Callback = function()
            if ESPConnection then
                task.cancel(ESPConnection)
            end
            ESPConnection = task.spawn(autoESPUpdate)
        end
    })
    
    local keyOptions = {"RightControl", "LeftControl", "RightShift", "LeftShift", "F1", "F2", "F3", "F4"}
    SettingsTab:Dropdown({
        Title = "Toggle Keybind",
        Desc = "Key to toggle GUI",
        Value = toggleKeybind,
        Options = keyOptions,
        Callback = function(value)
            toggleKeybind = value
        end
    })
    
    SettingsTab:Toggle({
        Title = "Auto Initialize",
        Desc = "Auto initialize on startup",
        Value = flags.AutoInitialize,
        Callback = function(value)
            flags.AutoInitialize = value
        end
    })
    
    SettingsTab:Button({
        Title = " View Logs",
        Desc = "Show system status and logs",
        Callback = function()
            print("=== System Status ===")
            print("Auto Mine: " .. tostring(AutoMineEnabled))
            print("Auto Attack: " .. tostring(flags.AutoAttackEnabled))
            print("Rock ESP: " .. tostring(ESPEnabled))
            print("Mob ESP: " .. tostring(MobESPEnabled))
            print("Noclip: " .. tostring(NOCLIP_ENABLED))
            print("Forge Hooks Active: " .. tostring(isHammerMinigameActive))
            print("Rocks Found: " .. tostring(getRocksCountByType().Total))
            print("Mobs Found: " .. tostring(getMobsCountByType().Total))
        end
    })
    
    SettingsTab:Button({
        Title = " Save Settings",
        Desc = "Save current settings",
        Callback = function()
            print("[SETTINGS] Save feature coming soon!")
        end
    })
    
    SettingsTab:Button({
        Title = " Load Settings",
        Desc = "Load saved settings",
        Callback = function()
            print("[SETTINGS] Load feature coming soon!")
        end
    })
    
    -- Tab 6: Info
    local InfoTab = MainWindow:Tab({
        Title = " Info",
        Desc = "System Information"
    })
    
    InfoTab:Label({
        Title = "JawirScript v2.0",
        Desc = "Complete Automation System"
    })
    
    InfoTab:Label({
        Title = "Features",
        Desc = " Auto Forge Skipper\n Auto Mining System\n Auto Attack System\n Rock & Mob ESP\n NoClip & Flight\n Priority Target System\n GUI with Full Settings"
    })
    
    InfoTab:Label({
        Title = " Important Note",
        Desc = "This script only detects MOBS, not PLAYERS.\nAll attacks are directed only at game mobs."
    })
    
    InfoTab:Label({
        Title = "Controls",
        Desc = toggleKeybind .. " - Toggle GUI\nGUI contains all settings"
    })
    
    print("[GUI] WindUI Window created with all settings")
    return MainWindow
end

----------------------------------------------------------------
-- ===================== INITIALIZATION ======================
----------------------------------------------------------------
local function setupEventListeners()
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed then
            if input.KeyCode == Enum.KeyCode[toggleKeybind] then
                toggleGUI()
            end
        end
    end)
    
    LocalPlayer.CharacterAdded:Connect(function(character)
        task.wait(1)
        if (AutoMineEnabled or IsAttacking) and NOCLIP_ENABLED then
            enableNoclip()
        end
    end)
    
    for _, player in pairs(Players:GetPlayers()) do
        PlayerBlacklist[player.Name] = true
    end
    
    Players.PlayerAdded:Connect(function(player)
        PlayerBlacklist[player.Name] = true
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        PlayerBlacklist[player.Name] = nil
    end)
end

local function startESPScanning()
    if ESPConnection then
        task.cancel(ESPConnection)
        ESPConnection = nil
    end
    
    ESPConnection = task.spawn(autoESPUpdate)
    print("[ESP] Auto scanning started")
end

local function initializeSystem()
    print("========================================")
    print("JAWIRSCRIPT AUTO FORGE & MINE SYSTEM v2.0")
    print("========================================")
    print("Features: Forge Skip + Auto Mine + Auto Attack")
    print("ESP: Hanya deteksi MOB (TIDAK deteksi PLAYER)")
    print("GUI: Press " .. toggleKeybind .. " to toggle")
    print("GUI contains ALL settings and controls")
    print("========================================")
    
    for _, player in pairs(Players:GetPlayers()) do
        PlayerBlacklist[player.Name] = true
    end
    
    pcall(initializeRemotes)
    pcall(createMainWindow)
    pcall(setupEventListeners)
    pcall(startESPScanning)
    
    task.spawn(function()
        task.wait(5)
        pcall(hookMinigameModules)
    end)
    
    task.spawn(function()
        task.wait(8)
        if flags.AutoAttackEnabled then
            pcall(startAutoAttackLoop)
        end
    end)
    
    Players.LocalPlayer.AncestryChanged:Connect(function()
        if not Players.LocalPlayer.Parent then
            pcall(stopAutoHammer)
            pcall(cleanupESP)
            pcall(disableNoclip)
            
            if MineConnection then
                MineConnection:Disconnect()
                MineConnection = nil
            end
            
            if AttackConnection then
                AttackConnection:Disconnect()
                AttackConnection = nil
            end
            
            if ESPConnection then
                task.cancel(ESPConnection)
                ESPConnection = nil
            end
        end
    end)
    
    game:BindToClose(function()
        pcall(stopAutoHammer)
        pcall(cleanupESP)
        pcall(disableNoclip)
    end)
    
    print("[SYSTEM] Initialization complete")
    print("[SYSTEM] Press " .. toggleKeybind .. " to toggle GUI")
    print("[SYSTEM] GUI contains all settings and controls")
    print("========================================")
end

task.spawn(function()
    task.wait(2)
    print("[SYSTEM] Starting initialization...")
    pcall(initializeSystem)
end)

return {
    ActivateHooks = hookMinigameModules,
    StopHammer = stopAutoHammer,
    StartHammer = startAutoHammer,
    ToggleAutoMine = toggleAutoMine,
    ForceMine = forceMineNearest,
    ToggleNoclip = toggleNoclip,
    ToggleAutoAttack = toggleAutoAttack,
    ForceAttack = forceAttackNearest,
    ToggleRockESP = toggleRockESP,
    ToggleMobESP = toggleMobESP,
    CleanupESP = cleanupESP,
    ToggleGUI = toggleGUI,
    GetStatus = function()
        return {
            AutoMine = AutoMineEnabled,
            AutoAttack = flags.AutoAttackEnabled,
            RockESP = ESPEnabled,
            MobESP = MobESPEnabled,
            Noclip = NOCLIP_ENABLED,
            ForgeActive = isHammerMinigameActive,
            RockCount = getRocksCountByType().Total,
            MobCount = getMobsCountByType().Total
        }
    end
}
