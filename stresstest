-- ============================================================
-- JAWIRSCRIPT AUTO FORGE SYSTEM - WIND UI VERSION
-- ============================================================
-- Gabungan sistem: Forge Skipper + Auto Mine System + Mob ESP & Auto Attack
-- TIDAK DETEKSI PLAYER - HANYA MOB
-- GUI: Modern Wind UI dengan efek glassmorphism
-- ============================================================

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer

-- Load Wind UI Library
local Wind = loadstring(game:HttpGet("https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wind"))()

-- Remote references
local ForgeServiceRF
local ToolServiceRF
local Knit

-- FORGE STATE
local isHammerMinigameActive = false
local autoHammerRunning = false
local originalMinigames = {}
local lastHammerTime = 0
local HAMMER_COOLDOWN = 0.5
local hammerTask = nil
local stopRequested = false
local debugMode = false
local hammerMinigameUI = nil
local minigameCompleteFlag = false

-- AUTO MINE STATE
local AutoMineEnabled = false
local IsMining = false
local IsAttacking = false
local CurrentMineTarget = nil
local CurrentAttackTarget = nil
local MineConnection = nil
local AttackConnection = nil
local MINING_COOLDOWN = 0.5
local ATTACK_COOLDOWN = 1.0
local MINING_SPEED = 100
local ATTACK_SPEED = 150
local MINING_SEARCH_RADIUS = 1000
local ATTACK_SEARCH_RADIUS = 300
local SelectedRockType = "Any"
local SelectedMobType = "Any"
local NOCLIP_ENABLED = true
local FLY_HEIGHT = 15
local MINE_DELAY = 0.5
local ATTACK_DELAY = 0.3

-- ESP STATE
local highlightedObjects = {}
local highlightedMobs = {}
local ESPEnabled = true
local MobESPEnabled = true
local ESPDistance = 500
local MobESPDistance = 300
local ESPUpdateInterval = 0.5
local lastESPUpdate = 0
local ESPConnection = nil

-- Blacklist untuk player names
local PlayerBlacklist = {}

-- Priority mob untuk auto attack saat mining
local PriorityMobs = {
    ["Blight Pyromancer"] = true,
    ["Reaper"] = true,
    ["Elite Deathaxe Skeleton"] = true,
    ["Elite Rogue Skeleton"] = true,
    ["Deathaxe Skeleton"] = true,
    ["Axe Skeleton"] = true,
    ["Skeleton Rogue"] = true,
    ["Brute Zombie"] = true,
    ["Elite Zombie"] = true,
    ["Delver Zombie"] = true,
    ["Miner Zombie"] = true,
    ["Zombie3"] = true,
    ["Zombie"] = true,
    ["Bomber"] = true,
    ["Blazing Slime"] = true,
    ["Slime"] = true
}

-- Rock configurations
local RockConfigs = {
    Pebble = {
        Name = "Pebble",
        Color = Color3.fromRGB(180, 160, 140),
        SizeOffset = Vector3.new(0, 2, 0),
        BillboardSize = UDim2.new(0, 80, 0, 40),
        TextSize = 16,
        Priority = 12
    },
    Rock = {
        Name = "Rock",
        Color = Color3.fromRGB(150, 120, 90),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 100, 0, 50),
        TextSize = 18,
        Priority = 11
    },
    Boulder = {
        Name = "Boulder",
        Color = Color3.fromRGB(120, 85, 60),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 120, 0, 60),
        TextSize = 20,
        Priority = 10
    },
    ["Basalt"] = {
        Name = "Basalt",
        Color = Color3.fromRGB(50, 50, 60),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 110, 0, 55),
        TextSize = 18,
        Priority = 9
    },
    ["Basalt Core"] = {
        Name = "Basalt Core",
        Color = Color3.fromRGB(70, 30, 40),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 130, 0, 65),
        TextSize = 20,
        Priority = 8
    },
    ["Crimson Crystal"] = {
        Name = "Crimson Crystal",
        Color = Color3.fromRGB(220, 20, 60),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 150, 0, 75),
        TextSize = 22,
        Priority = 5
    },
    ["Lucky Block"] = {
        Name = "Lucky Block",
        Color = Color3.fromRGB(255, 215, 0),
        SizeOffset = Vector3.new(0, 6, 0),
        BillboardSize = UDim2.new(0, 160, 0, 80),
        TextSize = 24,
        Priority = 1
    }
}

-- Mob configurations
local MobConfigs = {
    ["Blight Pyromancer"] = {
        Name = "Blight Pyromancer",
        Color = Color3.fromRGB(255, 69, 0),
        SizeOffset = Vector3.new(0, 6, 0),
        BillboardSize = UDim2.new(0, 180, 0, 90),
        TextSize = 22,
        Priority = 1,
        HealthBar = true,
        IsMob = true
    },
    ["Reaper"] = {
        Name = "Reaper",
        Color = Color3.fromRGB(0, 0, 0),
        SizeOffset = Vector3.new(0, 7, 0),
        BillboardSize = UDim2.new(0, 200, 0, 100),
        TextSize = 24,
        Priority = 2,
        HealthBar = true,
        IsMob = true
    },
    ["Elite Deathaxe Skeleton"] = {
        Name = "Elite Deathaxe Skeleton",
        Color = Color3.fromRGB(220, 20, 60),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 170, 0, 85),
        TextSize = 21,
        Priority = 3,
        HealthBar = true,
        IsMob = true
    },
    ["Zombie"] = {
        Name = "Zombie",
        Color = Color3.fromRGB(34, 139, 34),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 140, 0, 70),
        TextSize = 18,
        Priority = 13,
        HealthBar = true,
        IsMob = true
    },
    ["Slime"] = {
        Name = "Slime",
        Color = Color3.fromRGB(0, 255, 0),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 130, 0, 65),
        TextSize = 17,
        Priority = 16,
        HealthBar = true,
        IsMob = true
    }
}

-- FLAGS STATE
local flags = {
    AutoHammerEnabled = true,
    SkipMeltEnabled = true,
    SkipPourEnabled = true,
    AutoInitialize = true,
    AutoAttackEnabled = true,
    AttackWhileMining = true
}

----------------------------------------------------------------
-- INITIALIZE REMOTES
----------------------------------------------------------------
local function initializeRemotes()
    local Packages = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages")
    local success, result = pcall(function()
        Knit = require(Packages.Knit)
    end)
    
    if not success then
        print("[SYSTEM] Knit not found, trying alternative")
        for _, remote in pairs(ReplicatedStorage:GetDescendants()) do
            if remote.Name == "ChangeSequence" and remote:IsA("RemoteFunction") then
                ForgeServiceRF = remote
            elseif remote.Name == "ToolActivated" and remote:IsA("RemoteFunction") then
                ToolServiceRF = remote
            end
        end
        return ForgeServiceRF ~= nil and ToolServiceRF ~= nil
    end
    
    local Services = Packages.Knit.Services
    if Services then
        local ForgeService = Services:FindFirstChild("ForgeService")
        local ToolService = Services:FindFirstChild("ToolService")
        
        if ForgeService then
            ForgeServiceRF = ForgeService.RF.ChangeSequence
        end
        if ToolService then
            ToolServiceRF = ToolService.RF.ToolActivated
        end
    end
    
    return ForgeServiceRF ~= nil and ToolServiceRF ~= nil
end

----------------------------------------------------------------
-- ==================== FORGE SKIPPER ========================
----------------------------------------------------------------

local function getHammerMinigameUI()
    local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
    local forgeUI = playerGui:WaitForChild("Forge", 5)
    if forgeUI then
        return forgeUI:WaitForChild("HammerMinigame", 3)
    end
    return nil
end

local function isMinigameVisible()
    hammerMinigameUI = getHammerMinigameUI()
    if hammerMinigameUI then
        return hammerMinigameUI.Visible
    end
    return false
end

local function hammerLoop()
    local hammerCount = 0
    local lastCheckTime = tick()
    
    while isHammerMinigameActive and autoHammerRunning and not stopRequested do
        local currentTime = tick()
        if currentTime - lastCheckTime > 0.5 then
            if not isMinigameVisible() then
                stopRequested = true
                break
            end
            lastCheckTime = currentTime
        end
        
        local baseDelay = HAMMER_COOLDOWN
        local randomVariation = math.random(-20, 30) / 100
        local totalDelay = math.max(0.3, baseDelay + randomVariation)
        
        local startWait = tick()
        while tick() - startWait < totalDelay do
            if not isHammerMinigameActive or not autoHammerRunning or stopRequested then
                return
            end
            task.wait(0.05)
        end
        
        if not isHammerMinigameActive or not autoHammerRunning or stopRequested then
            return
        end
        
        local success, result = pcall(function()
            return ForgeServiceRF:InvokeServer(
                "Hammer",
                { 
                    ClientTime = workspace:GetServerTimeNow(),
                    RandomSeed = math.random(1, 1000)
                }
            )
        end)
        
        if success then
            hammerCount = hammerCount + 1
            lastHammerTime = tick()
        end
    end
end

local function startAutoHammer()
    if autoHammerRunning then
        return
    end
    
    autoHammerRunning = true
    stopRequested = false
    minigameCompleteFlag = false
    
    if hammerTask then
        task.cancel(hammerTask)
        hammerTask = nil
    end
    
    hammerTask = task.spawn(function()
        hammerLoop()
        autoHammerRunning = false
        hammerTask = nil
    end)
end

local function stopAutoHammer()
    stopRequested = true
    autoHammerRunning = false
    isHammerMinigameActive = false
    minigameCompleteFlag = true
    
    if hammerTask then
        task.cancel(hammerTask)
        hammerTask = nil
    end
end

local function hookMinigameModules()
    if not Knit then
        print("[FORGE SKIP] Knit not available")
        return false
    end
    
    local ForgeController = Knit.GetController("ForgeController")
    if not ForgeController or not ForgeController.Minigames then
        warn("[FORGE SKIP] Cannot find ForgeController minigames")
        return false
    end

    if ForgeController.Minigames.MeltMinigame then
        originalMinigames.MeltStart = ForgeController.Minigames.MeltMinigame.Start
        ForgeController.Minigames.MeltMinigame.Start = function(self, data)
            print("[FORGE SKIP] Skipping Melt...")
            local t = workspace:GetServerTimeNow()
            task.wait(0.3)
            return t - 0.001
        end
    end

    if ForgeController.Minigames.PourMinigame then
        originalMinigames.PourStart = ForgeController.Minigames.PourMinigame.Start
        ForgeController.Minigames.PourMinigame.Start = function(self, data)
            print("[FORGE SKIP] Skipping Pour...")
            local t = workspace:GetServerTimeNow()
            task.wait(0.3)
            return t - 0.001
        end
    end

    if ForgeController.Minigames.HammerMinigame then
        local originalHammerStart = ForgeController.Minigames.HammerMinigame.Start
        local originalHammerStop = ForgeController.Minigames.HammerMinigame.Stop
        
        ForgeController.Minigames.HammerMinigame.Start = function(self, ...)
            isHammerMinigameActive = true
            autoHammerRunning = false
            stopRequested = false
            minigameCompleteFlag = false
            
            if flags.AutoHammerEnabled then
                task.spawn(function()
                    task.wait(0.5)
                    if isMinigameVisible() then
                        startAutoHammer()
                    end
                end)
            end
            
            if originalHammerStart then
                return originalHammerStart(self, ...)
            end
            return nil
        end

        ForgeController.Minigames.HammerMinigame.Stop = function(self, ...)
            stopAutoHammer()
            if originalHammerStop then
                return originalHammerStop(self, ...)
            end
            return nil
        end
    end

    return true
end

----------------------------------------------------------------
-- ====================== ESP SYSTEM =========================
----------------------------------------------------------------

local function isPlayerModel(model)
    if not model or not model:IsA("Model") then
        return false
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character == model then
            return true
        end
    end
    
    if model == LocalPlayer.Character then
        return true
    end
    
    if PlayerBlacklist[model.Name] then
        return true
    end
    
    return false
end

local function createRockESP(obj, rockType)
    local config = RockConfigs[rockType] or {
        Name = rockType,
        Color = Color3.fromRGB(200, 200, 200),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 100, 0, 50),
        TextSize = 18,
        Priority = 15
    }
    
    if highlightedObjects[obj] then return end
    
    local BillboardGui = Instance.new('BillboardGui')
    local TextLabel = Instance.new('TextLabel')
    local DistanceLabel = Instance.new('TextLabel')
    
    BillboardGui.Name = "RockESP"
    BillboardGui.Parent = obj
    BillboardGui.AlwaysOnTop = true
    BillboardGui.Size = config.BillboardSize
    BillboardGui.StudsOffset = config.SizeOffset
    BillboardGui.MaxDistance = ESPDistance
    BillboardGui.Enabled = ESPEnabled
    
    TextLabel.Name = "TypeLabel"
    TextLabel.Parent = BillboardGui
    TextLabel.BackgroundTransparency = 1
    TextLabel.Size = UDim2.new(1, 0, 0.6, 0)
    TextLabel.Position = UDim2.new(0, 0, 0, 0)
    TextLabel.Text = config.Name
    TextLabel.TextColor3 = config.Color
    TextLabel.TextStrokeTransparency = 0.5
    TextLabel.TextSize = config.TextSize
    TextLabel.Font = Enum.Font.SourceSansBold
    
    DistanceLabel.Name = "DistanceLabel"
    DistanceLabel.Parent = BillboardGui
    DistanceLabel.BackgroundTransparency = 1
    DistanceLabel.Size = UDim2.new(1, 0, 0.4, 0)
    DistanceLabel.Position = UDim2.new(0, 0, 0.6, 0)
    DistanceLabel.Text = "0 studs"
    DistanceLabel.TextColor3 = Color3.new(1, 1, 1)
    DistanceLabel.TextStrokeTransparency = 0.5
    DistanceLabel.TextSize = config.TextSize - 2
    
    local highlight = Instance.new("BoxHandleAdornment")
    highlight.Name = "RockHighlight"
    highlight.Adornee = obj
    highlight.AlwaysOnTop = true
    highlight.ZIndex = 10
    highlight.Size = obj.Size + Vector3.new(1, 1, 1)
    highlight.Color3 = config.Color
    highlight.Transparency = 0.2
    highlight.Visible = ESPEnabled
    highlight.Parent = obj
    
    highlightedObjects[obj] = {
        Billboard = BillboardGui,
        Highlight = highlight,
        Config = config,
        Type = rockType,
        LastUpdate = tick()
    }
end

local function createMobESP(obj, mobType, model)
    if isPlayerModel(model) then
        return
    end
    
    local config = MobConfigs[mobType] or {
        Name = mobType,
        Color = Color3.fromRGB(255, 0, 0),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 150, 0, 75),
        TextSize = 20,
        Priority = 20,
        HealthBar = false,
        IsMob = true
    }
    
    if highlightedMobs[obj] then return end
    
    local BillboardGui = Instance.new('BillboardGui')
    local TextLabel = Instance.new('TextLabel')
    local DistanceLabel = Instance.new('TextLabel')
    
    BillboardGui.Name = "MobESP"
    BillboardGui.Parent = obj
    BillboardGui.AlwaysOnTop = true
    BillboardGui.Size = config.BillboardSize
    BillboardGui.StudsOffset = config.SizeOffset
    BillboardGui.MaxDistance = MobESPDistance
    BillboardGui.Enabled = MobESPEnabled
    
    TextLabel.Name = "TypeLabel"
    TextLabel.Parent = BillboardGui
    TextLabel.BackgroundTransparency = 1
    TextLabel.Size = UDim2.new(1, 0, 0.4, 0)
    TextLabel.Position = UDim2.new(0, 0, 0, 0)
    TextLabel.Text = config.Name
    TextLabel.TextColor3 = config.Color
    TextLabel.TextStrokeTransparency = 0.3
    TextLabel.TextSize = config.TextSize
    TextLabel.Font = Enum.Font.SourceSansBold
    
    DistanceLabel.Name = "DistanceLabel"
    DistanceLabel.Parent = BillboardGui
    DistanceLabel.BackgroundTransparency = 1
    DistanceLabel.Size = UDim2.new(1, 0, 0.3, 0)
    DistanceLabel.Position = UDim2.new(0, 0, 0.4, 0)
    DistanceLabel.Text = "0 studs"
    DistanceLabel.TextColor3 = Color3.new(1, 1, 1)
    DistanceLabel.TextStrokeTransparency = 0.5
    DistanceLabel.TextSize = config.TextSize - 2
    
    local highlight = Instance.new("BoxHandleAdornment")
    highlight.Name = "MobHighlight"
    highlight.Adornee = obj
    highlight.AlwaysOnTop = true
    highlight.ZIndex = 10
    highlight.Size = obj.Size + Vector3.new(1, 1, 1)
    highlight.Color3 = config.Color
    highlight.Transparency = 0.3
    highlight.Visible = MobESPEnabled
    highlight.Parent = obj
    
    highlightedMobs[obj] = {
        Billboard = BillboardGui,
        Highlight = highlight,
        Config = config,
        Type = mobType,
        Model = model,
        LastUpdate = tick()
    }
end

local function scanForRocks()
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj:IsA("Model") then
            local rockType = obj.Name
            if RockConfigs[rockType] then
                local mainPart = obj:FindFirstChild("MainPart") or 
                                obj:FindFirstChild("Part") or 
                                obj:FindFirstChild("Handle") or
                                obj:FindFirstChildWhichIsA("BasePart")
                
                if mainPart then
                    if not highlightedObjects[mainPart] then
                        createRockESP(mainPart, rockType)
                    end
                end
            end
        end
    end
end

local function scanForMobs()
    local livingFolder = Workspace:FindFirstChild("Living")
    
    if livingFolder then
        for _, mobModel in pairs(livingFolder:GetChildren()) do
            if mobModel:IsA("Model") then
                if isPlayerModel(mobModel) then
                    continue
                end
                
                local mobType = mobModel.Name
                if MobConfigs[mobType] then
                    local humanoidRootPart = mobModel:FindFirstChild("HumanoidRootPart")
                    local torso = mobModel:FindFirstChild("Torso") or mobModel:FindFirstChild("UpperTorso")
                    local head = mobModel:FindFirstChild("Head")
                    
                    local targetPart = humanoidRootPart or torso or head
                    
                    if targetPart then
                        if not highlightedMobs[targetPart] then
                            createMobESP(targetPart, mobType, mobModel)
                        end
                    end
                end
            end
        end
    end
end

local function cleanupESP()
    for obj, espData in pairs(highlightedObjects) do
        if espData.Billboard then espData.Billboard:Destroy() end
        if espData.Highlight then espData.Highlight:Destroy() end
    end
    highlightedObjects = {}
    
    for obj, espData in pairs(highlightedMobs) do
        if espData.Billboard then espData.Billboard:Destroy() end
        if espData.Highlight then espData.Highlight:Destroy() end
    end
    highlightedMobs = {}
end

local function toggleRockESP()
    ESPEnabled = not ESPEnabled
    
    for obj, espData in pairs(highlightedObjects) do
        if espData.Billboard then
            espData.Billboard.Enabled = ESPEnabled
        end
        if espData.Highlight then
            espData.Highlight.Visible = ESPEnabled
        end
    end
    
    return ESPEnabled
end

local function toggleMobESP()
    MobESPEnabled = not MobESPEnabled
    
    for obj, espData in pairs(highlightedMobs) do
        if espData.Billboard then
            espData.Billboard.Enabled = MobESPEnabled
        end
        if espData.Highlight then
            espData.Highlight.Visible = MobESPEnabled
        end
    end
    
    return MobESPEnabled
end

----------------------------------------------------------------
-- ==================== AUTO ATTACK SYSTEM ====================
----------------------------------------------------------------

local function callAttackRemotes()
    local success1 = pcall(function()
        return ToolServiceRF:InvokeServer("Weapon")
    end)
    
    task.wait(0.1)
    
    local success2 = pcall(function()
        return ToolServiceRF:InvokeServer("Weapon")
    end)
    
    return success1 and success2
end

local function enableNoclip()
    if not NOCLIP_ENABLED then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.CanCollide then
            part.CanCollide = false
        end
    end
end

local function disableNoclip()
    local character = LocalPlayer.Character
    if not character then return end
    
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
end

local function tweenToTargetAndAttack(targetData, isMob)
    if not targetData or not targetData.Position then 
        return false 
    end
    
    local character = LocalPlayer.Character
    if not character then return false end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end
    
    if isMob and targetData.Model and isPlayerModel(targetData.Model) then
        return false
    end
    
    if isMob then
        CurrentAttackTarget = targetData
    else
        CurrentMineTarget = targetData
    end
    
    enableNoclip()
    
    local targetPosition
    if isMob then
        targetPosition = targetData.Position + Vector3.new(0, 5, 0)
    else
        targetPosition = targetData.Position + Vector3.new(0, FLY_HEIGHT, 0)
    end
    
    local distance = (humanoidRootPart.Position - targetPosition).Magnitude
    local speed = isMob and ATTACK_SPEED or MINING_SPEED
    local duration = math.max(0.5, distance / speed)
    
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear)
    local tween = TweenService:Create(humanoidRootPart, tweenInfo, {
        CFrame = CFrame.new(targetPosition)
    })
    
    tween:Play()
    
    local completed = false
    tween.Completed:Connect(function()
        completed = true
    end)
    
    local startTime = tick()
    while not completed and tick() - startTime < duration + 5 do
        task.wait(0.1)
        enableNoclip()
    end
    
    if completed then
        local actionStartTime = tick()
        local actionCount = 0
        local maxTime = isMob and 10 or 15
        local actionDelay = isMob and ATTACK_DELAY or MINE_DELAY
        
        while (isMob and IsAttacking) or (not isMob and AutoMineEnabled and IsMining) do
            if tick() - actionStartTime > maxTime then
                break
            end
            
            if not targetData.Object or not targetData.Object.Parent then
                break
            end
            
            if isMob and targetData.Model and isPlayerModel(targetData.Model) then
                break
            end
            
            local success
            if isMob then
                success = callAttackRemotes()
            else
                success = pcall(function()
                    ToolServiceRF:InvokeServer("Weapon")
                    task.wait(0.1)
                    ToolServiceRF:InvokeServer("Pickaxe")
                    return true
                end)
            end
            
            actionCount = actionCount + 1
            task.wait(actionDelay)
        end
    end
    
    if isMob then
        IsAttacking = false
        CurrentAttackTarget = nil
    else
        IsMining = false
        CurrentMineTarget = nil
    end
    
    return true
end

local function findNearestMob()
    local mobs = {}
    local character = LocalPlayer.Character
    
    if not character then return nil end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return nil end
    
    for obj, espData in pairs(highlightedMobs) do
        if obj and obj.Parent and espData.Type then
            if isPlayerModel(espData.Model) then
                continue
            end
            
            local isAlive = true
            if espData.Model then
                local humanoid = espData.Model:FindFirstChildWhichIsA("Humanoid")
                if humanoid and humanoid.Health <= 0 then
                    isAlive = false
                end
            end
            
            if isAlive then
                if SelectedMobType == "Any" or SelectedMobType == espData.Type then
                    local distance = (obj.Position - humanoidRootPart.Position).Magnitude
                    
                    if distance <= ATTACK_SEARCH_RADIUS then
                        table.insert(mobs, {
                            Type = espData.Type,
                            Position = obj.Position,
                            Distance = distance,
                            Object = obj,
                            Model = espData.Model,
                            Config = espData.Config,
                            Priority = espData.Config.Priority or 20
                        })
                    end
                end
            end
        end
    end
    
    table.sort(mobs, function(a, b)
        if a.Priority ~= b.Priority then
            return a.Priority < b.Priority
        end
        return a.Distance < b.Distance
    end)
    
    if #mobs == 0 then return nil end
    return mobs[1]
end

local function startAutoAttackLoop()
    if AttackConnection then
        AttackConnection:Disconnect()
        AttackConnection = nil
    end
    
    AttackConnection = RunService.Heartbeat:Connect(function()
        if not flags.AutoAttackEnabled then return end
        if IsAttacking then return end
        
        if not LocalPlayer.Character or isHammerMinigameActive then
            return
        end
        
        local nearestMob = findNearestMob()
        
        if nearestMob then
            if isPlayerModel(nearestMob.Model) then
                return
            end
            
            IsAttacking = true
            task.spawn(function()
                tweenToTargetAndAttack(nearestMob, true)
                IsAttacking = false
                task.wait(ATTACK_COOLDOWN)
            end)
        end
    end)
end

local function toggleAutoAttack()
    flags.AutoAttackEnabled = not flags.AutoAttackEnabled
    
    if flags.AutoAttackEnabled then
        startAutoAttackLoop()
    else
        if AttackConnection then
            AttackConnection:Disconnect()
            AttackConnection = nil
        end
        IsAttacking = false
        CurrentAttackTarget = nil
    end
    
    return flags.AutoAttackEnabled
end

----------------------------------------------------------------
-- ==================== AUTO MINE SYSTEM =====================
----------------------------------------------------------------

local function findNearestRock()
    local rocks = {}
    local character = LocalPlayer.Character
    
    if not character then return nil end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return nil end
    
    for obj, espData in pairs(highlightedObjects) do
        if obj and obj.Parent and espData.Type then
            if SelectedRockType == "Any" or SelectedRockType == espData.Type then
                local distance = (obj.Position - humanoidRootPart.Position).Magnitude
                
                if distance <= MINING_SEARCH_RADIUS then
                    table.insert(rocks, {
                        Type = espData.Type,
                        Position = obj.Position,
                        Distance = distance,
                        Object = obj,
                        Config = espData.Config,
                        Priority = espData.Config.Priority or 15
                    })
                end
            end
        end
    end
    
    table.sort(rocks, function(a, b)
        if a.Priority ~= b.Priority then
            return a.Priority < b.Priority
        end
        return a.Distance < b.Distance
    end)
    
    if #rocks == 0 then return nil end
    return rocks[1]
end

local function startAutoMineLoop()
    if MineConnection then
        MineConnection:Disconnect()
        MineConnection = nil
    end
    
    MineConnection = RunService.Heartbeat:Connect(function()
        if not AutoMineEnabled then return end
        if IsMining or IsAttacking then return end
        
        if not LocalPlayer.Character or isHammerMinigameActive then
            return
        end
        
        local nearestRock = findNearestRock()
        
        if nearestRock then
            IsMining = true
            task.spawn(function()
                tweenToTargetAndAttack(nearestRock, false)
                IsMining = false
                task.wait(MINING_COOLDOWN)
            end)
        end
    end)
end

local function toggleAutoMine()
    AutoMineEnabled = not AutoMineEnabled
    
    if AutoMineEnabled then
        startAutoMineLoop()
    else
        if MineConnection then
            MineConnection:Disconnect()
            MineConnection = nil
        end
        IsMining = false
        CurrentMineTarget = nil
        disableNoclip()
    end
    
    return AutoMineEnabled
end

local function toggleNoclip()
    NOCLIP_ENABLED = not NOCLIP_ENABLED
    
    if not NOCLIP_ENABLED then
        disableNoclip()
    end
    
    return NOCLIP_ENABLED
end

----------------------------------------------------------------
-- ===================== WIND UI GUI ========================
----------------------------------------------------------------

local MainWindow
local guiVisible = true
local toggleKeybind = "RightControl"

local function createWindUI()
    -- Create Main Window
    MainWindow = Wind:Window("JawirScript", "Auto Forge & Mine System")
    
    -- Tab 1: Auto Mine
    local MineTab = MainWindow:Tab("â›ï¸ Auto Mine", "http://www.roblox.com/asset/?id=6031075938")
    
    MineTab:Toggle("Auto Mine", "Enable/Disable Auto Mining", false, function(state)
        AutoMineEnabled = state
        if state then
            startAutoMineLoop()
        else
            if MineConnection then
                MineConnection:Disconnect()
                MineConnection = nil
            end
            IsMining = false
            CurrentMineTarget = nil
            disableNoclip()
        end
    end)
    
    MineTab:Toggle("Noclip", "Enable/Disable Noclip", NOCLIP_ENABLED, function(state)
        NOCLIP_ENABLED = state
        if not state then
            disableNoclip()
        end
    end)
    
    MineTab:Toggle("Attack While Mining", "Attack mobs while mining", flags.AttackWhileMining, function(state)
        flags.AttackWhileMining = state
    end)
    
    MineTab:Slider("Fly Height", "Height while flying to rocks", 5, 100, FLY_HEIGHT, function(value)
        FLY_HEIGHT = value
    end)
    
    MineTab:Slider("Mining Speed", "Speed of mining", 50, 500, MINING_SPEED, function(value)
        MINING_SPEED = value
    end)
    
    MineTab:Slider("Search Radius", "Radius to search for rocks", 100, 2000, MINING_SEARCH_RADIUS, function(value)
        MINING_SEARCH_RADIUS = value
    end)
    
    MineTab:Button("Mine Nearest Rock", "Mine the nearest rock", function()
        local rock = findNearestRock()
        if rock then
            IsMining = true
            task.spawn(function()
                tweenToTargetAndAttack(rock, false)
                IsMining = false
            end)
        else
            Wind:Notify("No rocks found", "No rocks found within search radius.")
        end
    end)
    
    -- Tab 2: Auto Attack
    local AttackTab = MainWindow:Tab("âš”ï¸ Auto Attack", "http://www.roblox.com/asset/?id=6031075938")
    
    AttackTab:Toggle("Auto Attack", "Enable/Disable Auto Attack", false, function(state)
        flags.AutoAttackEnabled = state
        if state then
            startAutoAttackLoop()
        else
            if AttackConnection then
                AttackConnection:Disconnect()
                AttackConnection = nil
            end
            IsAttacking = false
            CurrentAttackTarget = nil
        end
    end)
    
    AttackTab:Slider("Attack Speed", "Speed of attacking", 50, 500, ATTACK_SPEED, function(value)
        ATTACK_SPEED = value
    end)
    
    AttackTab:Slider("Attack Radius", "Radius to search for mobs", 50, 500, ATTACK_SEARCH_RADIUS, function(value)
        ATTACK_SEARCH_RADIUS = value
    end)
    
    AttackTab:Dropdown("Target Priority", "Select which mobs to attack", {
        "Any",
        "Blight Pyromancer",
        "Reaper",
        "Elite Deathaxe Skeleton",
        "Zombie",
        "Slime"
    }, function(option)
        SelectedMobType = option
    end)
    
    AttackTab:Button("Attack Nearest Mob", "Attack the nearest mob", function()
        local mob = findNearestMob()
        if mob then
            IsAttacking = true
            task.spawn(function()
                tweenToTargetAndAttack(mob, true)
                IsAttacking = false
            end)
        else
            Wind:Notify("No mobs found", "No mobs found within search radius.")
        end
    end)
    
    -- Tab 3: ESP System
    local ESPTab = MainWindow:Tab("ðŸ‘ï¸ ESP", "http://www.roblox.com/asset/?id=6031075938")
    
    ESPTab:Toggle("Rock ESP", "Show Rock ESP", ESPEnabled, function(state)
        ESPEnabled = state
        for obj, espData in pairs(highlightedObjects) do
            if espData.Billboard then espData.Billboard.Enabled = state end
            if espData.Highlight then espData.Highlight.Visible = state end
        end
    end)
    
    ESPTab:Toggle("Mob ESP", "Show Mob ESP", MobESPEnabled, function(state)
        MobESPEnabled = state
        for obj, espData in pairs(highlightedMobs) do
            if espData.Billboard then espData.Billboard.Enabled = state end
            if espData.Highlight then espData.Highlight.Visible = state end
        end
    end)
    
    ESPTab:Slider("Rock ESP Distance", "Distance to show rock ESP", 100, 1000, ESPDistance, function(value)
        ESPDistance = value
        for obj, espData in pairs(highlightedObjects) do
            if espData.Billboard then
                espData.Billboard.MaxDistance = value
            end
        end
    end)
    
    ESPTab:Slider("Mob ESP Distance", "Distance to show mob ESP", 100, 500, MobESPDistance, function(value)
        MobESPDistance = value
        for obj, espData in pairs(highlightedMobs) do
            if espData.Billboard then
                espData.Billboard.MaxDistance = value
            end
        end
    end)
    
    ESPTab:Button("Refresh ESP", "Refresh ESP for all objects", function()
        cleanupESP()
        scanForRocks()
        scanForMobs()
        Wind:Notify("ESP Refreshed", "ESP has been refreshed for all objects.")
    end)
    
    ESPTab:Button("Clear ESP", "Clear all ESP objects", function()
        cleanupESP()
        Wind:Notify("ESP Cleared", "All ESP objects have been cleared.")
    end)
    
    -- Tab 4: Forge System
    local ForgeTab = MainWindow:Tab("âš’ï¸ Forge", "http://www.roblox.com/asset/?id=6031075938")
    
    ForgeTab:Toggle("Auto Hammer", "Enable/Disable Auto Hammer", flags.AutoHammerEnabled, function(state)
        flags.AutoHammerEnabled = state
    end)
    
    ForgeTab:Toggle("Skip Melt", "Skip melting minigame", flags.SkipMeltEnabled, function(state)
        flags.SkipMeltEnabled = state
    end)
    
    ForgeTab:Toggle("Skip Pour", "Skip pouring minigame", flags.SkipPourEnabled, function(state)
        flags.SkipPourEnabled = state
    end)
    
    ForgeTab:Button("Activate Hooks", "Activate forge minigame hooks", function()
        if hookMinigameModules() then
            Wind:Notify("Hooks Activated", "Forge minigame hooks have been activated.")
        else
            Wind:Notify("Hooks Failed", "Failed to activate forge hooks.")
        end
    end)
    
    ForgeTab:Button("Start Hammer", "Start auto hammer", function()
        startAutoHammer()
        Wind:Notify("Auto Hammer Started", "Auto hammer has been started.")
    end)
    
    ForgeTab:Button("Stop Hammer", "Stop auto hammer", function()
        stopAutoHammer()
        Wind:Notify("Auto Hammer Stopped", "Auto hammer has been stopped.")
    end)
    
    -- Tab 5: Settings
    local SettingsTab = MainWindow:Tab("âš™ï¸ Settings", "http://www.roblox.com/asset/?id=6031075938")
    
    SettingsTab:Button("Stop All Systems", "Stop all running systems", function()
        stopAutoHammer()
        AutoMineEnabled = false
        flags.AutoAttackEnabled = false
        IsMining = false
        IsAttacking = false
        disableNoclip()
        
        if MineConnection then
            MineConnection:Disconnect()
            MineConnection = nil
        end
        
        if AttackConnection then
            AttackConnection:Disconnect()
            AttackConnection = nil
        end
        
        Wind:Notify("All Systems Stopped", "All systems have been stopped.")
    end)
    
    SettingsTab:Button("System Status", "Show system status", function()
        local status = {
            "=== JAWIRSCRIPT SYSTEM STATUS ===",
            "Auto Mine: " .. (AutoMineEnabled and "ðŸŸ¢ ENABLED" or "ðŸ”´ DISABLED"),
            "Auto Attack: " .. (flags.AutoAttackEnabled and "ðŸŸ¢ ENABLED" or "ðŸ”´ DISABLED"),
            "Rock ESP: " .. (ESPEnabled and "ðŸŸ¢ ENABLED" or "ðŸ”´ DISABLED"),
            "Mob ESP: " .. (MobESPEnabled and "ðŸŸ¢ ENABLED" or "ðŸ”´ DISABLED"),
            "Noclip: " .. (NOCLIP_ENABLED and "ðŸŸ¢ ENABLED" or "ðŸ”´ DISABLED"),
            "Auto Hammer: " .. (flags.AutoHammerEnabled and "ðŸŸ¢ ENABLED" or "ðŸ”´ DISABLED"),
            "Fly Height: " .. FLY_HEIGHT .. " studs",
            "Mining Radius: " .. MINING_SEARCH_RADIUS .. " studs",
            "Attack Radius: " .. ATTACK_SEARCH_RADIUS .. " studs"
        }
        
        Wind:Notify("System Status", table.concat(status, "\n"))
        print(table.concat(status, "\n"))
    end)
    
    SettingsTab:Keybind("Toggle GUI", "Toggle GUI visibility", Enum.KeyCode.RightControl, function()
        MainWindow:Toggle()
    end)
    
    SettingsTab:Label("JawirScript v2.0")
    SettingsTab:Label("Wind UI Edition")
    
    -- Create Open Button (Floating)
    local openButton = Instance.new("TextButton")
    openButton.Name = "JawirScriptOpenButton"
    openButton.Size = UDim2.new(0, 150, 0, 40)
    openButton.Position = UDim2.new(0.5, -75, 0, 20)
    openButton.Text = "ðŸ“œ JawirScript"
    openButton.Font = Enum.Font.GothamSemibold
    openButton.TextSize = 14
    openButton.TextColor3 = Color3.new(1, 1, 1)
    openButton.BackgroundColor3 = Color3.fromHex("1a1a1a")
    openButton.BackgroundTransparency = 0.2
    openButton.BorderSizePixel = 0
    openButton.Visible = true
    openButton.Active = true
    openButton.Draggable = true
    openButton.ZIndex = 100
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = openButton
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromHex("FF0F7B")
    stroke.Thickness = 2
    stroke.Parent = openButton
    
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromHex("FF0F7B")),
        ColorSequenceKeypoint.new(1, Color3.fromHex("F89B29"))
    })
    gradient.Rotation = 90
    gradient.Parent = openButton
    
    local icon = Instance.new("ImageLabel")
    icon.Name = "Icon"
    icon.Size = UDim2.new(0, 24, 0, 24)
    icon.Position = UDim2.new(0, 10, 0.5, -12)
    icon.Image = "http://www.roblox.com/asset/?id=6031075938"
    icon.BackgroundTransparency = 1
    icon.Parent = openButton
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "Text"
    textLabel.Size = UDim2.new(1, -40, 1, 0)
    textLabel.Position = UDim2.new(0, 35, 0, 0)
    textLabel.Text = "JawirScript"
    textLabel.TextColor3 = Color3.new(1, 1, 1)
    textLabel.Font = Enum.Font.GothamSemibold
    textLabel.TextSize = 14
    textLabel.BackgroundTransparency = 1
    textLabel.TextXAlignment = Enum.TextXAlignment.Left
    textLabel.Parent = openButton
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "JawirScriptOpenGUI"
    screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    openButton.Parent = screenGui
    
    -- Button functionality
    openButton.MouseButton1Click:Connect(function()
        MainWindow:Toggle()
        openButton.Visible = false
    end)
    
    -- When window is closed, show open button
    MainWindow.windowClosed = function()
        openButton.Visible = true
    end
    
    -- Keybind untuk toggle
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == Enum.KeyCode[toggleKeybind] then
            MainWindow:Toggle()
            openButton.Visible = not MainWindow.Visible
        end
    end)
    
    print("[WIND UI] GUI created successfully")
    return MainWindow
end

----------------------------------------------------------------
-- ===================== INITIALIZATION ======================
----------------------------------------------------------------

local function setupEventListeners()
    LocalPlayer.CharacterAdded:Connect(function(character)
        task.wait(1)
        if (AutoMineEnabled or IsAttacking) and NOCLIP_ENABLED then
            enableNoclip()
        end
    end)
    
    for _, player in pairs(Players:GetPlayers()) do
        PlayerBlacklist[player.Name] = true
    end
    
    Players.PlayerAdded:Connect(function(player)
        PlayerBlacklist[player.Name] = true
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        PlayerBlacklist[player.Name] = nil
    end)
end

local function startESPScanning()
    if ESPConnection then
        task.cancel(ESPConnection)
        ESPConnection = nil
    end
    
    ESPConnection = task.spawn(function()
        while true do
            pcall(scanForRocks)
            pcall(scanForMobs)
            task.wait(3)
        end
    end)
    print("[ESP] Auto scanning started")
end

local function initializeSystem()
    print("========================================")
    print("JAWIRSCRIPT - WIND UI EDITION")
    print("========================================")
    print("Features: Forge Skip + Auto Mine + Auto Attack")
    print("ESP: Hanya deteksi MOB (TIDAK deteksi PLAYER)")
    print("GUI: Modern Wind UI dengan efek glassmorphism")
    print("Toggle Key: RightControl")
    print("OpenButton: Click 'JawirScript' floating button")
    print("========================================")
    
    for _, player in pairs(Players:GetPlayers()) do
        PlayerBlacklist[player.Name] = true
    end
    
    pcall(initializeRemotes)
    
    task.spawn(function()
        task.wait(2)
        pcall(createWindUI)
    end)
    
    pcall(setupEventListeners)
    
    pcall(startESPScanning)
    
    task.spawn(function()
        task.wait(5)
        pcall(hookMinigameModules)
    end)
    
    Players.LocalPlayer.AncestryChanged:Connect(function()
        if not Players.LocalPlayer.Parent then
            pcall(stopAutoHammer)
            pcall(cleanupESP)
            pcall(disableNoclip)
            
            if MineConnection then
                MineConnection:Disconnect()
                MineConnection = nil
            end
            
            if AttackConnection then
                AttackConnection:Disconnect()
                AttackConnection = nil
            end
            
            if ESPConnection then
                task.cancel(ESPConnection)
                ESPConnection = nil
            end
        end
    end)
    
    Wind:Notify("JawirScript Loaded", "System initialized successfully!")
    print("[SYSTEM] Initialization complete")
    print("========================================")
end

task.spawn(function()
    task.wait(3)
    print("[SYSTEM] Starting initialization...")
    pcall(initializeSystem)
end)

return {
    ActivateHooks = hookMinigameModules,
    StopHammer = stopAutoHammer,
    StartHammer = startAutoHammer,
    ToggleAutoMine = toggleAutoMine,
    ToggleAutoAttack = toggleAutoAttack,
    ToggleRockESP = toggleRockESP,
    ToggleMobESP = toggleMobESP,
    CleanupESP = cleanupESP,
    ToggleNoclip = toggleNoclip
}
