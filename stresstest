-- ============================================================
-- JAWIRSCRIPT AUTO FORGE SYSTEM
-- ============================================================
-- Gabungan sistem: Forge Skipper + Auto Mine System + Mob ESP & Auto Attack
-- TIDAK DETEKSI PLAYER - HANYA MOB
-- ============================================================

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer

-- Remote references
local ForgeServiceRF
local ToolServiceRF
local Knit

-- FORGE STATE
local isHammerMinigameActive = false
local autoHammerRunning = false
local originalMinigames = {}
local lastHammerTime = 0
local HAMMER_COOLDOWN = 0.5
local hammerTask = nil
local stopRequested = false
local debugMode = false
local hammerMinigameUI = nil
local minigameCompleteFlag = false

-- AUTO MINE STATE
local AutoMineEnabled = false
local IsMining = false
local IsAttacking = false
local CurrentMineTarget = nil
local CurrentAttackTarget = nil
local MineConnection = nil
local AttackConnection = nil
local MINING_COOLDOWN = 0.5
local ATTACK_COOLDOWN = 1.0
local MINING_SPEED = 100
local ATTACK_SPEED = 150
local MINING_SEARCH_RADIUS = 1000
local ATTACK_SEARCH_RADIUS = 300
local SelectedRockType = "Any"
local SelectedMobType = "Any"
local NOCLIP_ENABLED = true
local FLY_HEIGHT = 15
local MINE_DELAY = 0.5
local ATTACK_DELAY = 0.3

-- ESP STATE
local highlightedObjects = {}
local highlightedMobs = {}
local ESPEnabled = true
local MobESPEnabled = true
local ESPDistance = 500
local MobESPDistance = 300
local ESPUpdateInterval = 0.5
local lastESPUpdate = 0
local ESPConnection = nil

-- Blacklist untuk player names
local PlayerBlacklist = {}

-- Priority mob untuk auto attack saat mining
local PriorityMobs = {
    ["Blight Pyromancer"] = true,  -- Highest priority for mining
    ["Reaper"] = true,             -- High priority mobs
    ["Elite Deathaxe Skeleton"] = true,
    ["Elite Rogue Skeleton"] = true,
    ["Deathaxe Skeleton"] = true,
    ["Axe Skeleton"] = true,
    ["Skeleton Rogue"] = true,
    ["Brute Zombie"] = true,
    ["Elite Zombie"] = true,
    ["Delver Zombie"] = true,
    ["Miner Zombie"] = true,
    ["Zombie3"] = true,
    ["Zombie"] = true,
    ["Bomber"] = true,
    ["Blazing Slime"] = true,
    ["Slime"] = true
}

-- Rock configurations - UPDATED WITH NEW ROCKS
local RockConfigs = {
    -- Original rocks
    Pebble = {
        Name = "Pebble",
        Color = Color3.fromRGB(180, 160, 140),
        SizeOffset = Vector3.new(0, 2, 0),
        BillboardSize = UDim2.new(0, 80, 0, 40),
        TextSize = 16,
        Priority = 12
    },
    Rock = {
        Name = "Rock",
        Color = Color3.fromRGB(150, 120, 90),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 100, 0, 50),
        TextSize = 18,
        Priority = 11
    },
    Boulder = {
        Name = "Boulder",
        Color = Color3.fromRGB(120, 85, 60),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 120, 0, 60),
        TextSize = 20,
        Priority = 10
    },
    
    -- New Basalt rocks
    ["Basalt"] = {
        Name = "Basalt",
        Color = Color3.fromRGB(50, 50, 60),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 110, 0, 55),
        TextSize = 18,
        Priority = 9
    },
    ["Basalt Core"] = {
        Name = "Basalt Core",
        Color = Color3.fromRGB(70, 30, 40),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 130, 0, 65),
        TextSize = 20,
        Priority = 8
    },
    ["Basalt Rock"] = {
        Name = "Basalt Rock",
        Color = Color3.fromRGB(60, 60, 70),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 120, 0, 60),
        TextSize = 19,
        Priority = 8
    },
    ["Basalt Vein"] = {
        Name = "Basalt Vein",
        Color = Color3.fromRGB(80, 40, 50),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 140, 0, 70),
        TextSize = 21,
        Priority = 7
    },
    
    -- Crystal rocks
    ["Crimson Crystal"] = {
        Name = "Crimson Crystal",
        Color = Color3.fromRGB(220, 20, 60),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 150, 0, 75),
        TextSize = 22,
        Priority = 5
    },
    ["Earth Crystal"] = {
        Name = "Earth Crystal",
        Color = Color3.fromRGB(139, 69, 19),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 140, 0, 70),
        TextSize = 21,
        Priority = 6
    },
    ["Light Crystal"] = {
        Name = "Light Crystal",
        Color = Color3.fromRGB(255, 255, 200),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 150, 0, 75),
        TextSize = 22,
        Priority = 4
    },
    ["Violet Crystal"] = {
        Name = "Violet Crystal",
        Color = Color3.fromRGB(138, 43, 226),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 150, 0, 75),
        TextSize = 22,
        Priority = 3
    },
    
    -- Volcanic rocks
    ["Lava Rock"] = {
        Name = "Lava Rock",
        Color = Color3.fromRGB(255, 69, 0),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 130, 0, 65),
        TextSize = 20,
        Priority = 6
    },
    ["Volcanic Rock"] = {
        Name = "Volcanic Rock",
        Color = Color3.fromRGB(178, 34, 34),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 140, 0, 70),
        TextSize = 21,
        Priority = 5
    },
    
    -- Special rocks
    ["Lucky Block"] = {
        Name = "Lucky Block",
        Color = Color3.fromRGB(255, 215, 0),
        SizeOffset = Vector3.new(0, 6, 0),
        BillboardSize = UDim2.new(0, 160, 0, 80),
        TextSize = 24,
        Priority = 1  -- Highest priority
    }
}

-- Mob configurations (HANYA MOB - TIDAK PLAYER)
local MobConfigs = {
    ["Blight Pyromancer"] = {
        Name = "Blight Pyromancer",
        Color = Color3.fromRGB(255, 69, 0),
        SizeOffset = Vector3.new(0, 6, 0),
        BillboardSize = UDim2.new(0, 180, 0, 90),
        TextSize = 22,
        Priority = 1,
        HealthBar = true,
        IsMob = true
    },
    ["Reaper"] = {
        Name = "Reaper",
        Color = Color3.fromRGB(0, 0, 0),
        SizeOffset = Vector3.new(0, 7, 0),
        BillboardSize = UDim2.new(0, 200, 0, 100),
        TextSize = 24,
        Priority = 2,
        HealthBar = true,
        IsMob = true
    },
    ["Elite Deathaxe Skeleton"] = {
        Name = "Elite Deathaxe Skeleton",
        Color = Color3.fromRGB(220, 20, 60),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 170, 0, 85),
        TextSize = 21,
        Priority = 3,
        HealthBar = true,
        IsMob = true
    },
    ["Elite Rogue Skeleton"] = {
        Name = "Elite Rogue Skeleton",
        Color = Color3.fromRGB(0, 191, 255),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 170, 0, 85),
        TextSize = 21,
        Priority = 4,
        HealthBar = true,
        IsMob = true
    },
    ["Deathaxe Skeleton"] = {
        Name = "Deathaxe Skeleton",
        Color = Color3.fromRGB(178, 34, 34),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 160, 0, 80),
        TextSize = 20,
        Priority = 5,
        HealthBar = true,
        IsMob = true
    },
    ["Axe Skeleton"] = {
        Name = "Axe Skeleton",
        Color = Color3.fromRGB(128, 128, 128),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 150, 0, 75),
        TextSize = 19,
        Priority = 6,
        HealthBar = true,
        IsMob = true
    },
    ["Skeleton Rogue"] = {
        Name = "Skeleton Rogue",
        Color = Color3.fromRGB(105, 105, 105),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 150, 0, 75),
        TextSize = 19,
        Priority = 7,
        HealthBar = true,
        IsMob = true
    },
    ["Brute Zombie"] = {
        Name = "Brute Zombie",
        Color = Color3.fromRGB(0, 100, 0),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 160, 0, 80),
        TextSize = 20,
        Priority = 8,
        HealthBar = true,
        IsMob = true
    },
    ["Elite Zombie"] = {
        Name = "Elite Zombie",
        Color = Color3.fromRGB(50, 205, 50),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 160, 0, 80),
        TextSize = 20,
        Priority = 9,
        HealthBar = true,
        IsMob = true
    },
    ["Delver Zombie"] = {
        Name = "Delver Zombie",
        Color = Color3.fromRGB(85, 107, 47),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 150, 0, 75),
        TextSize = 19,
        Priority = 10,
        HealthBar = true,
        IsMob = true
    },
    ["Miner Zombie"] = {
        Name = "Miner Zombie",
        Color = Color3.fromRGB(139, 69, 19),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 150, 0, 75),
        TextSize = 19,
        Priority = 11,
        HealthBar = true,
        IsMob = true
    },
    ["Zombie3"] = {
        Name = "Zombie3",
        Color = Color3.fromRGB(107, 142, 35),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 140, 0, 70),
        TextSize = 18,
        Priority = 12,
        HealthBar = true,
        IsMob = true
    },
    ["Zombie"] = {
        Name = "Zombie",
        Color = Color3.fromRGB(34, 139, 34),
        SizeOffset = Vector3.new(0, 4, 0),
        BillboardSize = UDim2.new(0, 140, 0, 70),
        TextSize = 18,
        Priority = 13,
        HealthBar = true,
        IsMob = true
    },
    ["Bomber"] = {
        Name = "Bomber",
        Color = Color3.fromRGB(255, 0, 0),
        SizeOffset = Vector3.new(0, 5, 0),
        BillboardSize = UDim2.new(0, 160, 0, 80),
        TextSize = 20,
        Priority = 14,
        HealthBar = true,
        IsMob = true
    },
    ["Blazing Slime"] = {
        Name = "Blazing Slime",
        Color = Color3.fromRGB(255, 140, 0),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 140, 0, 70),
        TextSize = 18,
        Priority = 15,
        HealthBar = true,
        IsMob = true
    },
    ["Slime"] = {
        Name = "Slime",
        Color = Color3.fromRGB(0, 255, 0),
        SizeOffset = Vector3.new(0, 3, 0),
        BillboardSize = UDim2.new(0, 130, 0, 65),
        TextSize = 17,
        Priority = 16,
        HealthBar = true,
        IsMob = true
    }
}

-- GUI STATE
local guiVisible = true
local toggleKeybind = "RightControl"
local WindUI, MainWindow

-- FLAGS STATE
local flags = {
    AutoHammerEnabled = true,
    SkipMeltEnabled = true,
    SkipPourEnabled = true,
    AutoInitialize = true,
    AutoAttackEnabled = true,
    AttackWhileMining = true
}

----------------------------------------------------------------
-- LOAD WINDUI LIBRARY - FIXED VERSION
----------------------------------------------------------------
local function loadUILibrary()
    local success, lib = pcall(function()
        -- Coba load dari raw.githubusercontent.com
        local url = "https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"
        local response = game:HttpGet(url, true)
        return loadstring(response)()
    end)
    
    if success then
        WindUI = lib
        print("[WINDUI] Library loaded successfully")
        return true
    else
        warn("[WINDUI] Failed to load WindUI Library")
        -- Coba alternatif
        local success2, lib2 = pcall(function()
            return loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/src/main.lua"))()
        end)
        
        if success2 then
            WindUI = lib2
            print("[WINDUI] Library loaded from alternative source")
            return true
        end
        return false
    end
end

----------------------------------------------------------------
-- INITIALIZE REMOTES
----------------------------------------------------------------
local function initializeRemotes()
    local Packages = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages")
    local success, result = pcall(function()
        Knit = require(Packages.Knit)
    end)
    
    if not success then
        print("[SYSTEM] Knit not found, trying alternative")
        -- Coba cara lain untuk menemukan remotes
        for _, remote in pairs(ReplicatedStorage:GetDescendants()) do
            if remote.Name == "ChangeSequence" and remote:IsA("RemoteFunction") then
                ForgeServiceRF = remote
            elseif remote.Name == "ToolActivated" and remote:IsA("RemoteFunction") then
                ToolServiceRF = remote
            end
        end
        return ForgeServiceRF ~= nil and ToolServiceRF ~= nil
    end
    
    local Services = Packages.Knit.Services
    if Services then
        local ForgeService = Services:FindFirstChild("ForgeService")
        local ToolService = Services:FindFirstChild("ToolService")
        
        if ForgeService then
            ForgeServiceRF = ForgeService.RF.ChangeSequence
        end
        if ToolService then
            ToolServiceRF = ToolService.RF.ToolActivated
        end
    end
    
    return ForgeServiceRF ~= nil and ToolServiceRF ~= nil
end

----------------------------------------------------------------
-- ==================== FORGE SKIPPER ========================
----------------------------------------------------------------

local function getHammerMinigameUI()
    local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
    local forgeUI = playerGui:WaitForChild("Forge", 5)
    if forgeUI then
        return forgeUI:WaitForChild("HammerMinigame", 3)
    end
    return nil
end

local function isMinigameVisible()
    hammerMinigameUI = getHammerMinigameUI()
    if hammerMinigameUI then
        return hammerMinigameUI.Visible
    end
    return false
end

local function isMinigameTimerComplete()
    if not hammerMinigameUI then
        hammerMinigameUI = getHammerMinigameUI()
    end
    
    if hammerMinigameUI then
        local timerBar = hammerMinigameUI:FindFirstChild("Timer")
        if timerBar then
            local bar = timerBar:FindFirstChild("Bar")
            if bar then
                return bar.Size.X.Scale >= 0.95
            end
        end
    end
    return false
end

local function debugLog(message)
    if debugMode then
        print("[DEBUG] " .. message)
    end
end

local function hammerLoop()
    debugLog("Hammer loop started")
    local hammerCount = 0
    local lastCheckTime = tick()
    
    while isHammerMinigameActive and autoHammerRunning and not stopRequested do
        local currentTime = tick()
        if currentTime - lastCheckTime > 0.5 then
            if not isMinigameVisible() or isMinigameTimerComplete() then
                debugLog("Minigame no longer active, stopping hammer")
                stopRequested = true
                break
            end
            lastCheckTime = currentTime
        end
        
        local baseDelay = HAMMER_COOLDOWN
        local randomVariation = math.random(-20, 30) / 100
        local totalDelay = math.max(0.3, baseDelay + randomVariation)
        
        debugLog("Waiting " .. string.format("%.2f", totalDelay) .. "s before next hit")
        
        local startWait = tick()
        while tick() - startWait < totalDelay do
            if not isHammerMinigameActive or not autoHammerRunning or stopRequested then
                debugLog("Breaking during wait")
                return
            end
            task.wait(0.05)
        end
        
        if not isHammerMinigameActive or not autoHammerRunning or stopRequested then
            debugLog("Breaking before send")
            return
        end
        
        local success, result = pcall(function()
            return ForgeServiceRF:InvokeServer(
                "Hammer",
                { 
                    ClientTime = workspace:GetServerTimeNow(),
                    RandomSeed = math.random(1, 1000)
                }
            )
        end)
        
        if success then
            hammerCount = hammerCount + 1
            lastHammerTime = tick()
            debugLog("Hammer hit #" .. hammerCount .. " sent successfully")
            
            if isMinigameTimerComplete() then
                debugLog("Timer completed after hit #" .. hammerCount)
                stopRequested = true
                break
            end
        else
            debugLog("Hammer hit failed: " .. tostring(result))
        end
    end
    
    debugLog("Hammer loop ended. Total hits: " .. hammerCount)
end

local function startAutoHammer()
    if autoHammerRunning then
        debugLog("Auto hammer already running")
        return
    end
    
    debugLog("Starting auto hammer system")
    autoHammerRunning = true
    stopRequested = false
    minigameCompleteFlag = false
    
    if hammerTask then
        task.cancel(hammerTask)
        hammerTask = nil
    end
    
    hammerTask = task.spawn(function()
        hammerLoop()
        
        autoHammerRunning = false
        hammerTask = nil
        debugLog("Auto hammer task cleaned up")
    end)
end

local function stopAutoHammer()
    debugLog("Stopping auto hammer requested")
    stopRequested = true
    autoHammerRunning = false
    isHammerMinigameActive = false
    minigameCompleteFlag = true
    
    if hammerTask then
        task.cancel(hammerTask)
        hammerTask = nil
    end
    
    debugLog("Auto hammer fully stopped")
end

local function hookMinigameModules()
    if not Knit then
        print("[FORGE SKIP] Knit not available")
        return false
    end
    
    local ForgeController = Knit.GetController("ForgeController")
    if not ForgeController or not ForgeController.Minigames then
        warn("[FORGE SKIP] Cannot find ForgeController minigames")
        return false
    end

    print("[FORGE SKIP] Found ForgeController with minigames")

    -- MELT
    if ForgeController.Minigames.MeltMinigame then
        originalMinigames.MeltStart = ForgeController.Minigames.MeltMinigame.Start

        ForgeController.Minigames.MeltMinigame.Start = function(self, data)
            print("[FORGE SKIP] Skipping Melt...")
            local t = workspace:GetServerTimeNow()
            task.wait(0.3)
            print("[FORGE SKIP] Melt skipped!")
            return t - 0.001
        end
    end

    -- POUR
    if ForgeController.Minigames.PourMinigame then
        originalMinigames.PourStart = ForgeController.Minigames.PourMinigame.Start

        ForgeController.Minigames.PourMinigame.Start = function(self, data)
            print("[FORGE SKIP] Skipping Pour...")
            local t = workspace:GetServerTimeNow()
            task.wait(0.3)
            print("[FORGE SKIP] Pour skipped!")
            return t - 0.001
        end
    end

    -- HAMMER
    if ForgeController.Minigames.HammerMinigame then
        local originalHammerStart = ForgeController.Minigames.HammerMinigame.Start
        local originalHammerStop = ForgeController.Minigames.HammerMinigame.Stop
        
        hammerMinigameUI = getHammerMinigameUI()
        
        ForgeController.Minigames.HammerMinigame.Start = function(self, ...)
            print("[FORGE HOOK] ===== HAMMER MINIGAME STARTED =====")
            
            isHammerMinigameActive = true
            autoHammerRunning = false
            stopRequested = false
            minigameCompleteFlag = false
            
            hammerMinigameUI = getHammerMinigameUI()
            
            if flags.AutoHammerEnabled then
                task.spawn(function()
                    task.wait(0.5)
                    if isMinigameVisible() then
                        print("[FORGE HOOK] UI detected, starting auto hammer...")
                        startAutoHammer()
                    end
                end)
            end
            
            if originalHammerStart then
                return originalHammerStart(self, ...)
            end
            return nil
        end

        ForgeController.Minigames.HammerMinigame.Stop = function(self, ...)
            print("[FORGE HOOK] ===== HAMMER MINIGAME STOPPED =====")
            
            stopAutoHammer()
            
            if originalHammerStop then
                return originalHammerStop(self, ...)
            end
            return nil
        end
        
        print("[FORGE HOOK] Hammer minigame hooks installed")
    end

    print("[FORGE SKIP] All minigames hooked successfully")
    return true
end

----------------------------------------------------------------
-- ====================== ESP SYSTEM =========================
----------------------------------------------------------------

-- FUNGSI UNTUK CEK APAKAH INI PLAYER
local function isPlayerModel(model)
    if not model or not model:IsA("Model") then
        return false
    end
    
    -- CEK 1: Apakah ini character milik player
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character == model then
            return true
        end
    end
    
    -- CEK 2: Apakah ini local player
    if model == LocalPlayer.Character then
        return true
    end
    
    -- CEK 3: Apakah model memiliki komponen khusus player
    local hasLeaderstats = model:FindFirstChild("leaderstats")
    local hasPlayerScripts = model:FindFirstChild("PlayerScripts")
    local hasPlayerGui = model:FindFirstChild("PlayerGui")
    local hasBackpack = model:FindFirstChild("Backpack")
    
    if hasLeaderstats or hasPlayerScripts or hasPlayerGui or hasBackpack then
        return true
    end
    
    -- CEK 4: Apakah nama model sama dengan nama player
    if PlayerBlacklist[model.Name] then
        return true
    end
    
    return false
end

local function createRockESP(obj, rockType)
    local config = RockConfigs[rockType]
    if not config then 
        config = {
            Name = rockType,
            Color = Color3.fromRGB(200, 200, 200),
            SizeOffset = Vector3.new(0, 3, 0),
            BillboardSize = UDim2.new(0, 100, 0, 50),
            TextSize = 18,
            Priority = 15
        }
    end
    
    if highlightedObjects[obj] then return end
    
    local BillboardGui = Instance.new('BillboardGui')
    local TextLabel = Instance.new('TextLabel')
    local DistanceLabel = Instance.new('TextLabel')
    
    BillboardGui.Name = "RockESP"
    BillboardGui.Parent = obj
    BillboardGui.AlwaysOnTop = true
    BillboardGui.Size = config.BillboardSize
    BillboardGui.StudsOffset = config.SizeOffset
    BillboardGui.MaxDistance = ESPDistance
    BillboardGui.Enabled = ESPEnabled
    
    TextLabel.Name = "TypeLabel"
    TextLabel.Parent = BillboardGui
    TextLabel.BackgroundTransparency = 1
    TextLabel.Size = UDim2.new(1, 0, 0.6, 0)
    TextLabel.Position = UDim2.new(0, 0, 0, 0)
    TextLabel.Text = config.Name
    TextLabel.TextColor3 = config.Color
    TextLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    TextLabel.TextStrokeTransparency = 0.5
    TextLabel.TextSize = config.TextSize
    TextLabel.Font = Enum.Font.SourceSansBold
    TextLabel.TextScaled = false
    
    DistanceLabel.Name = "DistanceLabel"
    DistanceLabel.Parent = BillboardGui
    DistanceLabel.BackgroundTransparency = 1
    DistanceLabel.Size = UDim2.new(1, 0, 0.4, 0)
    DistanceLabel.Position = UDim2.new(0, 0, 0.6, 0)
    DistanceLabel.Text = "0 studs"
    DistanceLabel.TextColor3 = Color3.new(1, 1, 1)
    DistanceLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    DistanceLabel.TextStrokeTransparency = 0.5
    DistanceLabel.TextSize = config.TextSize - 2
    DistanceLabel.Font = Enum.Font.SourceSans
    
    local highlight = Instance.new("BoxHandleAdornment")
    highlight.Name = "RockHighlight"
    highlight.Adornee = obj
    highlight.AlwaysOnTop = true
    highlight.ZIndex = 10
    highlight.Size = obj.Size + Vector3.new(1, 1, 1)
    highlight.Color3 = config.Color
    highlight.Transparency = 0.2
    highlight.Visible = ESPEnabled
    highlight.Parent = obj
    
    local pointLight = Instance.new("PointLight")
    pointLight.Name = "RockGlow"
    pointLight.Color = config.Color
    pointLight.Brightness = 2
    pointLight.Range = 20
    pointLight.Enabled = ESPEnabled
    pointLight.Shadows = false
    pointLight.Parent = obj
    
    highlightedObjects[obj] = {
        Billboard = BillboardGui,
        Highlight = highlight,
        Light = pointLight,
        Config = config,
        Type = rockType,
        ObjectType = "Rock",
        LastUpdate = tick()
    }
end

local function createMobESP(obj, mobType, model)
    -- CEK APAKAH INI PLAYER - JIKA YA, SKIP
    if isPlayerModel(model) then
        print("[MOB ESP] Skipping player model: " .. model.Name)
        return
    end
    
    local config = MobConfigs[mobType]
    if not config then 
        config = {
            Name = mobType,
            Color = Color3.fromRGB(255, 0, 0),
            SizeOffset = Vector3.new(0, 5, 0),
            BillboardSize = UDim2.new(0, 150, 0, 75),
            TextSize = 20,
            Priority = 20,
            HealthBar = false,
            IsMob = true
        }
    end
    
    if highlightedMobs[obj] then return end
    
    local BillboardGui = Instance.new('BillboardGui')
    local TextLabel = Instance.new('TextLabel')
    local DistanceLabel = Instance.new('TextLabel')
    local HealthBar = nil
    local HealthText = nil
    
    BillboardGui.Name = "MobESP"
    BillboardGui.Parent = obj
    BillboardGui.AlwaysOnTop = true
    BillboardGui.Size = config.BillboardSize
    BillboardGui.StudsOffset = config.SizeOffset
    BillboardGui.MaxDistance = MobESPDistance
    BillboardGui.Enabled = MobESPEnabled
    
    TextLabel.Name = "TypeLabel"
    TextLabel.Parent = BillboardGui
    TextLabel.BackgroundTransparency = 1
    TextLabel.Size = UDim2.new(1, 0, 0.4, 0)
    TextLabel.Position = UDim2.new(0, 0, 0, 0)
    TextLabel.Text = config.Name
    TextLabel.TextColor3 = config.Color
    TextLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    TextLabel.TextStrokeTransparency = 0.3
    TextLabel.TextSize = config.TextSize
    TextLabel.Font = Enum.Font.SourceSansBold
    TextLabel.TextScaled = false
    
    DistanceLabel.Name = "DistanceLabel"
    DistanceLabel.Parent = BillboardGui
    DistanceLabel.BackgroundTransparency = 1
    DistanceLabel.Size = UDim2.new(1, 0, 0.3, 0)
    DistanceLabel.Position = UDim2.new(0, 0, 0.4, 0)
    DistanceLabel.Text = "0 studs"
    DistanceLabel.TextColor3 = Color3.new(1, 1, 1)
    DistanceLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    DistanceLabel.TextStrokeTransparency = 0.5
    DistanceLabel.TextSize = config.TextSize - 2
    DistanceLabel.Font = Enum.Font.SourceSans
    
    -- Health Bar
    if config.HealthBar then
        local healthBarFrame = Instance.new("Frame")
        healthBarFrame.Name = "HealthBarFrame"
        healthBarFrame.Size = UDim2.new(0.8, 0, 0.2, 0)
        healthBarFrame.Position = UDim2.new(0.1, 0, 0.7, 0)
        healthBarFrame.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
        healthBarFrame.BorderSizePixel = 1
        healthBarFrame.BorderColor3 = Color3.new(0, 0, 0)
        healthBarFrame.Parent = BillboardGui
        
        local healthBar = Instance.new("Frame")
        healthBar.Name = "HealthBar"
        healthBar.Size = UDim2.new(1, 0, 1, 0)
        healthBar.Position = UDim2.new(0, 0, 0, 0)
        healthBar.BackgroundColor3 = Color3.new(0, 1, 0)
        healthBar.BorderSizePixel = 0
        healthBar.Parent = healthBarFrame
        
        HealthText = Instance.new("TextLabel")
        HealthText.Name = "HealthText"
        HealthText.Size = UDim2.new(1, 0, 0.1, 0)
        HealthText.Position = UDim2.new(0, 0, 0.9, 0)
        HealthText.BackgroundTransparency = 1
        HealthText.Text = "100%"
        HealthText.TextColor3 = Color3.new(1, 1, 1)
        HealthText.TextStrokeTransparency = 0.5
        HealthText.TextSize = config.TextSize - 4
        HealthText.Font = Enum.Font.SourceSansBold
        HealthText.Parent = BillboardGui
        
        HealthBar = healthBar
    end
    
    local highlight = Instance.new("BoxHandleAdornment")
    highlight.Name = "MobHighlight"
    highlight.Adornee = obj
    highlight.AlwaysOnTop = true
    highlight.ZIndex = 10
    highlight.Size = obj.Size + Vector3.new(1, 1, 1)
    highlight.Color3 = config.Color
    highlight.Transparency = 0.3
    highlight.Visible = MobESPEnabled
    highlight.Parent = obj
    
    local pointLight = Instance.new("PointLight")
    pointLight.Name = "MobGlow"
    pointLight.Color = config.Color
    pointLight.Brightness = 3
    pointLight.Range = 25
    pointLight.Enabled = MobESPEnabled
    pointLight.Shadows = false
    pointLight.Parent = obj
    
    highlightedMobs[obj] = {
        Billboard = BillboardGui,
        Highlight = highlight,
        Light = pointLight,
        HealthBar = HealthBar,
        HealthText = HealthText,
        Config = config,
        Type = mobType,
        Model = model,
        ObjectType = "Mob",
        LastUpdate = tick()
    }
end

local function updateRockESP(obj, espData)
    if not obj or not obj.Parent then
        return false
    end
    
    local character = LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    if not humanoidRootPart then return true end
    
    local distance = (obj.Position - humanoidRootPart.Position).Magnitude
    
    if espData.Billboard and espData.Billboard:FindFirstChild("DistanceLabel") then
        espData.Billboard.DistanceLabel.Text = string.format("%.0f studs", distance)
        
        -- Update color based on distance
        if distance < 50 then
            espData.Billboard.TypeLabel.TextColor3 = Color3.new(0, 1, 0)
        elseif distance < 100 then
            espData.Billboard.TypeLabel.TextColor3 = Color3.new(1, 1, 0)
        else
            espData.Billboard.TypeLabel.TextColor3 = espData.Config.Color
        end
        
        if espData.Highlight then
            espData.Highlight.Color3 = espData.Billboard.TypeLabel.TextColor3
        end
        
        if espData.Light then
            espData.Light.Brightness = math.clamp(30 / distance, 1, 3)
        end
        
        -- Filter by selected rock type
        local shouldShow = distance <= ESPDistance
        if SelectedRockType ~= "Any" and SelectedRockType ~= espData.Type then
            shouldShow = false
        end
        
        espData.Billboard.Enabled = ESPEnabled and shouldShow
        espData.Highlight.Visible = ESPEnabled and shouldShow
        espData.Light.Enabled = ESPEnabled and shouldShow
    end
    
    espData.LastUpdate = tick()
    return true
end

local function updateMobESP(obj, espData)
    if not obj or not obj.Parent then
        return false
    end
    
    -- CEK APAKAH INI PLAYER - JIKA YA, HAPUS
    if isPlayerModel(espData.Model) then
        print("[MOB ESP] Removing ESP from player: " .. espData.Model.Name)
        return false
    end
    
    local character = LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    if not humanoidRootPart then return true end
    
    local distance = (obj.Position - humanoidRootPart.Position).Magnitude
    
    if espData.Billboard and espData.Billboard:FindFirstChild("DistanceLabel") then
        espData.Billboard.DistanceLabel.Text = string.format("%.0f studs", distance)
        
        -- Update color based on distance and priority
        if distance < 30 then
            espData.Billboard.TypeLabel.TextColor3 = Color3.new(1, 0, 0)  -- Red when very close
        elseif distance < 100 then
            espData.Billboard.TypeLabel.TextColor3 = Color3.new(1, 0.5, 0) -- Orange when close
        else
            espData.Billboard.TypeLabel.TextColor3 = espData.Config.Color
        end
        
        -- Update health bar if exists
        if espData.HealthBar and espData.Model then
            local humanoid = espData.Model:FindFirstChildWhichIsA("Humanoid")
            if humanoid then
                local healthPercent = humanoid.Health / humanoid.MaxHealth
                espData.HealthBar.Size = UDim2.new(healthPercent, 0, 1, 0)
                
                -- Health bar color based on health
                if healthPercent > 0.6 then
                    espData.HealthBar.BackgroundColor3 = Color3.new(0, 1, 0)
                elseif healthPercent > 0.3 then
                    espData.HealthBar.BackgroundColor3 = Color3.new(1, 1, 0)
                else
                    espData.HealthBar.BackgroundColor3 = Color3.new(1, 0, 0)
                end
                
                if espData.HealthText then
                    espData.HealthText.Text = string.format("%.0f%%", healthPercent * 100)
                end
            end
        end
        
        if espData.Highlight then
            espData.Highlight.Color3 = espData.Billboard.TypeLabel.TextColor3
        end
        
        if espData.Light then
            espData.Light.Brightness = math.clamp(40 / distance, 2, 5)
        end
        
        -- Filter by selected mob type
        local shouldShow = distance <= MobESPDistance
        if SelectedMobType ~= "Any" and SelectedMobType ~= espData.Type then
            shouldShow = false
        end
        
        espData.Billboard.Enabled = MobESPEnabled and shouldShow
        espData.Highlight.Visible = MobESPEnabled and shouldShow
        espData.Light.Enabled = MobESPEnabled and shouldShow
        
        if espData.HealthBar and espData.HealthBar.Parent then
            espData.HealthBar.Parent.Visible = MobESPEnabled and shouldShow
        end
        if espData.HealthText then
            espData.HealthText.Visible = MobESPEnabled and shouldShow
        end
    end
    
    espData.LastUpdate = tick()
    return true
end

local function scanForRocks()
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj:IsA("Model") then
            local rockType = obj.Name
            -- Check if it's a known rock type
            if RockConfigs[rockType] then
                -- Find the main part of the rock
                local mainPart = obj:FindFirstChild("MainPart") or 
                                obj:FindFirstChild("Part") or 
                                obj:FindFirstChild("Handle") or
                                obj:FindFirstChildWhichIsA("BasePart")
                
                if mainPart then
                    if not highlightedObjects[mainPart] then
                        createRockESP(mainPart, rockType)
                    end
                end
            end
        end
    end
end

-- FUNGSI UNTUK SCAN MOB (TANPA PLAYER)
local function scanForMobs()
    -- Mencari folder Living di Workspace
    local livingFolder = Workspace:FindFirstChild("Living")
    
    if livingFolder then
        -- Scan semua model di dalam folder Living
        for _, mobModel in pairs(livingFolder:GetChildren()) do
            if mobModel:IsA("Model") then
                -- CEK APAKAH INI PLAYER - JIKA YA, SKIP
                if isPlayerModel(mobModel) then
                    continue
                end
                
                local mobType = mobModel.Name
                
                -- Check if it's a known mob type
                if MobConfigs[mobType] then
                    -- Find the humanoid root part or main part
                    local humanoidRootPart = mobModel:FindFirstChild("HumanoidRootPart")
                    local torso = mobModel:FindFirstChild("Torso") or mobModel:FindFirstChild("UpperTorso")
                    local head = mobModel:FindFirstChild("Head")
                    
                    local targetPart = humanoidRootPart or torso or head
                    
                    if targetPart then
                        if not highlightedMobs[targetPart] then
                            createMobESP(targetPart, mobType, mobModel)
                        end
                    end
                else
                    -- Jika mob tidak dikenal tapi punya humanoid, buat ESP default
                    local humanoid = mobModel:FindFirstChildWhichIsA("Humanoid")
                    if humanoid and not isPlayerModel(mobModel) then
                        local humanoidRootPart = mobModel:FindFirstChild("HumanoidRootPart")
                        local torso = mobModel:FindFirstChild("Torso") or mobModel:FindFirstChild("UpperTorso")
                        local head = mobModel:FindFirstChild("Head")
                        
                        local targetPart = humanoidRootPart or torso or head
                        
                        if targetPart and not highlightedMobs[targetPart] then
                            createMobESP(targetPart, mobType, mobModel)
                        end
                    end
                end
            end
        end
    else
        -- Jika tidak ada folder Living, coba scan semua model di Workspace yang mungkin mob
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj:IsA("Model") then
                -- CEK APAKAH INI PLAYER - JIKA YA, SKIP
                if isPlayerModel(obj) then
                    continue
                end
                
                local mobType = obj.Name
                
                -- Check if it's a known mob type
                if MobConfigs[mobType] then
                    -- Find the humanoid root part or main part
                    local humanoidRootPart = obj:FindFirstChild("HumanoidRootPart")
                    local torso = obj:FindFirstChild("Torso") or obj:FindFirstChild("UpperTorso")
                    local head = obj:FindFirstChild("Head")
                    
                    local targetPart = humanoidRootPart or torso or head
                    
                    if targetPart then
                        if not highlightedMobs[targetPart] then
                            createMobESP(targetPart, mobType, obj)
                        end
                    end
                end
            end
        end
    end
end

local function autoESPUpdate()
    while true do
        -- Scan for new rocks and mobs every 3 seconds
        scanForRocks()
        scanForMobs()
        
        -- Update existing rock ESP
        for obj, espData in pairs(highlightedObjects) do
            if not updateRockESP(obj, espData) then
                -- Clean up if object no longer exists
                if espData.Billboard then espData.Billboard:Destroy() end
                if espData.Highlight then espData.Highlight:Destroy() end
                if espData.Light then espData.Light:Destroy() end
                highlightedObjects[obj] = nil
            end
        end
        
        -- Update existing mob ESP
        for obj, espData in pairs(highlightedMobs) do
            -- CEK APAKAH INI PLAYER SEBELUM UPDATE
            if isPlayerModel(espData.Model) then
                -- HAPUS ESP UNTUK PLAYER
                if espData.Billboard then espData.Billboard:Destroy() end
                if espData.Highlight then espData.Highlight:Destroy() end
                if espData.Light then espData.Light:Destroy() end
                if espData.HealthBar then espData.HealthBar.Parent:Destroy() end
                if espData.HealthText then espData.HealthText:Destroy() end
                highlightedMobs[obj] = nil
            elseif not updateMobESP(obj, espData) then
                -- Clean up if object no longer exists
                if espData.Billboard then espData.Billboard:Destroy() end
                if espData.Highlight then espData.Highlight:Destroy() end
                if espData.Light then espData.Light:Destroy() end
                if espData.HealthBar then espData.HealthBar.Parent:Destroy() end
                if espData.HealthText then espData.HealthText:Destroy() end
                highlightedMobs[obj] = nil
            end
        end
        
        task.wait(3)
    end
end

local function cleanupESP()
    -- Cleanup rock ESP
    for obj, espData in pairs(highlightedObjects) do
        if espData.Billboard then espData.Billboard:Destroy() end
        if espData.Highlight then espData.Highlight:Destroy() end
        if espData.Light then espData.Light:Destroy() end
    end
    highlightedObjects = {}
    
    -- Cleanup mob ESP
    for obj, espData in pairs(highlightedMobs) do
        if espData.Billboard then espData.Billboard:Destroy() end
        if espData.Highlight then espData.Highlight:Destroy() end
        if espData.Light then espData.Light:Destroy() end
        if espData.HealthBar then espData.HealthBar.Parent:Destroy() end
        if espData.HealthText then espData.HealthText:Destroy() end
    end
    highlightedMobs = {}
end

local function toggleRockESP()
    ESPEnabled = not ESPEnabled
    
    for obj, espData in pairs(highlightedObjects) do
        if espData.Billboard then
            espData.Billboard.Enabled = ESPEnabled
        end
        if espData.Highlight then
            espData.Highlight.Visible = ESPEnabled
        end
        if espData.Light then
            espData.Light.Enabled = ESPEnabled
        end
    end
    
    return ESPEnabled
end

local function toggleMobESP()
    MobESPEnabled = not MobESPEnabled
    
    for obj, espData in pairs(highlightedMobs) do
        if espData.Billboard then
            espData.Billboard.Enabled = MobESPEnabled
        end
        if espData.Highlight then
            espData.Highlight.Visible = MobESPEnabled
        end
        if espData.Light then
            espData.Light.Enabled = MobESPEnabled
        end
        if espData.HealthBar and espData.HealthBar.Parent then
            espData.HealthBar.Parent.Visible = MobESPEnabled
        end
        if espData.HealthText then
            espData.HealthText.Visible = MobESPEnabled
        end
    end
    
    return MobESPEnabled
end

local function setESPDistance(distance)
    ESPDistance = math.clamp(distance, 10, 2000)
end

local function setMobESPDistance(distance)
    MobESPDistance = math.clamp(distance, 10, 1000)
end

local function setRockType(rockType)
    SelectedRockType = rockType
end

local function setMobType(mobType)
    SelectedMobType = mobType
end

-- Function to get all available rock types
local function getAllRockTypes()
    local rockTypes = {}
    for rockName, _ in pairs(RockConfigs) do
        table.insert(rockTypes, rockName)
    end
    table.sort(rockTypes)
    return rockTypes
end

-- Function to get all available mob types (HANYA MOB, TIDAK PLAYER)
local function getAllMobTypes()
    local mobTypes = {}
    for mobName, config in pairs(MobConfigs) do
        if config.IsMob then
            table.insert(mobTypes, mobName)
        end
    end
    table.sort(mobTypes)
    return mobTypes
end

local function getRocksCountByType()
    local counts = {}
    
    for rockName, _ in pairs(RockConfigs) do
        counts[rockName] = 0
    end
    counts["Other"] = 0
    counts["Total"] = 0
    
    for obj, espData in pairs(highlightedObjects) do
        if espData.Type then
            if RockConfigs[espData.Type] then
                counts[espData.Type] = (counts[espData.Type] or 0) + 1
            else
                counts["Other"] = counts["Other"] + 1
            end
            counts.Total = counts.Total + 1
        end
    end
    
    return counts
end

local function getMobsCountByType()
    local counts = {}
    
    for mobName, config in pairs(MobConfigs) do
        if config.IsMob then
            counts[mobName] = 0
        end
    end
    counts["Other"] = 0
    counts["Total"] = 0
    
    for obj, espData in pairs(highlightedMobs) do
        if espData.Type then
            -- SKIP PLAYER
            if isPlayerModel(espData.Model) then
                continue
            end
            
            if MobConfigs[espData.Type] and MobConfigs[espData.Type].IsMob then
                counts[espData.Type] = (counts[espData.Type] or 0) + 1
            else
                counts["Other"] = counts["Other"] + 1
            end
            counts.Total = counts.Total + 1
        end
    end
    
    return counts
end

----------------------------------------------------------------
-- ==================== NOCLIP FUNCTIONS ======================
----------------------------------------------------------------

-- FUNGSI UNTUK ENABLE NOCLIP
local function enableNoclip()
    if not NOCLIP_ENABLED then 
        print("[NOCLIP] Noclip disabled in settings")
        return 
    end
    
    local character = LocalPlayer.Character
    if not character then 
        print("[NOCLIP] No character found")
        return 
    end
    
    local success = pcall(function()
        -- Set semua bagian menjadi tidak bisa tabrakan
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
        
        -- Tambahkan BodyVelocity untuk kontrol yang lebih baik
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            -- Hapus BodyVelocity lama jika ada
            local oldVelocity = humanoidRootPart:FindFirstChild("NoclipVelocity")
            if oldVelocity then
                oldVelocity:Destroy()
            end
            
            -- Buat BodyVelocity baru
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.Name = "NoclipVelocity"
            bodyVelocity.MaxForce = Vector3.new(40000, 40000, 40000)
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            bodyVelocity.Parent = humanoidRootPart
        end
        
        print("[NOCLIP] Noclip enabled successfully")
    end)
    
    if not success then
        print("[NOCLIP] Failed to enable noclip")
    end
end

-- FUNGSI UNTUK DISABLE NOCLIP
local function disableNoclip()
    local character = LocalPlayer.Character
    if not character then 
        print("[NOCLIP] No character found")
        return 
    end
    
    local success = pcall(function()
        -- Set semua bagian menjadi bisa tabrakan
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
        
        -- Hapus BodyVelocity
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            local bodyVelocity = humanoidRootPart:FindFirstChild("NoclipVelocity")
            if bodyVelocity then
                bodyVelocity:Destroy()
            end
        end
        
        print("[NOCLIP] Noclip disabled successfully")
    end)
    
    if not success then
        print("[NOCLIP] Failed to disable noclip")
    end
end

-- FUNGSI UNTUK MENGUPDATE NOCLIP SETIAP FRAME SAAT MINING/ATTACKING
local function updateNoclipDuringAction()
    if (AutoMineEnabled and IsMining) or (flags.AutoAttackEnabled and IsAttacking) then
        if NOCLIP_ENABLED then
            enableNoclip()
        end
    end
end

----------------------------------------------------------------
-- ==================== AUTO ATTACK SYSTEM ====================
----------------------------------------------------------------

local function callAttackRemotes()
    local success1, result1 = pcall(function()
        local args = {"Weapon"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    task.wait(0.1)
    
    local success2, result2 = pcall(function()
        local args = {"Weapon"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    return success1 and success2
end

local function getMobsData()
    local mobs = {}
    local character = LocalPlayer.Character
    
    if not character then return mobs end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return mobs end
    
    for obj, espData in pairs(highlightedMobs) do
        if obj and obj.Parent and espData.Type then
            -- SKIP PLAYER - Pastikan bukan player
            if isPlayerModel(espData.Model) then
                continue
            end
            
            -- Check if mob is alive
            local isAlive = true
            if espData.Model then
                local humanoid = espData.Model:FindFirstChildWhichIsA("Humanoid")
                if humanoid and humanoid.Health <= 0 then
                    isAlive = false
                end
            end
            
            if isAlive then
                -- Filter by selected mob type
                if SelectedMobType == "Any" or SelectedMobType == espData.Type then
                    local distance = (obj.Position - humanoidRootPart.Position).Magnitude
                    
                    if distance <= ATTACK_SEARCH_RADIUS then
                        table.insert(mobs, {
                            Type = espData.Type,
                            Position = obj.Position,
                            Distance = distance,
                            Object = obj,
                            Model = espData.Model,
                            Config = espData.Config,
                            Priority = espData.Config.Priority or 20
                        })
                    end
                end
            end
        end
    end
    
    -- Sort by priority first, then distance
    table.sort(mobs, function(a, b)
        if a.Priority ~= b.Priority then
            return a.Priority < b.Priority
        end
        return a.Distance < b.Distance
    end)
    
    return mobs
end

local function findNearestMob()
    local mobs = getMobsData()
    if #mobs == 0 then return nil end
    return mobs[1]
end

local function findPriorityMobs()
    local mobs = getMobsData()
    local priorityMobs = {}
    
    for _, mob in ipairs(mobs) do
        if PriorityMobs[mob.Type] then
            table.insert(priorityMobs, mob)
        end
    end
    
    table.sort(priorityMobs, function(a, b)
        if a.Priority ~= b.Priority then
            return a.Priority < b.Priority
        end
        return a.Distance < b.Distance
    end)
    
    return priorityMobs
end

local function tweenToTargetAndAttack(targetData, isMob)
    if not targetData or not targetData.Position then 
        print("[TWEEEN] No target data")
        return false 
    end
    
    local character = LocalPlayer.Character
    if not character then 
        print("[TWEEEN] No character")
        return false 
    end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then 
        print("[TWEEEN] No HumanoidRootPart")
        return false 
    end
    
    -- CEK APAKAH INI PLAYER - JIKA YA, BATALKAN
    if isMob and isPlayerModel(targetData.Model) then
        print("[TWEEEN] Cannot attack player: " .. targetData.Model.Name)
        return false
    end
    
    if isMob then
        CurrentAttackTarget = targetData
    else
        CurrentMineTarget = targetData
    end
    
    -- Enable noclip sebelum mulai bergerak
    enableNoclip()
    
    local targetPosition
    if isMob then
        targetPosition = targetData.Position + Vector3.new(0, 5, 0)
    else
        targetPosition = targetData.Position + Vector3.new(0, FLY_HEIGHT, 0)
    end
    
    local distance = (humanoidRootPart.Position - targetPosition).Magnitude
    local speed = isMob and ATTACK_SPEED or MINING_SPEED
    local duration = math.max(0.5, distance / speed)
    
    print(string.format("[TWEEEN] Moving to %s at %.0f studs/sec (%.1f seconds)", 
        targetData.Type, speed, duration))
    
    local tweenInfo = TweenInfo.new(
        duration,
        Enum.EasingStyle.Linear,
        Enum.EasingDirection.Out
    )
    
    local tween = TweenService:Create(humanoidRootPart, tweenInfo, {
        CFrame = CFrame.new(targetPosition)
    })
    
    tween:Play()
    
    local completed = false
    local connection = tween.Completed:Connect(function()
        completed = true
    end)
    
    -- Selama tween berjalan, update noclip
    local startTime = tick()
    while not completed and tick() - startTime < duration + 2 do
        task.wait(0.1)
        enableNoclip() -- Pastikan noclip tetap aktif
    end
    
    connection:Disconnect()
    
    if completed then
        print("[TWEEEN] Arrived at target")
        local actionStartTime = tick()
        local actionCount = 0
        
        local maxTime = isMob and 10 or 15
        local actionDelay = isMob and ATTACK_DELAY or MINE_DELAY
        
        while (isMob and IsAttacking) or (not isMob and AutoMineEnabled and IsMining) and tick() - actionStartTime < maxTime do
            if not targetData.Object or not targetData.Object.Parent then
                print("[TWEEEN] Target disappeared")
                break
            end
            
            -- CEK APAKAH INI PLAYER SEBELUM MENYERANG
            if isMob and isPlayerModel(targetData.Model) then
                print("[TWEEEN] Target is player, stopping")
                break
            end
            
            if isMob and targetData.Model then
                local humanoid = targetData.Model:FindFirstChildWhichIsA("Humanoid")
                if humanoid and humanoid.Health <= 0 then
                    print("[TWEEEN] Target defeated")
                    break
                end
            end
            
            local success
            if isMob then
                success = callAttackRemotes()
            else
                success = callMiningRemotes()
            end
            
            actionCount = actionCount + 1
            
            if success then
                print(string.format("[TWEEEN] Action #%d successful", actionCount))
            else
                print("[TWEEEN] Remote call failed")
            end
            
            -- Update noclip selama aksi
            enableNoclip()
            task.wait(actionDelay)
        end
        
        print(string.format("[TWEEEN] Finished - %d cycles", actionCount))
    else
        print("[TWEEEN] Tween failed or timed out")
    end
    
    if isMob then
        IsAttacking = false
        CurrentAttackTarget = nil
    else
        IsMining = false
        CurrentMineTarget = nil
    end
    
    return true
end

local function attackPriorityMobs()
    if IsAttacking then return end
    
    local priorityMobs = findPriorityMobs()
    
    if #priorityMobs > 0 then
        IsAttacking = true
        task.spawn(function()
            for _, mob in ipairs(priorityMobs) do
                if not IsAttacking then break end
                
                print(string.format("[AUTO ATTACK] Attacking priority mob %s (%.0f studs away)", 
                    mob.Type, mob.Distance))
                
                local success = tweenToTargetAndAttack(mob, true)
                
                if success then
                    print("[AUTO ATTACK] Finished attacking " .. mob.Type)
                    task.wait(ATTACK_COOLDOWN)
                else
                    print("[AUTO ATTACK] Attack failed on " .. mob.Type)
                    task.wait(2)
                end
            end
            IsAttacking = false
        end)
        return true
    end
    
    return false
end

local function startAutoAttackLoop()
    if AttackConnection then
        AttackConnection:Disconnect()
        AttackConnection = nil
    end
    
    AttackConnection = RunService.Heartbeat:Connect(function()
        if not flags.AutoAttackEnabled then return end
        if IsAttacking then return end
        
        if not LocalPlayer.Character then
            return
        end
        
        if isHammerMinigameActive then
            return
        end
        
        if flags.AttackWhileMining then
            local priorityMobs = findPriorityMobs()
            if #priorityMobs > 0 then
                print("[AUTO ATTACK] Priority mobs detected, attacking first")
                attackPriorityMobs()
                return
            end
        end
        
        local nearestMob = findNearestMob()
        
        if nearestMob then
            -- CEK APAKAH INI PLAYER SEBELUM MENYERANG
            if isPlayerModel(nearestMob.Model) then
                print("[AUTO ATTACK] Skipping player target: " .. nearestMob.Model.Name)
                return
            end
            
            IsAttacking = true
            task.spawn(function()
                print(string.format("[AUTO ATTACK] Starting attack on %s (%.0f studs away)", 
                    nearestMob.Type, nearestMob.Distance))
                
                local success = tweenToTargetAndAttack(nearestMob, true)
                IsAttacking = false
                
                if success then
                    print("[AUTO ATTACK] Moving to next mob in " .. ATTACK_COOLDOWN .. " seconds")
                    task.wait(ATTACK_COOLDOWN)
                else
                    print("[AUTO ATTACK] Attack failed, waiting before retry")
                    task.wait(2)
                end
            end)
        end
    end)
end

local function toggleAutoAttack()
    flags.AutoAttackEnabled = not flags.AutoAttackEnabled
    
    if flags.AutoAttackEnabled then
        print("[AUTO ATTACK] Auto attack system ENABLED")
        startAutoAttackLoop()
    else
        print("[AUTO ATTACK] Auto attack system DISABLED")
        if AttackConnection then
            AttackConnection:Disconnect()
            AttackConnection = nil
        end
        IsAttacking = false
        CurrentAttackTarget = nil
        disableNoclip()
    end
    
    return flags.AutoAttackEnabled
end

local function setAttackCooldown(seconds)
    ATTACK_COOLDOWN = math.max(0.5, seconds)
    print("[AUTO ATTACK] Attack cooldown set to: " .. ATTACK_COOLDOWN .. " seconds")
end

local function setAttackSpeed(speed)
    ATTACK_SPEED = math.max(10, math.min(500, speed))
    print("[AUTO ATTACK] Attack speed set to: " .. ATTACK_SPEED .. " studs/sec")
end

local function setAttackSearchRadius(radius)
    ATTACK_SEARCH_RADIUS = math.max(10, math.min(1000, radius))
    print("[AUTO ATTACK] Attack search radius set to: " .. ATTACK_SEARCH_RADIUS .. " studs")
end

local function setAttackDelay(delay)
    ATTACK_DELAY = math.max(0.1, math.min(2, delay))
    print("[AUTO ATTACK] Attack delay set to: " .. ATTACK_DELAY .. " seconds")
end

local function forceAttackNearest()
    if IsAttacking then
        print("[AUTO ATTACK] Already attacking, please wait")
        return false
    end
    
    local nearestMob = findNearestMob()
    
    if nearestMob then
        -- CEK APAKAH INI PLAYER
        if isPlayerModel(nearestMob.Model) then
            print("[AUTO ATTACK] Cannot attack player: " .. nearestMob.Model.Name)
            return false
        end
        
        print(string.format("[AUTO ATTACK] Force attacking %s (%.0f studs away)", 
            nearestMob.Type, nearestMob.Distance))
        
        IsAttacking = true
        task.spawn(function()
            local success = tweenToTargetAndAttack(nearestMob, true)
            IsAttacking = false
            return success
        end)
        return true
    else
        print("[AUTO ATTACK] No mobs found to attack")
        return false
    end
end

----------------------------------------------------------------
-- ==================== AUTO MINE SYSTEM =====================
----------------------------------------------------------------

local function getRocksData()
    local rocks = {}
    local character = LocalPlayer.Character
    
    if not character then return rocks end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return rocks end
    
    for obj, espData in pairs(highlightedObjects) do
        if obj and obj.Parent and espData.Type then
            if SelectedRockType == "Any" or SelectedRockType == espData.Type then
                local distance = (obj.Position - humanoidRootPart.Position).Magnitude
                
                if distance <= MINING_SEARCH_RADIUS then
                    table.insert(rocks, {
                        Type = espData.Type,
                        Position = obj.Position,
                        Distance = distance,
                        Object = obj,
                        Config = espData.Config,
                        Priority = espData.Config.Priority or 15
                    })
                end
            end
        end
    end
    
    table.sort(rocks, function(a, b)
        if a.Priority ~= b.Priority then
            return a.Priority < b.Priority
        end
        return a.Distance < b.Distance
    end)
    
    return rocks
end

local function findNearestRock()
    local rocks = getRocksData()
    if #rocks == 0 then return nil end
    return rocks[1]
end

local function callMiningRemotes()
    local success1, result1 = pcall(function()
        local args = {"Weapon"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    task.wait(0.1)
    
    local success2, result2 = pcall(function()
        local args = {"Pickaxe"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    task.wait(0.1)
    
    local success3, result3 = pcall(function()
        local args = {"Weapon"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    task.wait(0.1)
    
    local success4, result4 = pcall(function()
        local args = {"Pickaxe"}
        return ToolServiceRF:InvokeServer(unpack(args))
    end)
    
    return success1 and success2 and success3 and success4
end

local function tweenToRockAndMine(rockData)
    return tweenToTargetAndAttack(rockData, false)
end

local function startAutoMineLoop()
    if MineConnection then
        MineConnection:Disconnect()
        MineConnection = nil
    end
    
    MineConnection = RunService.Heartbeat:Connect(function()
        if not AutoMineEnabled then return end
        if IsMining or IsAttacking then return end
        
        if not LocalPlayer.Character then
            return
        end
        
        if isHammerMinigameActive then
            return
        end
        
        if flags.AttackWhileMining then
            local priorityMobs = findPriorityMobs()
            if #priorityMobs > 0 then
                print("[AUTO MINE] Priority mobs detected, attacking first")
                attackPriorityMobs()
                return
            end
        end
        
        local nearestRock = findNearestRock()
        
        if nearestRock then
            IsMining = true
            task.spawn(function()
                print(string.format("[AUTO MINE] Starting mining on %s (%.0f studs away)", 
                    nearestRock.Type, nearestRock.Distance))
                
                local success = tweenToRockAndMine(nearestRock)
                IsMining = false
                
                if success then
                    print("[AUTO MINE] Moving to next rock in " .. MINING_COOLDOWN .. " seconds")
                    task.wait(MINING_COOLDOWN)
                else
                    print("[AUTO MINE] Mining failed, waiting before retry")
                    task.wait(2)
                end
            end)
        end
    end)
end

local function toggleAutoMine()
    AutoMineEnabled = not AutoMineEnabled
    
    if AutoMineEnabled then
        print("[AUTO MINE] Auto mining system ENABLED")
        -- Enable noclip saat mulai mining
        if NOCLIP_ENABLED then
            enableNoclip()
        end
        startAutoMineLoop()
    else
        print("[AUTO MINE] Auto mining system DISABLED")
        if MineConnection then
            MineConnection:Disconnect()
            MineConnection = nil
        end
        IsMining = false
        CurrentMineTarget = nil
        -- Disable noclip saat berhenti mining
        disableNoclip()
    end
    
    return AutoMineEnabled
end

local function toggleNoclip()
    NOCLIP_ENABLED = not NOCLIP_ENABLED
    
    if NOCLIP_ENABLED then
        enableNoclip()
    else
        disableNoclip()
    end
    
    print("[AUTO MINE] Noclip: " .. (NOCLIP_ENABLED and "ENABLED" or "DISABLED"))
    return NOCLIP_ENABLED
end

local function setMiningCooldown(seconds)
    MINING_COOLDOWN = math.max(0.5, seconds)
    print("[AUTO MINE] Mining cooldown set to: " .. MINING_COOLDOWN .. " seconds")
end

local function setMiningSpeed(speed)
    MINING_SPEED = math.max(10, math.min(500, speed))
    print("[AUTO MINE] Mining speed set to: " .. MINING_SPEED .. " studs/sec")
end

local function setSearchRadius(radius)
    MINING_SEARCH_RADIUS = math.max(10, math.min(5000, radius))
    print("[AUTO MINE] Search radius set to: " .. MINING_SEARCH_RADIUS .. " studs")
end

local function setFlyHeight(height)
    FLY_HEIGHT = math.max(0, math.min(100, height))
    print("[AUTO MINE] Fly height set to: " .. FLY_HEIGHT .. " studs")
end

local function setMineDelay(delay)
    MINE_DELAY = math.max(0.1, math.min(2, delay))
    print("[AUTO MINE] Mining delay set to: " .. MINE_DELAY .. " seconds")
end

local function forceMineNearest()
    if IsMining then
        print("[AUTO MINE] Already mining, please wait")
        return false
    end
    
    local nearestRock = findNearestRock()
    
    if nearestRock then
        print(string.format("[AUTO MINE] Force mining %s (%.0f studs away)", 
            nearestRock.Type, nearestRock.Distance))
        
        IsMining = true
        task.spawn(function()
            local success = tweenToRockAndMine(nearestRock)
            IsMining = false
            return success
        end)
        return true
    else
        print("[AUTO MINE] No rocks found to mine")
        return false
    end
end

----------------------------------------------------------------
-- ====================== WINDUI GUI ========================
----------------------------------------------------------------

local function toggleGUI()
    if not MainWindow then 
        print("[GUI] MainWindow not created yet")
        return 
    end
    
    if guiVisible then
        MainWindow:Close()
        if MainWindow.OpenButtonMain then
            MainWindow.OpenButtonMain:Visible(true)
        end
        guiVisible = false
        print("[GUI] GUI hidden")
    else
        MainWindow:Open()
        if MainWindow.OpenButtonMain then
            MainWindow.OpenButtonMain:Visible(false)
        end
        guiVisible = true
        print("[GUI] GUI shown")
    end
end

local function createMainWindow()
    if not loadUILibrary() then
        print("[GUI] Failed to load WindUI Library")
        -- Buat GUI sederhana sebagai fallback
        local function createFallbackGUI()
            local ScreenGui = Instance.new("ScreenGui")
            ScreenGui.Name = "JawirScriptGUI"
            ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
            
            local Frame = Instance.new("Frame")
            Frame.Size = UDim2.new(0, 300, 0, 400)
            Frame.Position = UDim2.new(0.5, -150, 0.5, -200)
            Frame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            Frame.BorderSizePixel = 0
            Frame.Active = true
            Frame.Draggable = true
            Frame.Parent = ScreenGui
            
            local Title = Instance.new("TextLabel")
            Title.Size = UDim2.new(1, 0, 0, 40)
            Title.Position = UDim2.new(0, 0, 0, 0)
            Title.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
            Title.Text = "JawirScript - Fallback GUI"
            Title.TextColor3 = Color3.fromRGB(255, 255, 255)
            Title.Font = Enum.Font.SourceSansBold
            Title.TextSize = 18
            Title.Parent = Frame
            
            local CloseButton = Instance.new("TextButton")
            CloseButton.Size = UDim2.new(0, 30, 0, 30)
            CloseButton.Position = UDim2.new(1, -35, 0, 5)
            CloseButton.Text = "X"
            CloseButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
            CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            CloseButton.Font = Enum.Font.SourceSansBold
            CloseButton.TextSize = 18
            CloseButton.Parent = Frame
            CloseButton.MouseButton1Click:Connect(function()
                ScreenGui:Destroy()
            end)
            
            local ScrollFrame = Instance.new("ScrollingFrame")
            ScrollFrame.Size = UDim2.new(1, -10, 1, -50)
            ScrollFrame.Position = UDim2.new(0, 5, 0, 45)
            ScrollFrame.BackgroundTransparency = 1
            ScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 800)
            ScrollFrame.ScrollBarThickness = 5
            ScrollFrame.Parent = Frame
            
            local UIListLayout = Instance.new("UIListLayout")
            UIListLayout.Padding = UDim.new(0, 5)
            UIListLayout.Parent = ScrollFrame
            
            -- Tambahkan beberapa tombol
            local buttons = {
                {"Toggle Auto Mine", toggleAutoMine},
                {"Toggle Auto Attack", toggleAutoAttack},
                {"Toggle Rock ESP", toggleRockESP},
                {"Toggle Mob ESP", toggleMobESP},
                {"Force Mine Nearest", forceMineNearest},
                {"Force Attack Nearest", forceAttackNearest}
            }
            
            for i, buttonData in ipairs(buttons) do
                local button = Instance.new("TextButton")
                button.Size = UDim2.new(1, -10, 0, 40)
                button.Position = UDim2.new(0, 5, 0, (i-1)*45)
                button.Text = buttonData[1]
                button.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
                button.TextColor3 = Color3.fromRGB(255, 255, 255)
                button.Font = Enum.Font.SourceSans
                button.TextSize = 16
                button.Parent = ScrollFrame
                button.MouseButton1Click:Connect(buttonData[2])
            end
            
            print("[GUI] Fallback GUI created")
            return {Open = function() Frame.Visible = true end, Close = function() Frame.Visible = false end}
        end
        
        MainWindow = createFallbackGUI()
        return MainWindow
    end
    
    print("[GUI] Creating WindUI Window...")
    
    local success, window = pcall(function()
        return WindUI:CreateWindow({
            Title = "JawirScript - The Forge",
            Folder = "JawirScriptForgeSystem",
            Theme = "Dark",
            Size = UDim2.new(0, 600, 0, 750),
            Radius = 12,
            Resizable = true,
            Acrylic = true,
            Background = Color3.fromRGB(30, 30, 35),
            Author = "Auto Forge + Auto Mine + Auto Attack System",
            ToggleKey = Enum.KeyCode.RightControl,
            OpenButton = {
                Title = "Jawir Script",
                Icon = "hammer",
                Enabled = true,
                Position = UDim2.new(0.5, -75, 0, 15),
                OnlyIcon = false,
                Draggable = true,
                Color = ColorSequence.new(
                    Color3.fromHex("#FF6B6B"),
                    Color3.fromHex("#4ECDC4")
                )
            }
        })
    end)
    
    if not success then
        print("[GUI] Failed to create WindUI window: " .. tostring(window))
        return nil
    end
    
    MainWindow = window
    print("[GUI] WindUI Window created successfully")
    
    MainWindow:OnOpen(function()
        print("[GUI] Window opened")
        if MainWindow.OpenButtonMain then
            MainWindow.OpenButtonMain:Visible(false)
        end
        guiVisible = true
    end)
    
    MainWindow:OnClose(function()
        print("[GUI] Window closed")
        if MainWindow.OpenButtonMain then
            MainWindow.OpenButtonMain:Visible(true)
        end
        guiVisible = false
    end)
    
    -- Tab 1: Forge System
    local ForgeTab = MainWindow:Tab({
        Title = " Forge",
        Desc = "Auto Forge Skipper"
    })
    
    ForgeTab:Paragraph({
        Title = " Auto Forge System",
        Desc = "Automatically skip melt, pour, and hammer minigames"
    })
    
    ForgeTab:Button({
        Title = " Activate Hooks",
        Desc = "Activate minigame hooks",
        Callback = function()
            local success = hookMinigameModules()
            if success then
                task.wait(0.5)
                WindUI:Notify({
                    Title = "Hooks Activated",
                    Content = "Auto forge system activated successfully!",
                    Icon = "check-circle",
                    Duration = 3
                })
            else
                WindUI:Notify({
                    Title = "Hooks Failed",
                    Content = "Failed to activate hooks",
                    Icon = "x-circle",
                    Duration = 3
                })
            end
        end
    })
    
    ForgeTab:Divider()
    
    ForgeTab:Toggle({
        Title = " Auto Hammer",
        Desc = "Auto hammer during minigame",
        Value = true,
        Callback = function(value)
            flags.AutoHammerEnabled = value
            WindUI:Notify({
                Title = "Auto Hammer",
                Content = value and "ENABLED" or "DISABLED",
                Icon = value and "hammer" or "hammer-off",
                Duration = 2
            })
        end
    })
    
    ForgeTab:Toggle({
        Title = " Skip Melt",
        Desc = "Skip melt minigame",
        Value = true,
        Callback = function(value)
            flags.SkipMeltEnabled = value
            WindUI:Notify({
                Title = "Skip Melt",
                Content = value and "ENABLED" or "DISABLED",
                Icon = value and "fire" or "fire-off",
                Duration = 2
            })
        end
    })
    
    ForgeTab:Toggle({
        Title = " Skip Pour",
        Desc = "Skip pour minigame",
        Value = true,
        Callback = function(value)
            flags.SkipPourEnabled = value
            WindUI:Notify({
                Title = "Skip Pour",
                Content = value and "ENABLED" or "DISABLED",
                Icon = value and "droplet" or "droplet-off",
                Duration = 2
            })
        end
    })
    
    ForgeTab:Slider({
        Title = " Hammer Speed",
        Desc = "Delay between hammer hits",
        Value = {Default = HAMMER_COOLDOWN, Min = 0.1, Max = 1.0, Step = 0.1},
        Callback = function(value)
            HAMMER_COOLDOWN = value
            WindUI:Notify({
                Title = "Hammer Speed",
                Content = "Set to: " .. string.format("%.1f", value) .. "s",
                Icon = "gauge",
                Duration = 2
            })
        end
    })
    
    ForgeTab:Button({
        Title = " Stop Hammer",
        Desc = "Stop auto hammer immediately",
        Callback = function()
            stopAutoHammer()
            WindUI:Notify({
                Title = "Hammer Stopped",
                Content = "Auto hammer stopped",
                Icon = "stop-circle",
                Duration = 1.5
            })
        end
    })
    
    -- Tab 2: Auto Mine System
    local MineTab = MainWindow:Tab({
        Title = " Auto Mine",
        Desc = "Auto Mine System - Mines rocks with Weapon & Pickaxe"
    })
    
    MineTab:Paragraph({
        Title = " Auto Mine System",
        Desc = "Automatically mine rocks - Tween to rock and call Weapon & Pickaxe remotes"
    })
    
    MineTab:Toggle({
        Title = " Enable Auto Mine",
        Desc = "Toggle auto mining system",
        Value = AutoMineEnabled,
        Callback = function(value)
            AutoMineEnabled = toggleAutoMine()
            WindUI:Notify({
                Title = "Auto Mine",
                Content = AutoMineEnabled and "ENABLED - Mining with Weapon & Pickaxe" or "DISABLED",
                Icon = AutoMineEnabled and "mining" or "mining-off",
                Duration = 3
            })
        end
    })
    
    MineTab:Paragraph({
        Title = " Mining Tools",
        Desc = "System will call both Weapon and Pickaxe remotes simultaneously"
    })
    
    MineTab:Toggle({
        Title = " Enable Noclip",
        Desc = "Enable noclip while mining",
        Value = NOCLIP_ENABLED,
        Callback = function(value)
            NOCLIP_ENABLED = toggleNoclip()
            WindUI:Notify({
                Title = "Noclip",
                Content = NOCLIP_ENABLED and "ENABLED" or "DISABLED",
                Icon = NOCLIP_ENABLED and "ghost" or "ghost-off",
                Duration = 2
            })
        end
    })
    
    MineTab:Toggle({
        Title = " Attack While Mining",
        Desc = "Auto attack priority mobs while mining",
        Value = flags.AttackWhileMining,
        Callback = function(value)
            flags.AttackWhileMining = value
            WindUI:Notify({
                Title = "Attack While Mining",
                Content = value and "ENABLED - Will attack Blight Pyromancer first" or "DISABLED",
                Icon = value and "swords" or "swords-off",
                Duration = 3
            })
        end
    })
    
    -- Get all rock types for dropdown
    local allRockTypes = getAllRockTypes()
    table.insert(allRockTypes, 1, "Any")
    
    MineTab:Dropdown({
        Title = " Target Rock Type",
        Desc = "Select which rock type to mine",
        Value = SelectedRockType,
        Values = allRockTypes,
        Callback = function(value)
            setRockType(value)
            WindUI:Notify({
                Title = "Target Type",
                Content = "Set to: " .. value,
                Icon = "target",
                Duration = 2
            })
        end
    })
    
    MineTab:Slider({
        Title = " Mining Cooldown",
        Desc = "Time between mining different rocks",
        Value = {Default = MINING_COOLDOWN, Min = 0.5, Max = 30, Step = 0.5},
        Callback = function(value)
            setMiningCooldown(value)
            WindUI:Notify({
                Title = "Mining Cooldown",
                Content = "Set to: " .. value .. " seconds",
                Icon = "clock",
                Duration = 2
            })
        end
    })
    
    MineTab:Slider({
        Title = " Tween Speed",
        Desc = "Speed of movement between rocks",
        Value = {Default = MINING_SPEED, Min = 10, Max = 500, Step = 10},
        Callback = function(value)
            setMiningSpeed(value)
            WindUI:Notify({
                Title = "Tween Speed",
                Content = "Set to: " .. value .. " studs/sec",
                Icon = "zap",
                Duration = 2
            })
        end
    })
    
    MineTab:Slider({
        Title = " Search Radius",
        Desc = "Maximum distance to search for rocks",
        Value = {Default = MINING_SEARCH_RADIUS, Min = 10, Max = 5000, Step = 50},
        Callback = function(value)
            setSearchRadius(value)
            WindUI:Notify({
                Title = "Search Radius",
                Content = "Set to: " .. value .. " studs",
                Icon = "ruler",
                Duration = 2
            })
        end
    })
    
    MineTab:Slider({
        Title = " Fly Height",
        Desc = "Height above rock to fly to",
        Value = {Default = FLY_HEIGHT, Min = 0, Max = 100, Step = 1},
        Callback = function(value)
            setFlyHeight(value)
            WindUI:Notify({
                Title = "Fly Height",
                Content = "Set to: " .. value .. " studs",
                Icon = "arrow-up",
                Duration = 2
            })
        end
    })
    
    MineTab:Slider({
        Title = " Mining Delay",
        Desc = "Delay between mining remote calls",
        Value = {Default = MINE_DELAY, Min = 0.1, Max = 2, Step = 0.1},
        Callback = function(value)
            setMineDelay(value)
            WindUI:Notify({
                Title = "Mining Delay",
                Content = "Set to: " .. value .. " seconds",
                Icon = "timer",
                Duration = 2
            })
        end
    })
    
    MineTab:Divider()
    
    MineTab:Button({
        Title = " Mine Nearest Rock",
        Desc = "Immediately mine nearest rock",
        Callback = function()
            local counts = getRocksCountByType()
            if counts.Total == 0 then
                WindUI:Notify({
                    Title = "No Rocks Found",
                    Content = "ESP is auto-scanning, wait a few seconds",
                    Icon = "x-circle",
                    Duration = 2
                })
                return
            end
            
            local nearestRock = findNearestRock()
            if nearestRock then
                WindUI:Notify({
                    Title = "Mining " .. nearestRock.Type,
                    Content = string.format("Distance: %.0f studs", nearestRock.Distance),
                    Icon = "mining",
                    Duration = 2
                })
                
                local success = forceMineNearest()
                if not success then
                    WindUI:Notify({
                        Title = "Mining Failed",
                        Content = "Could not start mining",
                        Icon = "x-circle",
                        Duration = 2
                    })
                end
            else
                WindUI:Notify({
                    Title = "No Rocks Found",
                    Content = "No rocks of selected type found",
                    Icon = "x-circle",
                    Duration = 2
                })
            end
        end
    })
    
    MineTab:Button({
        Title = " Stop Mining",
        Desc = "Stop current mining",
        Callback = function()
            IsMining = false
            CurrentMineTarget = nil
            disableNoclip()
            WindUI:Notify({
                Title = "Mining Stopped",
                Content = "Current mining stopped",
                Icon = "stop-circle",
                Duration = 1.5
            })
        end
    })
    
    -- Tab 3: Auto Attack System
    local AttackTab = MainWindow:Tab({
        Title = " Auto Attack",
        Desc = "Auto Attack System - Attack mobs automatically"
    })
    
    AttackTab:Paragraph({
        Title = " Auto Attack System",
        Desc = "Automatically attack mobs - Tween to mob and attack"
    })
    
    AttackTab:Toggle({
        Title = " Enable Auto Attack",
        Desc = "Toggle auto attack system",
        Value = flags.AutoAttackEnabled,
        Callback = function(value)
            flags.AutoAttackEnabled = toggleAutoAttack()
            WindUI:Notify({
                Title = "Auto Attack",
                Content = flags.AutoAttackEnabled and "ENABLED" or "DISABLED",
                Icon = flags.AutoAttackEnabled and "swords" or "swords-off",
                Duration = 2
            })
        end
    })
    
    AttackTab:Toggle({
        Title = " Priority: Blight Pyromancer",
        Desc = "Always attack Blight Pyromancer first",
        Value = true,
        Callback = function(value)
            PriorityMobs["Blight Pyromancer"] = value
            WindUI:Notify({
                Title = "Priority Attack",
                Content = value and "Blight Pyromancer will be attacked first" or "Blight Pyromancer priority removed",
                Icon = value and "skull" or "skull-off",
                Duration = 2
            })
        end
    })
    
    -- Get all mob types for dropdown
    local allMobTypes = getAllMobTypes()
    table.insert(allMobTypes, 1, "Any")
    
    AttackTab:Dropdown({
        Title = " Target Mob Type",
        Desc = "Select which mob type to attack",
        Value = SelectedMobType,
        Values = allMobTypes,
        Callback = function(value)
            setMobType(value)
            WindUI:Notify({
                Title = "Target Mob",
                Content = "Set to: " .. value,
                Icon = "target",
                Duration = 2
            })
        end
    })
    
    AttackTab:Slider({
        Title = " Attack Cooldown",
        Desc = "Time between attacking different mobs",
        Value = {Default = ATTACK_COOLDOWN, Min = 0.5, Max = 30, Step = 0.5},
        Callback = function(value)
            setAttackCooldown(value)
            WindUI:Notify({
                Title = "Attack Cooldown",
                Content = "Set to: " .. value .. " seconds",
                Icon = "clock",
                Duration = 2
            })
        end
    })
    
    AttackTab:Slider({
        Title = " Attack Speed",
        Desc = "Speed of movement between mobs",
        Value = {Default = ATTACK_SPEED, Min = 10, Max = 500, Step = 10},
        Callback = function(value)
            setAttackSpeed(value)
            WindUI:Notify({
                Title = "Attack Speed",
                Content = "Set to: " .. value .. " studs/sec",
                Icon = "zap",
                Duration = 2
            })
        end
    })
    
    AttackTab:Slider({
        Title = " Attack Radius",
        Desc = "Maximum distance to search for mobs",
        Value = {Default = ATTACK_SEARCH_RADIUS, Min = 10, Max = 1000, Step = 10},
        Callback = function(value)
            setAttackSearchRadius(value)
            WindUI:Notify({
                Title = "Attack Radius",
                Content = "Set to: " .. value .. " studs",
                Icon = "ruler",
                Duration = 2
            })
        end
    })
    
    AttackTab:Slider({
        Title = " Attack Delay",
        Desc = "Delay between attack remote calls",
        Value = {Default = ATTACK_DELAY, Min = 0.1, Max = 2, Step = 0.1},
        Callback = function(value)
            setAttackDelay(value)
            WindUI:Notify({
                Title = "Attack Delay",
                Content = "Set to: " .. value .. " seconds",
                Icon = "timer",
                Duration = 2
            })
        end
    })
    
    AttackTab:Divider()
    
    AttackTab:Button({
        Title = " Attack Nearest Mob",
        Desc = "Immediately attack nearest mob",
        Callback = function()
            local counts = getMobsCountByType()
            if counts.Total == 0 then
                WindUI:Notify({
                    Title = "No Mobs Found",
                    Content = "ESP is auto-scanning, wait a few seconds",
                    Icon = "x-circle",
                    Duration = 2
                })
                return
            end
            
            local nearestMob = findNearestMob()
            if nearestMob then
                WindUI:Notify({
                    Title = "Attacking " .. nearestMob.Type,
                    Content = string.format("Distance: %.0f studs", nearestMob.Distance),
                    Icon = "swords",
                    Duration = 2
                })
                
                local success = forceAttackNearest()
                if not success then
                    WindUI:Notify({
                        Title = "Attack Failed",
                        Content = "Could not start attack",
                        Icon = "x-circle",
                        Duration = 2
                    })
                end
            else
                WindUI:Notify({
                    Title = "No Mobs Found",
                    Content = "No mobs of selected type found",
                    Icon = "x-circle",
                    Duration = 2
                })
            end
        end
    })
    
    AttackTab:Button({
        Title = " Attack Blight Pyromancer",
        Desc = "Force attack Blight Pyromancer if available",
        Callback = function()
            local priorityMobs = findPriorityMobs()
            local blightPyromancer = nil
            
            for _, mob in ipairs(priorityMobs) do
                if mob.Type == "Blight Pyromancer" then
                    blightPyromancer = mob
                    break
                end
            end
            
            if blightPyromancer then
                WindUI:Notify({
                    Title = "Attacking Blight Pyromancer",
                    Content = string.format("Distance: %.0f studs", blightPyromancer.Distance),
                    Icon = "skull",
                    Duration = 2
                })
                
                IsAttacking = true
                task.spawn(function()
                    local success = tweenToTargetAndAttack(blightPyromancer, true)
                    IsAttacking = false
                    if not success then
                        WindUI:Notify({
                            Title = "Attack Failed",
                            Content = "Could not attack Blight Pyromancer",
                            Icon = "x-circle",
                            Duration = 2
                        })
                    end
                end)
            else
                WindUI:Notify({
                    Title = "Not Found",
                    Content = "Blight Pyromancer not found in range",
                    Icon = "search",
                    Duration = 2
                })
            end
        end
    })
    
    AttackTab:Button({
        Title = " Stop Attack",
        Desc = "Stop current attack",
        Callback = function()
            IsAttacking = false
            CurrentAttackTarget = nil
            WindUI:Notify({
                Title = "Attack Stopped",
                Content = "Current attack stopped",
                Icon = "stop-circle",
                Duration = 1.5
            })
        end
    })
    
    -- Tab 4: ESP Settings
    local ESPTab = MainWindow:Tab({
        Title = " ESP",
        Desc = "Rock & Mob ESP Settings"
    })
    
    ESPTab:Paragraph({
        Title = " ESP System",
        Desc = "Auto-detect and highlight nearby rocks and mobs"
    })
    
    ESPTab:Toggle({
        Title = " Rock ESP",
        Desc = "Toggle rock ESP visibility",
        Value = ESPEnabled,
        Callback = function(value)
            ESPEnabled = toggleRockESP()
            WindUI:Notify({
                Title = "Rock ESP",
                Content = ESPEnabled and "ENABLED" or "DISABLED",
                Icon = ESPEnabled and "eye" or "eye-off",
                Duration = 2
            })
        end
    })
    
    ESPTab:Toggle({
        Title = " Mob ESP",
        Desc = "Toggle mob ESP visibility",
        Value = MobESPEnabled,
        Callback = function(value)
            MobESPEnabled = toggleMobESP()
            WindUI:Notify({
                Title = "Mob ESP",
                Content = MobESPEnabled and "ENABLED" or "DISABLED",
                Icon = MobESPEnabled and "eye" or "eye-off",
                Duration = 2
            })
        end
    })
    
    ESPTab:Slider({
        Title = " Rock ESP Distance",
        Desc = "Maximum rock ESP render distance",
        Value = {Default = ESPDistance, Min = 10, Max = 2000, Step = 10},
        Callback = function(value)
            setESPDistance(value)
            WindUI:Notify({
                Title = "Rock ESP Distance",
                Content = "Set to: " .. value .. " studs",
                Icon = "ruler",
                Duration = 2
            })
        end
    })
    
    ESPTab:Slider({
        Title = " Mob ESP Distance",
        Desc = "Maximum mob ESP render distance",
        Value = {Default = MobESPDistance, Min = 10, Max = 1000, Step = 10},
        Callback = function(value)
            setMobESPDistance(value)
            WindUI:Notify({
                Title = "Mob ESP Distance",
                Content = "Set to: " .. value .. " studs",
                Icon = "ruler",
                Duration = 2
            })
        end
    })
    
    ESPTab:Button({
        Title = " Detailed Status",
        Desc = "Show current rock & mob detection status",
        Callback = function()
            local rockCounts = getRocksCountByType()
            local mobCounts = getMobsCountByType()
            local nearestRock = findNearestRock()
            local nearestMob = findNearestMob()
            local priorityMobs = findPriorityMobs()
            
            local statusText = "=== ESP DETECTION STATUS ===\n\n"
            
            statusText = statusText .. " ROCKS DETECTED:\n"
            statusText = statusText .. "   Total Rocks: " .. rockCounts.Total .. "\n"
            
            if nearestRock then
                statusText = statusText .. "   Nearest Rock: " .. nearestRock.Type .. "\n"
                statusText = statusText .. "   Distance: " .. string.format("%.0f", nearestRock.Distance) .. " studs\n"
            else
                statusText = statusText .. "   Nearest Rock: None\n"
            end
            
            statusText = statusText .. "\n MOBS DETECTED:\n"
            statusText = statusText .. "   Total Mobs: " .. mobCounts.Total .. "\n"
            
            if nearestMob then
                statusText = statusText .. "   Nearest Mob: " .. nearestMob.Type .. "\n"
                statusText = statusText .. "   Distance: " .. string.format("%.0f", nearestMob.Distance) .. " studs\n"
            else
                statusText = statusText .. "   Nearest Mob: None\n"
            end
            
            if #priorityMobs > 0 then
                statusText = statusText .. "\n PRIORITY MOBS:\n"
                for i, mob in ipairs(priorityMobs) do
                    if i <= 3 then
                        statusText = statusText .. string.format("   %d. %s (%.0f studs)\n", i, mob.Type, mob.Distance)
                    end
                end
            end
            
            statusText = statusText .. "\n TARGET SETTINGS:\n"
            statusText = statusText .. "   Rock Type: " .. SelectedRockType .. "\n"
            statusText = statusText .. "   Mob Type: " .. SelectedMobType .. "\n"
            statusText = statusText .. "   Rock ESP Distance: " .. ESPDistance .. " studs\n"
            statusText = statusText .. "   Mob ESP Distance: " .. MobESPDistance .. " studs\n"
            statusText = statusText .. "   Attack While Mining: " .. (flags.AttackWhileMining and "ON" or "OFF") .. "\n"
            
            WindUI:Dialog({
                Title = "ESP Detection Status",
                Content = statusText,
                Icon = "info",
                Buttons = {
                    {
                        Title = "OK",
                        Callback = function() end
                    }
                }
            })
        end
    })
    
    ESPTab:Button({
        Title = " Clear All ESP",
        Desc = "Remove all ESP highlights",
        Callback = function()
            cleanupESP()
            WindUI:Notify({
                Title = "ESP Cleared",
                Content = "All ESP objects removed",
                Icon = "broom",
                Duration = 2
            })
        end
    })
    
    -- Tab 5: Settings
    local SettingsTab = MainWindow:Tab({
        Title = " Settings",
        Desc = "System Settings"
    })
    
    SettingsTab:Paragraph({
        Title = " System Settings",
        Desc = "Configure system behavior"
    })
    
    SettingsTab:Keybind({
        Title = " GUI Toggle Key",
        Desc = "Key to toggle GUI visibility",
        Value = "RightControl",
        Callback = function(key)
            toggleKeybind = key
            WindUI:Notify({
                Title = "Keybind Updated",
                Content = "Press " .. key .. " to toggle GUI",
                Icon = "keyboard",
                Duration = 3
            })
        end
    })
    
    SettingsTab:Toggle({
        Title = " Debug Mode",
        Desc = "Enable debug logging",
        Value = debugMode,
        Callback = function(value)
            debugMode = value
            WindUI:Notify({
                Title = "Debug Mode",
                Content = value and "ENABLED" or "DISABLED",
                Icon = value and "bug" or "bug-off",
                Duration = 2
            })
        end
    })
    
    SettingsTab:Button({
        Title = " System Status",
        Desc = "Display current system status",
        Callback = function()
            local rockCounts = getRocksCountByType()
            local mobCounts = getMobsCountByType()
            local nearestRock = findNearestRock()
            local nearestMob = findNearestMob()
            local priorityMobs = findPriorityMobs()
            
            local statusText = "=== JAWIRSCRIPT SYSTEM STATUS ===\n\n"
            
            statusText = statusText .. " FORGE SYSTEM:\n"
            statusText = statusText .. "   Auto Hammer: " .. tostring(flags.AutoHammerEnabled) .. "\n"
            statusText = statusText .. "   Skip Melt: " .. tostring(flags.SkipMeltEnabled) .. "\n"
            statusText = statusText .. "   Skip Pour: " .. tostring(flags.SkipPourEnabled) .. "\n"
            statusText = statusText .. "   Hooks Active: " .. (originalMinigames.MeltStart and "YES" or "NO") .. "\n\n"
            
            statusText = statusText .. " AUTO MINE SYSTEM:\n"
            statusText = statusText .. "   Enabled: " .. tostring(AutoMineEnabled) .. "\n"
            statusText = statusText .. "   Is Mining: " .. tostring(IsMining) .. "\n"
            statusText = statusText .. "   Target Rock Type: " .. SelectedRockType .. "\n"
            statusText = statusText .. "   Speed: " .. MINING_SPEED .. " studs/sec\n"
            statusText = statusText .. "   Search Radius: " .. MINING_SEARCH_RADIUS .. " studs\n"
            statusText = statusText .. "   Attack While Mining: " .. (flags.AttackWhileMining and "ON" or "OFF") .. "\n\n"
            
            statusText = statusText .. " AUTO ATTACK SYSTEM:\n"
            statusText = statusText .. "   Enabled: " .. tostring(flags.AutoAttackEnabled) .. "\n"
            statusText = statusText .. "   Is Attacking: " .. tostring(IsAttacking) .. "\n"
            statusText = statusText .. "   Target Mob Type: " .. SelectedMobType .. "\n"
            statusText = statusText .. "   Speed: " .. ATTACK_SPEED .. " studs/sec\n"
            statusText = statusText .. "   Search Radius: " .. ATTACK_SEARCH_RADIUS .. " studs\n\n"
            
            statusText = statusText .. " ESP SYSTEM:\n"
            statusText = statusText .. "   Rock ESP: " .. (ESPEnabled and "ON" or "OFF") .. "\n"
            statusText = statusText .. "   Mob ESP: " .. (MobESPEnabled and "ON" or "OFF") .. "\n"
            statusText = statusText .. "   Rocks Detected: " .. rockCounts.Total .. "\n"
            statusText = statusText .. "   Mobs Detected: " .. mobCounts.Total .. "\n"
            statusText = statusText .. "   Priority Mobs: " .. #priorityMobs .. "\n\n"
            
            if nearestRock then
                statusText = statusText .. " NEAREST ROCK:\n"
                statusText = statusText .. "   Type: " .. nearestRock.Type .. "\n"
                statusText = statusText .. "   Distance: " .. string.format("%.0f", nearestRock.Distance) .. " studs\n"
            end
            
            if nearestMob then
                statusText = statusText .. " NEAREST MOB:\n"
                statusText = statusText .. "   Type: " .. nearestMob.Type .. "\n"
                statusText = statusText .. "   Distance: " .. string.format("%.0f", nearestMob.Distance) .. " studs\n"
            end
            
            if #priorityMobs > 0 then
                statusText = statusText .. "\n TOP PRIORITY MOBS:\n"
                for i = 1, math.min(3, #priorityMobs) do
                    local mob = priorityMobs[i]
                    statusText = statusText .. string.format("   %d. %s (%.0f studs)\n", i, mob.Type, mob.Distance)
                end
            end
            
            statusText = statusText .. "\n CONTROLS:\n"
            statusText = statusText .. "   GUI Visible: " .. tostring(guiVisible) .. "\n"
            statusText = statusText .. "   Toggle Key: " .. toggleKeybind .. "\n"
            statusText = statusText .. "   Tip: Auto mining will attack Blight Pyromancer first!"
            
            WindUI:Dialog({
                Title = "System Status",
                Content = statusText,
                Icon = "info",
                Buttons = {
                    {
                        Title = "OK",
                        Callback = function() end
                    }
                }
            })
        end
    })
    
    SettingsTab:Button({
        Title = " Emergency Stop",
        Desc = "Stop all auto systems immediately",
        Callback = function()
            WindUI:Notify({
                Title = "Emergency Stop",
                Content = "Stopping all systems...",
                Icon = "alert-octagon",
                Duration = 2
            })
            stopAutoHammer()
            AutoMineEnabled = false
            flags.AutoAttackEnabled = false
            
            if MineConnection then
                MineConnection:Disconnect()
                MineConnection = nil
            end
            
            if AttackConnection then
                AttackConnection:Disconnect()
                AttackConnection = nil
            end
            
            IsMining = false
            IsAttacking = false
            CurrentMineTarget = nil
            CurrentAttackTarget = nil
            disableNoclip()
        end
    })
    
    SettingsTab:Button({
        Title = " Cleanup All",
        Desc = "Clean up all system resources",
        Callback = function()
            WindUI:Notify({
                Title = "Cleanup",
                Content = "Cleaning up all systems...",
                Icon = "broom",
                Duration = 2
            })
            stopAutoHammer()
            cleanupESP()
            
            if MineConnection then
                MineConnection:Disconnect()
                MineConnection = nil
            end
            
            if AttackConnection then
                AttackConnection:Disconnect()
                AttackConnection = nil
            end
            
            disableNoclip()
        end
    })
    
    print("[GUI] All tabs created successfully")
    return MainWindow
end

----------------------------------------------------------------
-- ===================== INITIALIZATION ======================
----------------------------------------------------------------

local function setupEventListeners()
    -- GUI keybind listener
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed then
            if input.KeyCode == Enum.KeyCode[toggleKeybind] then
                toggleGUI()
            end
        end
    end)
    
    -- Character added listener untuk noclip
    LocalPlayer.CharacterAdded:Connect(function(character)
        task.wait(1)
        print("[SYSTEM] Character spawned, checking noclip status...")
        
        if (AutoMineEnabled or IsAttacking) and NOCLIP_ENABLED then
            print("[SYSTEM] Enabling noclip for new character")
            task.wait(0.5)
            enableNoclip()
        end
    end)
    
    -- Heartbeat connection untuk update noclip
    RunService.Heartbeat:Connect(function()
        updateNoclipDuringAction()
    end)
    
    -- Update player blacklist
    for _, player in pairs(Players:GetPlayers()) do
        PlayerBlacklist[player.Name] = true
        print("[BLACKLIST] Added player to blacklist: " .. player.Name)
    end
    
    Players.PlayerAdded:Connect(function(player)
        PlayerBlacklist[player.Name] = true
        print("[BLACKLIST] Added player to blacklist: " .. player.Name)
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        PlayerBlacklist[player.Name] = nil
        print("[BLACKLIST] Removed player from blacklist: " .. player.Name)
    end)
end

local function startESPScanning()
    -- Start auto ESP scanning
    if ESPConnection then
        task.cancel(ESPConnection)
        ESPConnection = nil
    end
    
    ESPConnection = task.spawn(autoESPUpdate)
    print("[ESP] Auto scanning started")
end

local function initializeSystem()
    print("========================================")
    print("JAWIRSCRIPT AUTO FORGE & MINE SYSTEM")
    print("========================================")
    print("Features: Forge Skip + Auto Mine + Auto Attack")
    print("ESP: Hanya deteksi MOB (TIDAK deteksi PLAYER)")
    print("GUI: Press RightControl to toggle")
    print("========================================")
    
    -- Initialize player blacklist
    for _, player in pairs(Players:GetPlayers()) do
        PlayerBlacklist[player.Name] = true
    end
    
    local remoteSuccess = initializeRemotes()
    if not remoteSuccess then
        warn("[SYSTEM] Remote initialization failed, continuing without remotes")
    else
        print("[SYSTEM] Remotes initialized successfully")
    end
    
    -- Create GUI
    local guiSuccess = pcall(createMainWindow)
    if not guiSuccess then
        print("[SYSTEM] Failed to create GUI, creating fallback")
        -- Coba buat fallback GUI
        pcall(function()
            local ScreenGui = Instance.new("ScreenGui")
            ScreenGui.Name = "JawirScriptFallback"
            ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
            
            local TextLabel = Instance.new("TextLabel")
            TextLabel.Size = UDim2.new(0, 200, 0, 50)
            TextLabel.Position = UDim2.new(0, 10, 0, 10)
            TextLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            TextLabel.BackgroundTransparency = 0.5
            TextLabel.Text = "JawirScript Loaded\nPress RightControl"
            TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            TextLabel.Font = Enum.Font.SourceSansBold
            TextLabel.TextSize = 14
            TextLabel.Parent = ScreenGui
            
            -- Tambahkan button untuk noclip toggle
            local NoclipButton = Instance.new("TextButton")
            NoclipButton.Size = UDim2.new(0, 200, 0, 30)
            NoclipButton.Position = UDim2.new(0, 10, 0, 70)
            NoclipButton.Text = "Toggle Noclip: " .. (NOCLIP_ENABLED and "ON" or "OFF")
            NoclipButton.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
            NoclipButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            NoclipButton.Parent = ScreenGui
            NoclipButton.MouseButton1Click:Connect(function()
                toggleNoclip()
                NoclipButton.Text = "Toggle Noclip: " .. (NOCLIP_ENABLED and "ON" or "OFF")
            end)
            
            print("[SYSTEM] Fallback GUI created")
        end)
    else
        print("[SYSTEM] GUI created successfully")
    end
    
    setupEventListeners()
    startESPScanning()
    
    -- Auto activate hooks
    task.spawn(function()
        task.wait(8)
        if not originalMinigames.MeltStart then
            local hookSuccess = pcall(hookMinigameModules)
            if hookSuccess then
                print("[SYSTEM] Forge hooks activated")
            else
                print("[SYSTEM] Failed to activate forge hooks")
            end
        end
    end)
    
    -- Auto start attack system
    task.spawn(function()
        task.wait(10)
        if flags.AutoAttackEnabled then
            local attackSuccess = pcall(startAutoAttackLoop)
            if attackSuccess then
                print("[SYSTEM] Auto attack system started")
            else
                print("[SYSTEM] Failed to start auto attack system")
            end
        end
    end)
    
    -- Initial noclip setup
    task.spawn(function()
        task.wait(2)
        if NOCLIP_ENABLED then
            print("[SYSTEM] Initial noclip setup")
            enableNoclip()
        end
    end)
    
    -- Cleanup on player leave
    Players.LocalPlayer.AncestryChanged:Connect(function()
        if not Players.LocalPlayer.Parent then
            print("[SYSTEM] Player leaving, cleaning up...")
            stopAutoHammer()
            cleanupESP()
            
            if MineConnection then
                MineConnection:Disconnect()
                MineConnection = nil
            end
            
            if AttackConnection then
                AttackConnection:Disconnect()
                AttackConnection = nil
            end
            
            if ESPConnection then
                task.cancel(ESPConnection)
                ESPConnection = nil
            end
            
            disableNoclip()
        end
    end)
    
    -- Cleanup on game close
    game:BindToClose(function()
        print("[SYSTEM] Game closing, cleaning up...")
        stopAutoHammer()
        cleanupESP()
        disableNoclip()
    end)
    
    print("[SYSTEM] Initialization complete")
    print("[SYSTEM] Press " .. toggleKeybind .. " to toggle GUI")
    print("========================================")
end

-- Delayed initialization
task.spawn(function()
    task.wait(5)
    print("[SYSTEM] Starting initialization...")
    local success, err = pcall(initializeSystem)
    if not success then
        warn("[SYSTEM] Initialization failed: " .. tostring(err))
        -- Coba buat notifikasi sederhana
        pcall(function()
            local ScreenGui = Instance.new("ScreenGui")
            ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
            
            local TextLabel = Instance.new("TextLabel")
            TextLabel.Size = UDim2.new(0, 300, 0, 100)
            TextLabel.Position = UDim2.new(0.5, -150, 0.5, -50)
            TextLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            TextLabel.BackgroundTransparency = 0.3
            TextLabel.Text = "JawirScript Loaded\nPress RightControl to open GUI"
            TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            TextLabel.Font = Enum.Font.SourceSansBold
            TextLabel.TextSize = 16
            TextLabel.TextWrapped = true
            TextLabel.Parent = ScreenGui
        end)
    end
end)

return {
    ActivateHooks = hookMinigameModules,
    StopHammer = stopAutoHammer,
    StartHammer = startAutoHammer,
    SetDebugMode = function(value) debugMode = value end,
    
    ToggleAutoMine = toggleAutoMine,
    SetMiningCooldown = setMiningCooldown,
    SetMiningSpeed = setMiningSpeed,
    SetSearchRadius = setSearchRadius,
    SetFlyHeight = setFlyHeight,
    SetMineDelay = setMineDelay,
    ForceMine = forceMineNearest,
    ToggleNoclip = toggleNoclip,
    
    ToggleAutoAttack = toggleAutoAttack,
    SetAttackCooldown = setAttackCooldown,
    SetAttackSpeed = setAttackSpeed,
    SetAttackSearchRadius = setAttackSearchRadius,
    SetAttackDelay = setAttackDelay,
    ForceAttack = forceAttackNearest,
    SetAttackWhileMining = function(value) flags.AttackWhileMining = value end,
    
    ToggleRockESP = toggleRockESP,
    ToggleMobESP = toggleMobESP,
    SetESPDistance = setESPDistance,
    SetMobESPDistance = setMobESPDistance,
    SetRockType = setRockType,
    SetMobType = setMobType,
    GetRockCounts = getRocksCountByType,
    GetMobCounts = getMobsCountByType,
    GetAllRockTypes = getAllRockTypes,
    GetAllMobTypes = getAllMobTypes,
    
    ToggleGUI = toggleGUI
}
